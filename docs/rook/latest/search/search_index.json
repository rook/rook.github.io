{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"CRDs/ceph-client-crd/","title":"CephClient CRD","text":"<p>Rook allows creation and updating clients through the custom resource definitions (CRDs). For more information about user management and capabilities see the Ceph docs.</p>"},{"location":"CRDs/ceph-client-crd/#use-case-connecting-to-ceph","title":"Use Case: Connecting to Ceph","text":"<p>Use Client CRD in case you want to integrate Rook with applications that are using LibRBD directly. For example for OpenStack deployment with Ceph backend use Client CRD to create OpenStack services users.</p> <p>The Client CRD is not needed for Flex or CSI driver users. The drivers create the needed users automatically.</p>"},{"location":"CRDs/ceph-client-crd/#prerequisites","title":"Prerequisites","text":"<p>This guide assumes you have created a Rook cluster as explained in the main Quickstart guide.</p>"},{"location":"CRDs/ceph-client-crd/#1-creating-ceph-user","title":"1. Creating Ceph User","text":"<p>To get you started, here is a simple example of a CRD to configure a Ceph client with capabilities.</p> <pre><code>---\napiVersion: ceph.rook.io/v1\nkind: CephClient\nmetadata:\n  name: example\n  namespace: rook-ceph\nspec:\n  caps:\n    mon: 'profile rbd, allow r'\n    osd: 'profile rbd pool=volumes, profile rbd pool=vms, profile rbd-read-only pool=images'\n</code></pre> <p>To use <code>CephClient</code> to connect to a Ceph cluster:</p>"},{"location":"CRDs/ceph-client-crd/#2-find-the-generated-secret-for-the-cephclient","title":"2. Find the generated secret for the <code>CephClient</code>","text":"<p>Once your <code>CephClient</code> has been processed by Rook, it will be updated to include your secret:</p> <pre><code>kubectl -n rook-ceph get cephclient example -o jsonpath='{.status.info.secretName}'\n</code></pre>"},{"location":"CRDs/ceph-client-crd/#3-extract-ceph-cluster-credentials-from-the-generated-secret","title":"3. Extract Ceph cluster credentials from the generated secret","text":"<p>Extract Ceph cluster credentials from the generated secret (note that the subkey will be your original client name):</p> <pre><code>kubectl --namespace rook-ceph get secret rook-ceph-client-example -o jsonpath=\"{.data.example}\" | base64 -d\n</code></pre> <p>The base64 encoded value that is returned is the password for your ceph client.</p>"},{"location":"CRDs/ceph-client-crd/#4-retrieve-the-mon-endpoints","title":"4. Retrieve the mon endpoints","text":"<p>To send writes to the cluster, you must retrieve the mons in use:</p> <pre><code>kubectl --namespace rook-ceph get configmap rook-ceph-mon-endpoints -o jsonpath='{.data.data}' | sed 's/.=//g'`\n</code></pre> <p>This command should produce a line that looks somewhat like this:</p> <pre><code>10.107.72.122:6789,10.103.244.218:6789,10.99.33.227:6789\n</code></pre>"},{"location":"CRDs/ceph-client-crd/#5-optional-generate-ceph-configuration-files","title":"5. (optional) Generate Ceph configuration files","text":"<p>If you choose to generate files for Ceph to use you will need to generate the following files:</p> <ul> <li>General configuration file (ex. <code>ceph.conf</code>)</li> <li>Keyring file (ex. <code>ceph.keyring</code>)</li> </ul> <p>Examples of the files follow:</p> <p><code>ceph.conf</code></p> <pre><code>[global]\nmon_host=10.107.72.122:6789,10.103.244.218:6789,10.99.33.227:6789\nlog file = /tmp/ceph-$pid.log\n</code></pre> <p><code>ceph.keyring</code></p> <pre><code>[client.example]\n  key = &lt; key, decoded from k8s secret&gt;\n  # The caps below are for a rbd workload -- you may need to edit/modify these capabilities for other workloads\n  # see https://docs.ceph.com/en/latest/cephfs/capabilities\n  caps mon = 'allow r'\n  caps osd = 'profile rbd pool=&lt;your pool&gt;, profile rb pool=&lt;another pool&gt;'\n</code></pre>"},{"location":"CRDs/ceph-client-crd/#6-connect-to-the-ceph-cluster-with-your-given-client-id","title":"6. Connect to the Ceph cluster with your given client ID","text":"<p>With the files we've created, you should be able to query the cluster by setting Ceph ENV variables and running <code>ceph status</code>:</p> <pre><code>export CEPH_CONF=/libsqliteceph/ceph.conf;\nexport CEPH_KEYRING=/libsqliteceph/ceph.keyring;\nexport CEPH_ARGS=--id example;\nceph status\n</code></pre> <p>With this config, the ceph tools (<code>ceph</code> CLI, in-program access, etc) can connect to and utilize the Ceph cluster.</p>"},{"location":"CRDs/ceph-client-crd/#use-case-sqlite","title":"Use Case: SQLite","text":"<p>The Ceph project contains a SQLite VFS that interacts with RADOS directly, called <code>libcephsqlite</code>.</p> <p>First, on your workload ensure that you have the appropriate packages installed that make <code>libcephsqlite.so</code> available:</p> <ul> <li><code>ceph</code> on Alpine</li> <li><code>libsqlite3-mod-ceph</code> on Ubuntu</li> <li><code>libcephsqlite</code> on Fedora</li> <li><code>ceph</code> on CentOS</li> </ul> <p>Without the appropriate package (or a from-scratch build of SQLite), you will be unable to load <code>libcephsqlite.so</code>.</p> <p>After creating a <code>CephClient</code> similar to <code>deploy/examples/sqlitevfs-client.yaml</code> and retrieving it's credentials, you may set the following ENV variables:</p> <pre><code>export CEPH_CONF=/libsqliteceph/ceph.conf;\nexport CEPH_KEYRING=/libsqliteceph/ceph.keyring;\nexport CEPH_ARGS=--id sqlitevfs\n</code></pre> <p>Then start your SQLite database:</p> <pre><code>sqlite&gt; .load libcephsqlite.so\nsqlite&gt; .open file:///poolname:/test.db?vfs=ceph\nsqlite&gt;\n</code></pre> <p>If those lines complete without error, you have successfully set up SQLite to access Ceph.</p> <p>See the libcephsqlite documentation for more information on the VFS and database URL format.</p>"},{"location":"CRDs/ceph-nfs-crd/","title":"CephNFS CRD","text":"<p>Rook allows exporting NFS shares of a CephFilesystem or CephObjectStore through the CephNFS custom resource definition.</p>"},{"location":"CRDs/ceph-nfs-crd/#example","title":"Example","text":"<pre><code>apiVersion: ceph.rook.io/v1\nkind: CephNFS\nmetadata:\n  name: my-nfs\n  namespace: rook-ceph\nspec:\n  # Settings for the NFS server\n  server:\n    active: 1\n\n    placement:\n      nodeAffinity:\n        requiredDuringSchedulingIgnoredDuringExecution:\n          nodeSelectorTerms:\n          - matchExpressions:\n            - key: role\n              operator: In\n              values:\n              - nfs-node\n      topologySpreadConstraints:\n      tolerations:\n      - key: nfs-node\n        operator: Exists\n      podAffinity:\n      podAntiAffinity:\n\n    annotations:\n      my-annotation: something\n\n    labels:\n      my-label: something\n\n    resources:\n      limits:\n        memory: \"8Gi\"\n      requests:\n        cpu: \"3\"\n        memory: \"8Gi\"\n\n    priorityClassName: \"\"\n\n    logLevel: NIV_INFO\n\n  security:\n    kerberos:\n      principalName: \"nfs\"\n      domainName: \"DOMAIN1.EXAMPLE.COM\"\n\n      configFiles:\n        volumeSource:\n          configMap:\n            name: my-krb5-config-files\n\n      keytabFile:\n        volumeSource:\n          secret:\n            secretName: my-nfs-keytab\n            defaultMode: 0600 # mode must be 0600\n\n    sssd:\n      sidecar:\n        image: registry.access.redhat.com/rhel7/sssd:latest\n\n        sssdConfigFile:\n          volumeSource:\n            configMap:\n              name: my-nfs-sssd-config\n              defaultMode: 0600 # mode must be 0600\n\n        debugLevel: 0\n\n        resources: {}\n</code></pre>"},{"location":"CRDs/ceph-nfs-crd/#nfs-settings","title":"NFS Settings","text":""},{"location":"CRDs/ceph-nfs-crd/#server","title":"Server","text":"<p>The <code>server</code> spec sets configuration for Rook-created NFS-Ganesha server pods.</p> <ul> <li><code>active</code>: The number of active NFS servers. Rook supports creating more than one active NFS     server, but cannot guarantee high availability. For values greater than 1, see the     known issue below.</li> <li><code>placement</code>: Kubernetes placement restrictions to apply to NFS server Pod(s). This is similar to     placement defined for daemons configured by the     CephCluster CRD.</li> <li><code>annotations</code>: Kubernetes annotations to apply to NFS server Pod(s)</li> <li><code>labels</code>: Kubernetes labels to apply to NFS server Pod(s)</li> <li><code>resources</code>: Kubernetes resource requests and limits to set on NFS server containers</li> <li><code>priorityClassName</code>: Set priority class name for the NFS server Pod(s)</li> <li><code>logLevel</code>: The log level that NFS-Ganesha servers should output.     Default value: <code>NIV_INFO</code>     Supported values: <code>NIV_NULL | NIV_FATAL | NIV_MAJ | NIV_CRIT | NIV_WARN | NIV_EVENT | NIV_INFO | NIV_DEBUG | NIV_MID_DEBUG | NIV_FULL_DEBUG | NB_LOG_LEVEL</code></li> <li><code>hostNetwork</code>: Whether host networking is enabled for the NFS server pod(s). If not set, the network     settings from the CephCluster CR will be applied.</li> </ul>"},{"location":"CRDs/ceph-nfs-crd/#security","title":"Security","text":"<p>The <code>security</code> spec sets security configuration for the NFS cluster.</p> <ul> <li> <p><code>kerberos</code>: Kerberos configures NFS-Ganesha to secure NFS client connections with Kerberos.</p> <ul> <li><code>principalName</code>: this value is combined with (a) the namespace and name of the CephNFS (with a     hyphen between) and (b) the Realm configured in the user-provided kerberos config file(s) to     determine the full service principal name: <code>&lt;principalName&gt;/&lt;namespace&gt;-&lt;name&gt;@&lt;realm&gt;</code>.     e.g., nfs/rook-ceph-my-nfs@example.net. For full details, see the     NFS security doc.</li> <li><code>domainName</code>: this is the domain name used in the kerberos credentials. This is used to     configure idmap to map the kerberos credentials to uid/gid. Without this configured, NFS-Ganesha     will use the anonuid/anongid configured (default: -2) when accessing the local filesystem.     eg., DOMAIN1.EXAMPLE.COM.     NFS security doc.</li> <li><code>configFiles</code>: defines where the Kerberos configuration should be sourced from. Config     files will be placed into the <code>/etc/krb5.conf.rook/</code> directory. For advanced usage, see the     NFS security doc.<ul> <li><code>volumeSource</code>: this is a standard Kubernetes VolumeSource for Kerberos configuration files     like what is normally used to configure Volumes for a Pod. For example, a ConfigMap, Secret,     or HostPath. The volume may contain multiple files, all of which will be loaded.</li> </ul> </li> <li><code>keytabFile</code>: defines where the Kerberos keytab should be sourced from. The keytab file will be     placed into <code>/etc/krb5.keytab</code>. For advanced usage, see the     NFS security doc.<ul> <li> <p><code>volumeSource</code>: this is a standard Kubernetes VolumeSource for the Kerberos keytab file like     what is normally used to configure Volumes for a Pod. For example, a Secret or HostPath.</p> <p>There are two requirements for the source's content:</p> <ol> <li>The config file must be mountable via <code>subPath: krb5.keytab</code>. For example, in a Secret, the     data item must be named <code>krb5.keytab</code>, or <code>items</code> must be defined to select the key and     give it path <code>krb5.keytab</code>. A HostPath directory must have the <code>krb5.keytab</code> file.</li> <li>The volume or config file must have mode 0600.</li> </ol> </li> </ul> </li> </ul> </li> <li> <p><code>sssd</code>: SSSD enables integration with System Security Services Daemon (SSSD). See also:     ID mapping via SSSD.</p> <ul> <li><code>sidecar</code>: Specifying this configuration tells Rook to run SSSD in a sidecar alongside the NFS     server in each NFS pod.<ul> <li><code>image</code>: defines the container image that should be used for the SSSD sidecar.</li> <li><code>sssdConfigFile</code>: defines where the SSSD configuration should be sourced from. The     config file will be placed into <code>/etc/sssd/sssd.conf</code>. For advanced usage, see the     NFS security doc.</li> <li><code>volumeSource</code>: this is a standard Kubernetes     VolumeSource like what is normally     used to configure Volumes for a Pod. For example, a ConfigMap, Secret, or HostPath.     There are two requirements for the source's content:<ol> <li>The config file must be mountable via <code>subPath: sssd.conf</code>. For example, in a ConfigMap,     the data item must be named <code>sssd.conf</code>, or <code>items</code> must be defined to select the key and     give it path <code>sssd.conf</code>. A HostPath directory must have the <code>sssd.conf</code> file.</li> <li>The volume or config file must have mode 0600.</li> </ol> </li> <li><code>additionalFiles</code>: adds any number of additional files into the SSSD sidecar. All files will     be placed into <code>/etc/sssd/rook-additional/&lt;subPath&gt;</code> and can be referenced by the SSSD     config file. For example, CA and/or TLS certificates to authenticate with Kerberos.<ul> <li><code>subPath</code>: the sub-path of <code>/etc/sssd/rook-additional</code> to add files into. This can     include <code>/</code> to create arbitrarily deep sub-paths if desired. If the <code>volumeSource</code> is a     file, this will refer to a file name.</li> <li><code>volumeSource</code>: this is a standard Kubernetes VolumeSource for additional files like what is     normally used to configure Volumes for a Pod. For example, a ConfigMap, Secret, or HostPath.     The volume may contain multiple files, a single file, or may be a file on its own (e.g., a     host path with <code>type: File</code>).</li> </ul> </li> <li><code>debugLevel</code>: sets the debug level for SSSD. If unset or <code>0</code>, Rook does nothing. Otherwise,     this may be a value between 1 and 10. See the     SSSD docs for more info.</li> <li><code>resources</code>: Kubernetes resource requests and limits to set on NFS server containers</li> </ul> </li> </ul> </li> </ul>"},{"location":"CRDs/ceph-nfs-crd/#scaling-the-active-server-count","title":"Scaling the active server count","text":"<p>It is possible to scale the size of the cluster up or down by modifying the <code>spec.server.active</code> field. Scaling the cluster size up can be done at will. Once the new server comes up, clients can be assigned to it immediately.</p> <p>The CRD always eliminates the highest index servers first, in reverse order from how they were started. Scaling down the cluster requires that clients be migrated from servers that will be eliminated to others. That process is currently a manual one and should be performed before reducing the size of the cluster.</p> <p>Warning</p> <p>See the known issue below about setting this value greater than one.</p>"},{"location":"CRDs/ceph-nfs-crd/#known-issues","title":"Known issues","text":""},{"location":"CRDs/ceph-nfs-crd/#serveractive-count-greater-than-1","title":"server.active count greater than 1","text":"<ul> <li>Active-active scale out does not work well with the NFS protocol. If one NFS server in a cluster     is offline, other servers may block client requests until the offline server returns, which may     not always happen due to the Kubernetes scheduler.<ul> <li>Workaround: It is safest to run only a single NFS server, but we do not limit this if it     benefits your use case.</li> </ul> </li> </ul>"},{"location":"CRDs/specification/","title":"Specification","text":"<p>Packages:</p> <ul> <li> ceph.rook.io/v1 </li> </ul>"},{"location":"CRDs/specification/#ceph.rook.io/v1","title":"ceph.rook.io/v1","text":"<p>Package v1 is the v1 version of the API.</p> <p>Resource Types:</p> <ul><li> CephBlockPool </li><li> CephBucketNotification </li><li> CephBucketTopic </li><li> CephCOSIDriver </li><li> CephClient </li><li> CephCluster </li><li> CephFilesystem </li><li> CephFilesystemMirror </li><li> CephFilesystemSubVolumeGroup </li><li> CephNFS </li><li> CephObjectRealm </li><li> CephObjectStore </li><li> CephObjectStoreUser </li><li> CephObjectZone </li><li> CephObjectZoneGroup </li><li> CephRBDMirror </li></ul>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephBlockPool","title":"CephBlockPool","text":"<p>CephBlockPool represents a Ceph Storage Pool</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephBlockPool</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NamedBlockPoolSpec  <code>name</code>  string  (Optional) <p>The desired name of the pool if different from the CephBlockPool CR name.</p> <code>PoolSpec</code>  PoolSpec  <p> (Members of <code>PoolSpec</code> are embedded into this type.) </p> <p>The core pool configuration</p> <code>status</code>  CephBlockPoolStatus"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephBucketNotification","title":"CephBucketNotification","text":"<p>CephBucketNotification represents a Bucket Notifications</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephBucketNotification</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  BucketNotificationSpec  <code>topic</code>  string  <p>The name of the topic associated with this notification</p> <code>events</code>  []BucketNotificationEvent  (Optional) <p>List of events that should trigger the notification</p> <code>filter</code>  NotificationFilterSpec  (Optional) <p>Spec of notification filter</p> <code>status</code>  Status  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephBucketTopic","title":"CephBucketTopic","text":"<p>CephBucketTopic represents a Ceph Object Topic for Bucket Notifications</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephBucketTopic</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  BucketTopicSpec  <code>objectStoreName</code>  string  <p>The name of the object store on which to define the topic</p> <code>objectStoreNamespace</code>  string  <p>The namespace of the object store on which to define the topic</p> <code>opaqueData</code>  string  (Optional) <p>Data which is sent in each event</p> <code>persistent</code>  bool  (Optional) <p>Indication whether notifications to this endpoint are persistent or not</p> <code>endpoint</code>  TopicEndpointSpec  <p>Contains the endpoint spec of the topic</p> <code>status</code>  BucketTopicStatus  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephCOSIDriver","title":"CephCOSIDriver","text":"<p>CephCOSIDriver represents the CRD for the Ceph COSI Driver Deployment</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephCOSIDriver</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  CephCOSIDriverSpec  <p>Spec represents the specification of a Ceph COSI Driver</p> <code>image</code>  string  (Optional) <p>Image is the container image to run the Ceph COSI driver</p> <code>objectProvisionerImage</code>  string  (Optional) <p>ObjectProvisionerImage is the container image to run the COSI driver sidecar</p> <code>deploymentStrategy</code>  COSIDeploymentStrategy  (Optional) <p>DeploymentStrategy is the strategy to use to deploy the COSI driver.</p> <code>placement</code>  Placement  (Optional) <p>Placement is the placement strategy to use for the COSI driver</p> <code>resources</code>  Kubernetes core/v1.ResourceRequirements  (Optional) <p>Resources is the resource requirements for the COSI driver</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephClient","title":"CephClient","text":"<p>CephClient represents a Ceph Client</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephClient</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  ClientSpec  <p>Spec represents the specification of a Ceph Client</p> <code>name</code>  string  (Optional) <code>caps</code>  map[string]string  <code>status</code>  CephClientStatus  (Optional) <p>Status represents the status of a Ceph Client</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephCluster","title":"CephCluster","text":"<p>CephCluster is a Ceph storage cluster</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephCluster</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  ClusterSpec  <code>cephVersion</code>  CephVersionSpec  (Optional) <p>The version information that instructs Rook to orchestrate a particular version of Ceph.</p> <code>storage</code>  StorageScopeSpec  (Optional) <p>A spec for available storage in the cluster and how it should be used</p> <code>annotations</code>  AnnotationsSpec  (Optional) <p>The annotations-related configuration to add/set on each Pod related object.</p> <code>labels</code>  LabelsSpec  (Optional) <p>The labels-related configuration to add/set on each Pod related object.</p> <code>placement</code>  PlacementSpec  (Optional) <p>The placement-related configuration to pass to kubernetes (affinity, node selector, tolerations).</p> <code>network</code>  NetworkSpec  (Optional) <p>Network related configuration</p> <code>resources</code>  ResourceSpec  (Optional) <p>Resources set resource requests and limits</p> <code>priorityClassNames</code>  PriorityClassNamesSpec  (Optional) <p>PriorityClassNames sets priority classes on components</p> <code>dataDirHostPath</code>  string  (Optional) <p>The path on the host where config and data can be persisted</p> <code>skipUpgradeChecks</code>  bool  (Optional) <p>SkipUpgradeChecks defines if an upgrade should be forced even if one of the check fails</p> <code>continueUpgradeAfterChecksEvenIfNotHealthy</code>  bool  (Optional) <p>ContinueUpgradeAfterChecksEvenIfNotHealthy defines if an upgrade should continue even if PGs are not clean</p> <code>waitTimeoutForHealthyOSDInMinutes</code>  time.Duration  (Optional) <p>WaitTimeoutForHealthyOSDInMinutes defines the time the operator would wait before an OSD can be stopped for upgrade or restart. If the timeout exceeds and OSD is not ok to stop, then the operator would skip upgrade for the current OSD and proceed with the next one if <code>continueUpgradeAfterChecksEvenIfNotHealthy</code> is <code>false</code>. If <code>continueUpgradeAfterChecksEvenIfNotHealthy</code> is <code>true</code>, then operator would continue with the upgrade of an OSD even if its not ok to stop after the timeout. This timeout won\u2019t be applied if <code>skipUpgradeChecks</code> is <code>true</code>. The default wait timeout is 10 minutes.</p> <code>upgradeOSDRequiresHealthyPGs</code>  bool  (Optional) <p>UpgradeOSDRequiresHealthyPGs defines if OSD upgrade requires PGs are clean. If set to <code>true</code> OSD upgrade process won\u2019t start until PGs are healthy. This configuration will be ignored if <code>skipUpgradeChecks</code> is <code>true</code>. Default is false.</p> <code>disruptionManagement</code>  DisruptionManagementSpec  (Optional) <p>A spec for configuring disruption management.</p> <code>mon</code>  MonSpec  (Optional) <p>A spec for mon related options</p> <code>crashCollector</code>  CrashCollectorSpec  (Optional) <p>A spec for the crash controller</p> <code>dashboard</code>  DashboardSpec  (Optional) <p>Dashboard settings</p> <code>monitoring</code>  MonitoringSpec  (Optional) <p>Prometheus based Monitoring settings</p> <code>external</code>  ExternalSpec  (Optional) <p>Whether the Ceph Cluster is running external to this Kubernetes cluster mon, mgr, osd, mds, and discover daemons will not be created for external clusters.</p> <code>mgr</code>  MgrSpec  (Optional) <p>A spec for mgr related options</p> <code>removeOSDsIfOutAndSafeToRemove</code>  bool  (Optional) <p>Remove the OSD that is out and safe to remove only if this option is true</p> <code>cleanupPolicy</code>  CleanupPolicySpec  (Optional) <p>Indicates user intent when deleting a cluster; blocks orchestration and should not be set if cluster deletion is not imminent.</p> <code>healthCheck</code>  CephClusterHealthCheckSpec  (Optional) <p>Internal daemon healthchecks and liveness probe</p> <code>security</code>  SecuritySpec  (Optional) <p>Security represents security settings</p> <code>logCollector</code>  LogCollectorSpec  (Optional) <p>Logging represents loggings settings</p> <code>csi</code>  CSIDriverSpec  (Optional) <p>CSI Driver Options applied per cluster.</p> <code>cephConfig</code>  map[string]map[string]string  (Optional) <p>Ceph Config options</p> <code>status</code>  ClusterStatus  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephFilesystem","title":"CephFilesystem","text":"<p>CephFilesystem represents a Ceph Filesystem</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephFilesystem</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  FilesystemSpec  <code>metadataPool</code>  NamedPoolSpec  <p>The metadata pool settings</p> <code>dataPools</code>  []NamedPoolSpec  <p>The data pool settings, with optional predefined pool name.</p> <code>preservePoolNames</code>  bool  (Optional) <p>Preserve pool names as specified</p> <code>preservePoolsOnDelete</code>  bool  (Optional) <p>Preserve pools on filesystem deletion</p> <code>preserveFilesystemOnDelete</code>  bool  (Optional) <p>Preserve the fs in the cluster on CephFilesystem CR deletion. Setting this to true automatically implies PreservePoolsOnDelete is true.</p> <code>metadataServer</code>  MetadataServerSpec  <p>The mds pod info</p> <code>mirroring</code>  FSMirroringSpec  (Optional) <p>The mirroring settings</p> <code>statusCheck</code>  MirrorHealthCheckSpec  <p>The mirroring statusCheck</p> <code>status</code>  CephFilesystemStatus"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephFilesystemMirror","title":"CephFilesystemMirror","text":"<p>CephFilesystemMirror is the Ceph Filesystem Mirror object definition</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephFilesystemMirror</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  FilesystemMirroringSpec  <code>placement</code>  Placement  (Optional) <p>The affinity to place the rgw pods (default is to place on any available node)</p> <code>annotations</code>  Annotations  (Optional) <p>The annotations-related configuration to add/set on each Pod related object.</p> <code>labels</code>  Labels  (Optional) <p>The labels-related configuration to add/set on each Pod related object.</p> <code>resources</code>  Kubernetes core/v1.ResourceRequirements  (Optional) <p>The resource requirements for the cephfs-mirror pods</p> <code>priorityClassName</code>  string  (Optional) <p>PriorityClassName sets priority class on the cephfs-mirror pods</p> <code>status</code>  Status  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephFilesystemSubVolumeGroup","title":"CephFilesystemSubVolumeGroup","text":"<p>CephFilesystemSubVolumeGroup represents a Ceph Filesystem SubVolumeGroup</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephFilesystemSubVolumeGroup</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  CephFilesystemSubVolumeGroupSpec  <p>Spec represents the specification of a Ceph Filesystem SubVolumeGroup</p> <code>name</code>  string  (Optional) <p>The name of the subvolume group. If not set, the default is the name of the subvolumeGroup CR.</p> <code>filesystemName</code>  string  <p>FilesystemName is the name of Ceph Filesystem SubVolumeGroup volume name. Typically it\u2019s the name of the CephFilesystem CR. If not coming from the CephFilesystem CR, it can be retrieved from the list of Ceph Filesystem volumes with <code>ceph fs volume ls</code>. To learn more about Ceph Filesystem abstractions see https://docs.ceph.com/en/latest/cephfs/fs-volumes/#fs-volumes-and-subvolumes</p> <code>pinning</code>  CephFilesystemSubVolumeGroupSpecPinning  (Optional) <p>Pinning configuration of CephFilesystemSubVolumeGroup, reference https://docs.ceph.com/en/latest/cephfs/fs-volumes/#pinning-subvolumes-and-subvolume-groups only one out of (export, distributed, random) can be set at a time</p> <code>quota</code>  k8s.io/apimachinery/pkg/api/resource.Quantity  (Optional) <p>Quota size of the Ceph Filesystem subvolume group.</p> <code>dataPoolName</code>  string  (Optional) <p>The data pool name for the Ceph Filesystem subvolume group layout, if the default CephFS pool is not desired.</p> <code>status</code>  CephFilesystemSubVolumeGroupStatus  (Optional) <p>Status represents the status of a CephFilesystem SubvolumeGroup</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephNFS","title":"CephNFS","text":"<p>CephNFS represents a Ceph NFS</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephNFS</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NFSGaneshaSpec  <code>rados</code>  GaneshaRADOSSpec  (Optional) <p>RADOS is the Ganesha RADOS specification</p> <code>server</code>  GaneshaServerSpec  <p>Server is the Ganesha Server specification</p> <code>security</code>  NFSSecuritySpec  (Optional) <p>Security allows specifying security configurations for the NFS cluster</p> <code>status</code>  Status  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephObjectRealm","title":"CephObjectRealm","text":"<p>CephObjectRealm represents a Ceph Object Store Gateway Realm</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephObjectRealm</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  ObjectRealmSpec  (Optional) <code>pull</code>  PullSpec  <code>status</code>  Status  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephObjectStore","title":"CephObjectStore","text":"<p>CephObjectStore represents a Ceph Object Store Gateway</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephObjectStore</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  ObjectStoreSpec  <code>metadataPool</code>  PoolSpec  (Optional) <p>The metadata pool settings</p> <code>dataPool</code>  PoolSpec  (Optional) <p>The data pool settings</p> <code>sharedPools</code>  ObjectSharedPoolsSpec  (Optional) <p>The pool information when configuring RADOS namespaces in existing pools.</p> <code>preservePoolsOnDelete</code>  bool  (Optional) <p>Preserve pools on object store deletion</p> <code>gateway</code>  GatewaySpec  (Optional) <p>The rgw pod info</p> <code>protocols</code>  ProtocolSpec  (Optional) <p>The protocol specification</p> <code>auth</code>  AuthSpec  (Optional) <p>The authentication configuration</p> <code>zone</code>  ZoneSpec  (Optional) <p>The multisite info</p> <code>healthCheck</code>  ObjectHealthCheckSpec  (Optional) <p>The RGW health probes</p> <code>security</code>  ObjectStoreSecuritySpec  (Optional) <p>Security represents security settings</p> <code>allowUsersInNamespaces</code>  []string  (Optional) <p>The list of allowed namespaces in addition to the object store namespace where ceph object store users may be created. Specify \u201c*\u201d to allow all namespaces, otherwise list individual namespaces that are to be allowed. This is useful for applications that need object store credentials to be created in their own namespace, where neither OBCs nor COSI is being used to create buckets. The default is empty.</p> <code>hosting</code>  ObjectStoreHostingSpec  (Optional) <p>Hosting settings for the object store. A common use case for hosting configuration is to inform Rook of endpoints that support DNS wildcards, which in turn allows virtual host-style bucket addressing.</p> <code>status</code>  ObjectStoreStatus"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephObjectStoreUser","title":"CephObjectStoreUser","text":"<p>CephObjectStoreUser represents a Ceph Object Store Gateway User</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephObjectStoreUser</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  ObjectStoreUserSpec  <code>store</code>  string  (Optional) <p>The store the user will be created in</p> <code>displayName</code>  string  (Optional) <p>The display name for the ceph users</p> <code>capabilities</code>  ObjectUserCapSpec  (Optional) <code>quotas</code>  ObjectUserQuotaSpec  (Optional) <code>clusterNamespace</code>  string  (Optional) <p>The namespace where the parent CephCluster and CephObjectStore are found</p> <code>status</code>  ObjectStoreUserStatus  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephObjectZone","title":"CephObjectZone","text":"<p>CephObjectZone represents a Ceph Object Store Gateway Zone</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephObjectZone</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  ObjectZoneSpec  <code>zoneGroup</code>  string  <p>The display name for the ceph users</p> <code>metadataPool</code>  PoolSpec  (Optional) <p>The metadata pool settings</p> <code>dataPool</code>  PoolSpec  (Optional) <p>The data pool settings</p> <code>sharedPools</code>  ObjectSharedPoolsSpec  (Optional) <p>The pool information when configuring RADOS namespaces in existing pools.</p> <code>customEndpoints</code>  []string  (Optional) <p>If this zone cannot be accessed from other peer Ceph clusters via the ClusterIP Service endpoint created by Rook, you must set this to the externally reachable endpoint(s). You may include the port in the definition. For example: \u201chttps://my-object-store.my-domain.net:443\u201d. In many cases, you should set this to the endpoint of the ingress resource that makes the CephObjectStore associated with this CephObjectStoreZone reachable to peer clusters. The list can have one or more endpoints pointing to different RGW servers in the zone.</p> <p>If a CephObjectStore endpoint is omitted from this list, that object store\u2019s gateways will not receive multisite replication data (see CephObjectStore.spec.gateway.disableMultisiteSyncTraffic).</p> <code>preservePoolsOnDelete</code>  bool  (Optional) <p>Preserve pools on object zone deletion</p> <code>status</code>  Status  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephObjectZoneGroup","title":"CephObjectZoneGroup","text":"<p>CephObjectZoneGroup represents a Ceph Object Store Gateway Zone Group</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephObjectZoneGroup</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  ObjectZoneGroupSpec  <code>realm</code>  string  <p>The display name for the ceph users</p> <code>status</code>  Status  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephRBDMirror","title":"CephRBDMirror","text":"<p>CephRBDMirror represents a Ceph RBD Mirror</p> Field Description <code>apiVersion</code> string <code> ceph.rook.io/v1 </code> <code>kind</code> string  <code>CephRBDMirror</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  RBDMirroringSpec  <code>count</code>  int  <p>Count represents the number of rbd mirror instance to run</p> <code>peers</code>  MirroringPeerSpec  (Optional) <p>Peers represents the peers spec</p> <code>placement</code>  Placement  (Optional) <p>The affinity to place the rgw pods (default is to place on any available node)</p> <code>annotations</code>  Annotations  (Optional) <p>The annotations-related configuration to add/set on each Pod related object.</p> <code>labels</code>  Labels  (Optional) <p>The labels-related configuration to add/set on each Pod related object.</p> <code>resources</code>  Kubernetes core/v1.ResourceRequirements  (Optional) <p>The resource requirements for the rbd mirror pods</p> <code>priorityClassName</code>  string  (Optional) <p>PriorityClassName sets priority class on the rbd mirror pods</p> <code>status</code>  Status  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.AMQPEndpointSpec","title":"AMQPEndpointSpec","text":"<p> (Appears on:TopicEndpointSpec) </p> <p>AMQPEndpointSpec represent the spec of an AMQP endpoint of a Bucket Topic</p> Field Description <code>uri</code>  string  <p>The URI of the AMQP endpoint to push notification to</p> <code>exchange</code>  string  <p>Name of the exchange that is used to route messages based on topics</p> <code>disableVerifySSL</code>  bool  (Optional) <p>Indicate whether the server certificate is validated by the client or not</p> <code>ackLevel</code>  string  (Optional) <p>The ack level required for this topic (none/broker/routeable)</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.AdditionalVolumeMount","title":"AdditionalVolumeMount","text":"<p>AdditionalVolumeMount represents the source from where additional files in pod containers should come from and what subdirectory they are made available in.</p> Field Description <code>subPath</code>  string  <p>SubPath defines the sub-path (subdirectory) of the directory root where the volumeSource will be mounted. All files/keys in the volume source\u2019s volume will be mounted to the subdirectory. This is not the same as the Kubernetes <code>subPath</code> volume mount option. Each subPath definition must be unique and must not contain \u2018:\u2019.</p> <code>volumeSource</code>  ConfigFileVolumeSource  <p>VolumeSource accepts a pared down version of the standard Kubernetes VolumeSource for the additional file(s) like what is normally used to configure Volumes for a Pod. Fore example, a ConfigMap, Secret, or HostPath. Each VolumeSource adds one or more additional files to the container <code>&lt;directory-root&gt;/&lt;subPath&gt;</code> directory. Be aware that some files may need to have a specific file mode like 0600 due to application requirements. For example, CA or TLS certificates.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.AdditionalVolumeMounts","title":"AdditionalVolumeMounts (<code>[]github.com/rook/rook/pkg/apis/ceph.rook.io/v1.AdditionalVolumeMount</code> alias)","text":"<p> (Appears on:GatewaySpec, SSSDSidecar) </p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.AddressRangesSpec","title":"AddressRangesSpec","text":"<p> (Appears on:NetworkSpec) </p> Field Description <code>public</code>  CIDRList  (Optional) <p>Public defines a list of CIDRs to use for Ceph public network communication.</p> <code>cluster</code>  CIDRList  (Optional) <p>Cluster defines a list of CIDRs to use for Ceph cluster network communication.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.Annotations","title":"Annotations (<code>map[string]string</code> alias)","text":"<p> (Appears on:FilesystemMirroringSpec, GaneshaServerSpec, GatewaySpec, MetadataServerSpec, RBDMirroringSpec, RGWServiceSpec) </p> <p>Annotations are annotations</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.AnnotationsSpec","title":"AnnotationsSpec (<code>map[github.com/rook/rook/pkg/apis/ceph.rook.io/v1.KeyType]github.com/rook/rook/pkg/apis/ceph.rook.io/v1.Annotations</code> alias)","text":"<p> (Appears on:ClusterSpec) </p> <p>AnnotationsSpec is the main spec annotation for all daemons</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.AuthSpec","title":"AuthSpec","text":"<p> (Appears on:ObjectStoreSpec) </p> <p>AuthSpec represents the authentication protocol configuration of a Ceph Object Store Gateway</p> Field Description <code>keystone</code>  KeystoneSpec  (Optional) <p>The spec for Keystone</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.BucketNotificationEvent","title":"BucketNotificationEvent (<code>string</code> alias)","text":"<p> (Appears on:BucketNotificationSpec) </p> <p>BucketNotificationSpec represent the event type of the bucket notification</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.BucketNotificationSpec","title":"BucketNotificationSpec","text":"<p> (Appears on:CephBucketNotification) </p> <p>BucketNotificationSpec represent the spec of a Bucket Notification</p> Field Description <code>topic</code>  string  <p>The name of the topic associated with this notification</p> <code>events</code>  []BucketNotificationEvent  (Optional) <p>List of events that should trigger the notification</p> <code>filter</code>  NotificationFilterSpec  (Optional) <p>Spec of notification filter</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.BucketTopicSpec","title":"BucketTopicSpec","text":"<p> (Appears on:CephBucketTopic) </p> <p>BucketTopicSpec represent the spec of a Bucket Topic</p> Field Description <code>objectStoreName</code>  string  <p>The name of the object store on which to define the topic</p> <code>objectStoreNamespace</code>  string  <p>The namespace of the object store on which to define the topic</p> <code>opaqueData</code>  string  (Optional) <p>Data which is sent in each event</p> <code>persistent</code>  bool  (Optional) <p>Indication whether notifications to this endpoint are persistent or not</p> <code>endpoint</code>  TopicEndpointSpec  <p>Contains the endpoint spec of the topic</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.BucketTopicStatus","title":"BucketTopicStatus","text":"<p> (Appears on:CephBucketTopic) </p> <p>BucketTopicStatus represents the Status of a CephBucketTopic</p> Field Description <code>phase</code>  string  (Optional) <code>ARN</code>  string  (Optional) <p>The ARN of the topic generated by the RGW</p> <code>observedGeneration</code>  int64  (Optional) <p>ObservedGeneration is the latest generation observed by the controller.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CIDR","title":"CIDR (<code>string</code> alias)","text":"<p>An IPv4 or IPv6 network CIDR.</p> <p>This naive kubebuilder regex provides immediate feedback for some typos and for a common problem case where the range spec is forgotten (e.g., /24). Rook does in-depth validation in code.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.COSIDeploymentStrategy","title":"COSIDeploymentStrategy (<code>string</code> alias)","text":"<p> (Appears on:CephCOSIDriverSpec) </p> <p>COSIDeploymentStrategy represents the strategy to use to deploy the Ceph COSI driver</p> Value Description <p>\"Always\"</p> <p>Always means the Ceph COSI driver will be deployed even if the object store is not present</p> <p>\"Auto\"</p> <p>Auto means the Ceph COSI driver will be deployed automatically if object store is present</p> <p>\"Never\"</p> <p>Never means the Ceph COSI driver will never deployed</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CSICephFSSpec","title":"CSICephFSSpec","text":"<p> (Appears on:CSIDriverSpec) </p> <p>CSICephFSSpec defines the settings for CephFS CSI driver.</p> Field Description <code>kernelMountOptions</code>  string  (Optional) <p>KernelMountOptions defines the mount options for kernel mounter.</p> <code>fuseMountOptions</code>  string  (Optional) <p>FuseMountOptions defines the mount options for ceph fuse mounter.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CSIDriverSpec","title":"CSIDriverSpec","text":"<p> (Appears on:ClusterSpec) </p> <p>CSIDriverSpec defines CSI Driver settings applied per cluster.</p> Field Description <code>readAffinity</code>  ReadAffinitySpec  (Optional) <p>ReadAffinity defines the read affinity settings for CSI driver.</p> <code>cephfs</code>  CSICephFSSpec  (Optional) <p>CephFS defines CSI Driver settings for CephFS driver.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.Capacity","title":"Capacity","text":"<p> (Appears on:CephStatus) </p> <p>Capacity is the capacity information of a Ceph Cluster</p> Field Description <code>bytesTotal</code>  uint64  <code>bytesUsed</code>  uint64  <code>bytesAvailable</code>  uint64  <code>lastUpdated</code>  string"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephBlockPoolRadosNamespace","title":"CephBlockPoolRadosNamespace","text":"<p>CephBlockPoolRadosNamespace represents a Ceph BlockPool Rados Namespace</p> Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  CephBlockPoolRadosNamespaceSpec  <p>Spec represents the specification of a Ceph BlockPool Rados Namespace</p> <code>name</code>  string  (Optional) <p>The name of the CephBlockPoolRadosNamespaceSpec namespace. If not set, the default is the name of the CR.</p> <code>blockPoolName</code>  string  <p>BlockPoolName is the name of Ceph BlockPool. Typically it\u2019s the name of the CephBlockPool CR.</p> <code>mirroring</code>  RadosNamespaceMirroring  (Optional) <p>Mirroring configuration of CephBlockPoolRadosNamespace</p> <code>status</code>  CephBlockPoolRadosNamespaceStatus  (Optional) <p>Status represents the status of a CephBlockPool Rados Namespace</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephBlockPoolRadosNamespaceSpec","title":"CephBlockPoolRadosNamespaceSpec","text":"<p> (Appears on:CephBlockPoolRadosNamespace) </p> <p>CephBlockPoolRadosNamespaceSpec represents the specification of a CephBlockPool Rados Namespace</p> Field Description <code>name</code>  string  (Optional) <p>The name of the CephBlockPoolRadosNamespaceSpec namespace. If not set, the default is the name of the CR.</p> <code>blockPoolName</code>  string  <p>BlockPoolName is the name of Ceph BlockPool. Typically it\u2019s the name of the CephBlockPool CR.</p> <code>mirroring</code>  RadosNamespaceMirroring  (Optional) <p>Mirroring configuration of CephBlockPoolRadosNamespace</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephBlockPoolRadosNamespaceStatus","title":"CephBlockPoolRadosNamespaceStatus","text":"<p> (Appears on:CephBlockPoolRadosNamespace) </p> <p>CephBlockPoolRadosNamespaceStatus represents the Status of Ceph BlockPool Rados Namespace</p> Field Description <code>phase</code>  ConditionType  (Optional) <code>info</code>  map[string]string  (Optional) <code>mirroringStatus</code>  MirroringStatusSpec  (Optional) <code>mirroringInfo</code>  MirroringInfoSpec  (Optional) <code>snapshotScheduleStatus</code>  SnapshotScheduleStatusSpec  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephBlockPoolStatus","title":"CephBlockPoolStatus","text":"<p> (Appears on:CephBlockPool) </p> <p>CephBlockPoolStatus represents the mirroring status of Ceph Storage Pool</p> Field Description <code>phase</code>  ConditionType  (Optional) <code>mirroringStatus</code>  MirroringStatusSpec  (Optional) <code>mirroringInfo</code>  MirroringInfoSpec  (Optional) <code>poolID</code>  int  <p>optional</p> <code>snapshotScheduleStatus</code>  SnapshotScheduleStatusSpec  (Optional) <code>info</code>  map[string]string  (Optional) <code>observedGeneration</code>  int64  (Optional) <p>ObservedGeneration is the latest generation observed by the controller.</p> <code>conditions</code>  []Condition"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephCOSIDriverSpec","title":"CephCOSIDriverSpec","text":"<p> (Appears on:CephCOSIDriver) </p> <p>CephCOSIDriverSpec represents the specification of a Ceph COSI Driver</p> Field Description <code>image</code>  string  (Optional) <p>Image is the container image to run the Ceph COSI driver</p> <code>objectProvisionerImage</code>  string  (Optional) <p>ObjectProvisionerImage is the container image to run the COSI driver sidecar</p> <code>deploymentStrategy</code>  COSIDeploymentStrategy  (Optional) <p>DeploymentStrategy is the strategy to use to deploy the COSI driver.</p> <code>placement</code>  Placement  (Optional) <p>Placement is the placement strategy to use for the COSI driver</p> <code>resources</code>  Kubernetes core/v1.ResourceRequirements  (Optional) <p>Resources is the resource requirements for the COSI driver</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephClientStatus","title":"CephClientStatus","text":"<p> (Appears on:CephClient) </p> <p>CephClientStatus represents the Status of Ceph Client</p> Field Description <code>phase</code>  ConditionType  (Optional) <code>info</code>  map[string]string  (Optional) <code>observedGeneration</code>  int64  (Optional) <p>ObservedGeneration is the latest generation observed by the controller.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephClusterHealthCheckSpec","title":"CephClusterHealthCheckSpec","text":"<p> (Appears on:ClusterSpec) </p> <p>CephClusterHealthCheckSpec represent the healthcheck for Ceph daemons</p> Field Description <code>daemonHealth</code>  DaemonHealthSpec  (Optional) <p>DaemonHealth is the health check for a given daemon</p> <code>livenessProbe</code>  map[github.com/rook/rook/pkg/apis/ceph.rook.io/v1.KeyType]*github.com/rook/rook/pkg/apis/ceph.rook.io/v1.ProbeSpec  (Optional) <p>LivenessProbe allows changing the livenessProbe configuration for a given daemon</p> <code>startupProbe</code>  map[github.com/rook/rook/pkg/apis/ceph.rook.io/v1.KeyType]*github.com/rook/rook/pkg/apis/ceph.rook.io/v1.ProbeSpec  (Optional) <p>StartupProbe allows changing the startupProbe configuration for a given daemon</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephDaemonsVersions","title":"CephDaemonsVersions","text":"<p> (Appears on:CephStatus) </p> <p>CephDaemonsVersions show the current ceph version for different ceph daemons</p> Field Description <code>mon</code>  map[string]int  (Optional) <p>Mon shows Mon Ceph version</p> <code>mgr</code>  map[string]int  (Optional) <p>Mgr shows Mgr Ceph version</p> <code>osd</code>  map[string]int  (Optional) <p>Osd shows Osd Ceph version</p> <code>rgw</code>  map[string]int  (Optional) <p>Rgw shows Rgw Ceph version</p> <code>mds</code>  map[string]int  (Optional) <p>Mds shows Mds Ceph version</p> <code>rbd-mirror</code>  map[string]int  (Optional) <p>RbdMirror shows RbdMirror Ceph version</p> <code>cephfs-mirror</code>  map[string]int  (Optional) <p>CephFSMirror shows CephFSMirror Ceph version</p> <code>overall</code>  map[string]int  (Optional) <p>Overall shows overall Ceph version</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephExporterSpec","title":"CephExporterSpec","text":"<p> (Appears on:MonitoringSpec) </p> Field Description <code>perfCountersPrioLimit</code>  int64  <p>Only performance counters greater than or equal to this option are fetched</p> <code>statsPeriodSeconds</code>  int64  <p>Time to wait before sending requests again to exporter server (seconds)</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephFilesystemStatus","title":"CephFilesystemStatus","text":"<p> (Appears on:CephFilesystem) </p> <p>CephFilesystemStatus represents the status of a Ceph Filesystem</p> Field Description <code>phase</code>  ConditionType  (Optional) <code>snapshotScheduleStatus</code>  FilesystemSnapshotScheduleStatusSpec  (Optional) <code>info</code>  map[string]string  (Optional) <p>Use only info and put mirroringStatus in it?</p> <code>mirroringStatus</code>  FilesystemMirroringInfoSpec  (Optional) <p>MirroringStatus is the filesystem mirroring status</p> <code>conditions</code>  []Condition  <code>observedGeneration</code>  int64  (Optional) <p>ObservedGeneration is the latest generation observed by the controller.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephFilesystemSubVolumeGroupSpec","title":"CephFilesystemSubVolumeGroupSpec","text":"<p> (Appears on:CephFilesystemSubVolumeGroup) </p> <p>CephFilesystemSubVolumeGroupSpec represents the specification of a Ceph Filesystem SubVolumeGroup</p> Field Description <code>name</code>  string  (Optional) <p>The name of the subvolume group. If not set, the default is the name of the subvolumeGroup CR.</p> <code>filesystemName</code>  string  <p>FilesystemName is the name of Ceph Filesystem SubVolumeGroup volume name. Typically it\u2019s the name of the CephFilesystem CR. If not coming from the CephFilesystem CR, it can be retrieved from the list of Ceph Filesystem volumes with <code>ceph fs volume ls</code>. To learn more about Ceph Filesystem abstractions see https://docs.ceph.com/en/latest/cephfs/fs-volumes/#fs-volumes-and-subvolumes</p> <code>pinning</code>  CephFilesystemSubVolumeGroupSpecPinning  (Optional) <p>Pinning configuration of CephFilesystemSubVolumeGroup, reference https://docs.ceph.com/en/latest/cephfs/fs-volumes/#pinning-subvolumes-and-subvolume-groups only one out of (export, distributed, random) can be set at a time</p> <code>quota</code>  k8s.io/apimachinery/pkg/api/resource.Quantity  (Optional) <p>Quota size of the Ceph Filesystem subvolume group.</p> <code>dataPoolName</code>  string  (Optional) <p>The data pool name for the Ceph Filesystem subvolume group layout, if the default CephFS pool is not desired.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephFilesystemSubVolumeGroupSpecPinning","title":"CephFilesystemSubVolumeGroupSpecPinning","text":"<p> (Appears on:CephFilesystemSubVolumeGroupSpec) </p> <p>CephFilesystemSubVolumeGroupSpecPinning represents the pinning configuration of SubVolumeGroup</p> Field Description <code>export</code>  int  (Optional) <code>distributed</code>  int  (Optional) <code>random,</code>  float64  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephFilesystemSubVolumeGroupStatus","title":"CephFilesystemSubVolumeGroupStatus","text":"<p> (Appears on:CephFilesystemSubVolumeGroup) </p> <p>CephFilesystemSubVolumeGroupStatus represents the Status of Ceph Filesystem SubVolumeGroup</p> Field Description <code>phase</code>  ConditionType  (Optional) <code>info</code>  map[string]string  (Optional) <code>observedGeneration</code>  int64  (Optional) <p>ObservedGeneration is the latest generation observed by the controller.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephHealthMessage","title":"CephHealthMessage","text":"<p> (Appears on:CephStatus) </p> <p>CephHealthMessage represents the health message of a Ceph Cluster</p> Field Description <code>severity</code>  string  <code>message</code>  string"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephNetworkType","title":"CephNetworkType (<code>string</code> alias)","text":"<p>CephNetworkType should be \u201cpublic\u201d or \u201ccluster\u201d. Allow any string so that over-specified legacy clusters do not break on CRD update.</p> Value Description <p>\"cluster\"</p> <p>\"public\"</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephStatus","title":"CephStatus","text":"<p> (Appears on:ClusterStatus) </p> <p>CephStatus is the details health of a Ceph Cluster</p> Field Description <code>health</code>  string  <code>details</code>  map[string]github.com/rook/rook/pkg/apis/ceph.rook.io/v1.CephHealthMessage  <code>lastChecked</code>  string  <code>lastChanged</code>  string  <code>previousHealth</code>  string  <code>capacity</code>  Capacity  <code>versions</code>  CephDaemonsVersions  (Optional) <code>fsid</code>  string"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephStorage","title":"CephStorage","text":"<p> (Appears on:ClusterStatus) </p> <p>CephStorage represents flavors of Ceph Cluster Storage</p> Field Description <code>deviceClasses</code>  []DeviceClasses  <code>osd</code>  OSDStatus  <code>deprecatedOSDs</code>  map[string][]int"},{"location":"CRDs/specification/#ceph.rook.io/v1.CephVersionSpec","title":"CephVersionSpec","text":"<p> (Appears on:ClusterSpec) </p> <p>CephVersionSpec represents the settings for the Ceph version that Rook is orchestrating.</p> Field Description <code>image</code>  string  (Optional) <p>Image is the container image used to launch the ceph daemons, such as quay.io/ceph/ceph: The full list of images can be found at https://quay.io/repository/ceph/ceph?tab=tags <code>allowUnsupported</code>  bool  (Optional) <p>Whether to allow unsupported versions (do not set to true in production)</p> <code>imagePullPolicy</code>  Kubernetes core/v1.PullPolicy  (Optional) <p>ImagePullPolicy describes a policy for if/when to pull a container image One of Always, Never, IfNotPresent.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CleanupConfirmationProperty","title":"CleanupConfirmationProperty (<code>string</code> alias)","text":"<p> (Appears on:CleanupPolicySpec) </p> <p>CleanupConfirmationProperty represents the cleanup confirmation</p> Value Description <p>\"yes-really-destroy-data\"</p> <p>DeleteDataDirOnHostsConfirmation represents the validation to destroy dataDirHostPath</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CleanupPolicySpec","title":"CleanupPolicySpec","text":"<p> (Appears on:ClusterSpec) </p> <p>CleanupPolicySpec represents a Ceph Cluster cleanup policy</p> Field Description <code>confirmation</code>  CleanupConfirmationProperty  (Optional) <p>Confirmation represents the cleanup confirmation</p> <code>sanitizeDisks</code>  SanitizeDisksSpec  (Optional) <p>SanitizeDisks represents way we sanitize disks</p> <code>allowUninstallWithVolumes</code>  bool  (Optional) <p>AllowUninstallWithVolumes defines whether we can proceed with the uninstall if they are RBD images still present</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ClientSpec","title":"ClientSpec","text":"<p> (Appears on:CephClient) </p> <p>ClientSpec represents the specification of a Ceph Client</p> Field Description <code>name</code>  string  (Optional) <code>caps</code>  map[string]string"},{"location":"CRDs/specification/#ceph.rook.io/v1.ClusterSpec","title":"ClusterSpec","text":"<p> (Appears on:CephCluster) </p> <p>ClusterSpec represents the specification of Ceph Cluster</p> Field Description <code>cephVersion</code>  CephVersionSpec  (Optional) <p>The version information that instructs Rook to orchestrate a particular version of Ceph.</p> <code>storage</code>  StorageScopeSpec  (Optional) <p>A spec for available storage in the cluster and how it should be used</p> <code>annotations</code>  AnnotationsSpec  (Optional) <p>The annotations-related configuration to add/set on each Pod related object.</p> <code>labels</code>  LabelsSpec  (Optional) <p>The labels-related configuration to add/set on each Pod related object.</p> <code>placement</code>  PlacementSpec  (Optional) <p>The placement-related configuration to pass to kubernetes (affinity, node selector, tolerations).</p> <code>network</code>  NetworkSpec  (Optional) <p>Network related configuration</p> <code>resources</code>  ResourceSpec  (Optional) <p>Resources set resource requests and limits</p> <code>priorityClassNames</code>  PriorityClassNamesSpec  (Optional) <p>PriorityClassNames sets priority classes on components</p> <code>dataDirHostPath</code>  string  (Optional) <p>The path on the host where config and data can be persisted</p> <code>skipUpgradeChecks</code>  bool  (Optional) <p>SkipUpgradeChecks defines if an upgrade should be forced even if one of the check fails</p> <code>continueUpgradeAfterChecksEvenIfNotHealthy</code>  bool  (Optional) <p>ContinueUpgradeAfterChecksEvenIfNotHealthy defines if an upgrade should continue even if PGs are not clean</p> <code>waitTimeoutForHealthyOSDInMinutes</code>  time.Duration  (Optional) <p>WaitTimeoutForHealthyOSDInMinutes defines the time the operator would wait before an OSD can be stopped for upgrade or restart. If the timeout exceeds and OSD is not ok to stop, then the operator would skip upgrade for the current OSD and proceed with the next one if <code>continueUpgradeAfterChecksEvenIfNotHealthy</code> is <code>false</code>. If <code>continueUpgradeAfterChecksEvenIfNotHealthy</code> is <code>true</code>, then operator would continue with the upgrade of an OSD even if its not ok to stop after the timeout. This timeout won\u2019t be applied if <code>skipUpgradeChecks</code> is <code>true</code>. The default wait timeout is 10 minutes.</p> <code>upgradeOSDRequiresHealthyPGs</code>  bool  (Optional) <p>UpgradeOSDRequiresHealthyPGs defines if OSD upgrade requires PGs are clean. If set to <code>true</code> OSD upgrade process won\u2019t start until PGs are healthy. This configuration will be ignored if <code>skipUpgradeChecks</code> is <code>true</code>. Default is false.</p> <code>disruptionManagement</code>  DisruptionManagementSpec  (Optional) <p>A spec for configuring disruption management.</p> <code>mon</code>  MonSpec  (Optional) <p>A spec for mon related options</p> <code>crashCollector</code>  CrashCollectorSpec  (Optional) <p>A spec for the crash controller</p> <code>dashboard</code>  DashboardSpec  (Optional) <p>Dashboard settings</p> <code>monitoring</code>  MonitoringSpec  (Optional) <p>Prometheus based Monitoring settings</p> <code>external</code>  ExternalSpec  (Optional) <p>Whether the Ceph Cluster is running external to this Kubernetes cluster mon, mgr, osd, mds, and discover daemons will not be created for external clusters.</p> <code>mgr</code>  MgrSpec  (Optional) <p>A spec for mgr related options</p> <code>removeOSDsIfOutAndSafeToRemove</code>  bool  (Optional) <p>Remove the OSD that is out and safe to remove only if this option is true</p> <code>cleanupPolicy</code>  CleanupPolicySpec  (Optional) <p>Indicates user intent when deleting a cluster; blocks orchestration and should not be set if cluster deletion is not imminent.</p> <code>healthCheck</code>  CephClusterHealthCheckSpec  (Optional) <p>Internal daemon healthchecks and liveness probe</p> <code>security</code>  SecuritySpec  (Optional) <p>Security represents security settings</p> <code>logCollector</code>  LogCollectorSpec  (Optional) <p>Logging represents loggings settings</p> <code>csi</code>  CSIDriverSpec  (Optional) <p>CSI Driver Options applied per cluster.</p> <code>cephConfig</code>  map[string]map[string]string  (Optional) <p>Ceph Config options</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ClusterState","title":"ClusterState (<code>string</code> alias)","text":"<p> (Appears on:ClusterStatus) </p> <p>ClusterState represents the state of a Ceph Cluster</p> Value Description <p>\"Connected\"</p> <p>ClusterStateConnected represents the Connected state of a Ceph Cluster</p> <p>\"Connecting\"</p> <p>ClusterStateConnecting represents the Connecting state of a Ceph Cluster</p> <p>\"Created\"</p> <p>ClusterStateCreated represents the Created state of a Ceph Cluster</p> <p>\"Creating\"</p> <p>ClusterStateCreating represents the Creating state of a Ceph Cluster</p> <p>\"Error\"</p> <p>ClusterStateError represents the Error state of a Ceph Cluster</p> <p>\"Updating\"</p> <p>ClusterStateUpdating represents the Updating state of a Ceph Cluster</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ClusterStatus","title":"ClusterStatus","text":"<p> (Appears on:CephCluster) </p> <p>ClusterStatus represents the status of a Ceph cluster</p> Field Description <code>state</code>  ClusterState  <code>phase</code>  ConditionType  <code>message</code>  string  <code>conditions</code>  []Condition  <code>ceph</code>  CephStatus  <code>storage</code>  CephStorage  <code>version</code>  ClusterVersion  <code>observedGeneration</code>  int64  (Optional) <p>ObservedGeneration is the latest generation observed by the controller.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ClusterVersion","title":"ClusterVersion","text":"<p> (Appears on:ClusterStatus) </p> <p>ClusterVersion represents the version of a Ceph Cluster</p> Field Description <code>image</code>  string  <code>version</code>  string"},{"location":"CRDs/specification/#ceph.rook.io/v1.CompressionSpec","title":"CompressionSpec","text":"<p> (Appears on:ConnectionsSpec) </p> Field Description <code>enabled</code>  bool  (Optional) <p>Whether to compress the data in transit across the wire. The default is not set.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.Condition","title":"Condition","text":"<p> (Appears on:CephBlockPoolStatus, CephFilesystemStatus, ClusterStatus, ObjectStoreStatus, Status) </p> <p>Condition represents a status condition on any Rook-Ceph Custom Resource.</p> Field Description <code>type</code>  ConditionType  <code>status</code>  Kubernetes core/v1.ConditionStatus  <code>reason</code>  ConditionReason  <code>message</code>  string  <code>lastHeartbeatTime</code>  Kubernetes meta/v1.Time  <code>lastTransitionTime</code>  Kubernetes meta/v1.Time"},{"location":"CRDs/specification/#ceph.rook.io/v1.ConditionReason","title":"ConditionReason (<code>string</code> alias)","text":"<p> (Appears on:Condition) </p> <p>ConditionReason is a reason for a condition</p> Value Description <p>\"ClusterConnected\"</p> <p>ClusterConnectedReason is cluster connected reason</p> <p>\"ClusterConnecting\"</p> <p>ClusterConnectingReason is cluster connecting reason</p> <p>\"ClusterCreated\"</p> <p>ClusterCreatedReason is cluster created reason</p> <p>\"ClusterDeleting\"</p> <p>ClusterDeletingReason is cluster deleting reason</p> <p>\"ClusterProgressing\"</p> <p>ClusterProgressingReason is cluster progressing reason</p> <p>\"Deleting\"</p> <p>DeletingReason represents when Rook has detected a resource object should be deleted.</p> <p>\"ObjectHasDependents\"</p> <p>ObjectHasDependentsReason represents when a resource object has dependents that are blocking deletion.</p> <p>\"ObjectHasNoDependents\"</p> <p>ObjectHasNoDependentsReason represents when a resource object has no dependents that are blocking deletion.</p> <p>\"ReconcileFailed\"</p> <p>ReconcileFailed represents when a resource reconciliation failed.</p> <p>\"ReconcileStarted\"</p> <p>ReconcileStarted represents when a resource reconciliation started.</p> <p>\"ReconcileSucceeded\"</p> <p>ReconcileSucceeded represents when a resource reconciliation was successful.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ConditionType","title":"ConditionType (<code>string</code> alias)","text":"<p> (Appears on:CephBlockPoolRadosNamespaceStatus, CephBlockPoolStatus, CephClientStatus, CephFilesystemStatus, CephFilesystemSubVolumeGroupStatus, ClusterStatus, Condition, ObjectStoreStatus) </p> <p>ConditionType represent a resource\u2019s status</p> Value Description <p>\"Connected\"</p> <p>ConditionConnected represents Connected state of an object</p> <p>\"Connecting\"</p> <p>ConditionConnecting represents Connecting state of an object</p> <p>\"Deleting\"</p> <p>ConditionDeleting represents Deleting state of an object</p> <p>\"DeletionIsBlocked\"</p> <p>ConditionDeletionIsBlocked represents when deletion of the object is blocked.</p> <p>\"Failure\"</p> <p>ConditionFailure represents Failure state of an object</p> <p>\"Progressing\"</p> <p>ConditionProgressing represents Progressing state of an object</p> <p>\"Ready\"</p> <p>ConditionReady represents Ready state of an object</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ConfigFileVolumeSource","title":"ConfigFileVolumeSource","text":"<p> (Appears on:AdditionalVolumeMount, KerberosConfigFiles, KerberosKeytabFile, SSSDSidecarConfigFile) </p> <p>Represents the source of a volume to mount. Only one of its members may be specified. This is a subset of the full Kubernetes API\u2019s VolumeSource that is reduced to what is most likely to be useful for mounting config files/dirs into Rook pods.</p> Field Description <code>hostPath</code>  Kubernetes core/v1.HostPathVolumeSource  (Optional) <p>hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath</p> <code>emptyDir</code>  Kubernetes core/v1.EmptyDirVolumeSource  (Optional) <p>emptyDir represents a temporary directory that shares a pod\u2019s lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir</p> <code>secret</code>  Kubernetes core/v1.SecretVolumeSource  (Optional) <p>secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret</p> <code>persistentVolumeClaim</code>  Kubernetes core/v1.PersistentVolumeClaimVolumeSource  (Optional) <p>persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims</p> <code>configMap</code>  Kubernetes core/v1.ConfigMapVolumeSource  (Optional) <p>configMap represents a configMap that should populate this volume</p> <code>projected</code>  Kubernetes core/v1.ProjectedVolumeSource  <p>projected items for all in one resources secrets, configmaps, and downward API</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ConnectionsSpec","title":"ConnectionsSpec","text":"<p> (Appears on:NetworkSpec) </p> Field Description <code>encryption</code>  EncryptionSpec  (Optional) <p>Encryption settings for the network connections.</p> <code>compression</code>  CompressionSpec  (Optional) <p>Compression settings for the network connections.</p> <code>requireMsgr2</code>  bool  (Optional) <p>Whether to require msgr2 (port 3300) even if compression or encryption are not enabled. If true, the msgr1 port (6789) will be disabled. Requires a kernel that supports msgr2 (kernel 5.11 or CentOS 8.4 or newer).</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.CrashCollectorSpec","title":"CrashCollectorSpec","text":"<p> (Appears on:ClusterSpec) </p> <p>CrashCollectorSpec represents options to configure the crash controller</p> Field Description <code>disable</code>  bool  (Optional) <p>Disable determines whether we should enable the crash collector</p> <code>daysToRetain</code>  uint  (Optional) <p>DaysToRetain represents the number of days to retain crash until they get pruned</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.DaemonHealthSpec","title":"DaemonHealthSpec","text":"<p> (Appears on:CephClusterHealthCheckSpec) </p> <p>DaemonHealthSpec is a daemon health check</p> Field Description <code>status</code>  HealthCheckSpec  (Optional) <p>Status represents the health check settings for the Ceph health</p> <code>mon</code>  HealthCheckSpec  (Optional) <p>Monitor represents the health check settings for the Ceph monitor</p> <code>osd</code>  HealthCheckSpec  (Optional) <p>ObjectStorageDaemon represents the health check settings for the Ceph OSDs</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.DashboardSpec","title":"DashboardSpec","text":"<p> (Appears on:ClusterSpec) </p> <p>DashboardSpec represents the settings for the Ceph dashboard</p> Field Description <code>enabled</code>  bool  (Optional) <p>Enabled determines whether to enable the dashboard</p> <code>urlPrefix</code>  string  (Optional) <p>URLPrefix is a prefix for all URLs to use the dashboard with a reverse proxy</p> <code>port</code>  int  (Optional) <p>Port is the dashboard webserver port</p> <code>ssl</code>  bool  (Optional) <p>SSL determines whether SSL should be used</p> <code>prometheusEndpoint</code>  string  (Optional) <p>Endpoint for the Prometheus host</p> <code>prometheusEndpointSSLVerify</code>  bool  (Optional) <p>Whether to verify the ssl endpoint for prometheus. Set to false for a self-signed cert.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.Device","title":"Device","text":"<p> (Appears on:Selection) </p> <p>Device represents a disk to use in the cluster</p> Field Description <code>name</code>  string  (Optional) <code>fullpath</code>  string  (Optional) <code>config</code>  map[string]string  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.DeviceClasses","title":"DeviceClasses","text":"<p> (Appears on:CephStorage) </p> <p>DeviceClasses represents device classes of a Ceph Cluster</p> Field Description <code>name</code>  string"},{"location":"CRDs/specification/#ceph.rook.io/v1.DisruptionManagementSpec","title":"DisruptionManagementSpec","text":"<p> (Appears on:ClusterSpec) </p> <p>DisruptionManagementSpec configures management of daemon disruptions</p> Field Description <code>managePodBudgets</code>  bool  (Optional) <p>This enables management of poddisruptionbudgets</p> <code>osdMaintenanceTimeout</code>  time.Duration  (Optional) <p>OSDMaintenanceTimeout sets how many additional minutes the DOWN/OUT interval is for drained failure domains it only works if managePodBudgets is true. the default is 30 minutes</p> <code>pgHealthCheckTimeout</code>  time.Duration  (Optional) <p>PGHealthCheckTimeout is the time (in minutes) that the operator will wait for the placement groups to become healthy (active+clean) after a drain was completed and OSDs came back up. Rook will continue with the next drain if the timeout exceeds. It only works if managePodBudgets is true. No values or 0 means that the operator will wait until the placement groups are healthy before unblocking the next drain.</p> <code>pgHealthyRegex</code>  string  (Optional) <p>PgHealthyRegex is the regular expression that is used to determine which PG states should be considered healthy. The default is <code>^(active\\+clean|active\\+clean\\+scrubbing|active\\+clean\\+scrubbing\\+deep)$</code></p> <code>manageMachineDisruptionBudgets</code>  bool  (Optional) <p>Deprecated. This enables management of machinedisruptionbudgets.</p> <code>machineDisruptionBudgetNamespace</code>  string  (Optional) <p>Deprecated. Namespace to look for MDBs by the machineDisruptionBudgetController</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.EncryptionSpec","title":"EncryptionSpec","text":"<p> (Appears on:ConnectionsSpec) </p> Field Description <code>enabled</code>  bool  (Optional) <p>Whether to encrypt the data in transit across the wire to prevent eavesdropping the data on the network. The default is not set. Even if encryption is not enabled, clients still establish a strong initial authentication for the connection and data integrity is still validated with a crc check. When encryption is enabled, all communication between clients and Ceph daemons, or between Ceph daemons will be encrypted.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.EndpointAddress","title":"EndpointAddress","text":"<p> (Appears on:GatewaySpec) </p> <p>EndpointAddress is a tuple that describes a single IP address or host name. This is a subset of Kubernetes\u2019s v1.EndpointAddress.</p> Field Description <code>ip</code>  string  (Optional) <p>The IP of this endpoint. As a legacy behavior, this supports being given a DNS-addressable hostname as well.</p> <code>hostname</code>  string  (Optional) <p>The DNS-addressable Hostname of this endpoint. This field will be preferred over IP if both are given.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ErasureCodedSpec","title":"ErasureCodedSpec","text":"<p> (Appears on:PoolSpec) </p> <p>ErasureCodedSpec represents the spec for erasure code in a pool</p> Field Description <code>codingChunks</code>  uint  <p>Number of coding chunks per object in an erasure coded storage pool (required for erasure-coded pool type). This is the number of OSDs that can be lost simultaneously before data cannot be recovered.</p> <code>dataChunks</code>  uint  <p>Number of data chunks per object in an erasure coded storage pool (required for erasure-coded pool type). The number of chunks required to recover an object when any single OSD is lost is the same as dataChunks so be aware that the larger the number of data chunks, the higher the cost of recovery.</p> <code>algorithm</code>  string  (Optional) <p>The algorithm for erasure coding</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ExternalSpec","title":"ExternalSpec","text":"<p> (Appears on:ClusterSpec) </p> <p>ExternalSpec represents the options supported by an external cluster</p> Field Description <code>enable</code>  bool  (Optional) <p>Enable determines whether external mode is enabled or not</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.FSMirroringSpec","title":"FSMirroringSpec","text":"<p> (Appears on:FilesystemSpec) </p> <p>FSMirroringSpec represents the setting for a mirrored filesystem</p> Field Description <code>enabled</code>  bool  (Optional) <p>Enabled whether this filesystem is mirrored or not</p> <code>peers</code>  MirroringPeerSpec  (Optional) <p>Peers represents the peers spec</p> <code>snapshotSchedules</code>  []SnapshotScheduleSpec  (Optional) <p>SnapshotSchedules is the scheduling of snapshot for mirrored filesystems</p> <code>snapshotRetention</code>  []SnapshotScheduleRetentionSpec  (Optional) <p>Retention is the retention policy for a snapshot schedule One path has exactly one retention policy. A policy can however contain multiple count-time period pairs in order to specify complex retention policies</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.FilesystemMirrorInfoPeerSpec","title":"FilesystemMirrorInfoPeerSpec","text":"<p> (Appears on:FilesystemsSpec) </p> <p>FilesystemMirrorInfoPeerSpec is the specification of a filesystem peer mirror</p> Field Description <code>uuid</code>  string  (Optional) <p>UUID is the peer unique identifier</p> <code>remote</code>  PeerRemoteSpec  (Optional) <p>Remote are the remote cluster information</p> <code>stats</code>  PeerStatSpec  (Optional) <p>Stats are the stat a peer mirror</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.FilesystemMirroringInfo","title":"FilesystemMirroringInfo","text":"<p> (Appears on:FilesystemMirroringInfoSpec) </p> <p>FilesystemMirrorInfoSpec is the filesystem mirror status of a given filesystem</p> Field Description <code>daemon_id</code>  int  (Optional) <p>DaemonID is the cephfs-mirror name</p> <code>filesystems</code>  []FilesystemsSpec  (Optional) <p>Filesystems is the list of filesystems managed by a given cephfs-mirror daemon</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.FilesystemMirroringInfoSpec","title":"FilesystemMirroringInfoSpec","text":"<p> (Appears on:CephFilesystemStatus) </p> <p>FilesystemMirroringInfo is the status of the pool mirroring</p> Field Description <code>daemonsStatus</code>  []FilesystemMirroringInfo  (Optional) <p>PoolMirroringStatus is the mirroring status of a filesystem</p> <code>lastChecked</code>  string  (Optional) <p>LastChecked is the last time time the status was checked</p> <code>lastChanged</code>  string  (Optional) <p>LastChanged is the last time time the status last changed</p> <code>details</code>  string  (Optional) <p>Details contains potential status errors</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.FilesystemMirroringSpec","title":"FilesystemMirroringSpec","text":"<p> (Appears on:CephFilesystemMirror) </p> <p>FilesystemMirroringSpec is the filesystem mirroring specification</p> Field Description <code>placement</code>  Placement  (Optional) <p>The affinity to place the rgw pods (default is to place on any available node)</p> <code>annotations</code>  Annotations  (Optional) <p>The annotations-related configuration to add/set on each Pod related object.</p> <code>labels</code>  Labels  (Optional) <p>The labels-related configuration to add/set on each Pod related object.</p> <code>resources</code>  Kubernetes core/v1.ResourceRequirements  (Optional) <p>The resource requirements for the cephfs-mirror pods</p> <code>priorityClassName</code>  string  (Optional) <p>PriorityClassName sets priority class on the cephfs-mirror pods</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.FilesystemSnapshotScheduleStatusRetention","title":"FilesystemSnapshotScheduleStatusRetention","text":"<p> (Appears on:FilesystemSnapshotSchedulesSpec) </p> <p>FilesystemSnapshotScheduleStatusRetention is the retention specification for a filesystem snapshot schedule</p> Field Description <code>start</code>  string  (Optional) <p>Start is when the snapshot schedule starts</p> <code>created</code>  string  (Optional) <p>Created is when the snapshot schedule was created</p> <code>first</code>  string  (Optional) <p>First is when the first snapshot schedule was taken</p> <code>last</code>  string  (Optional) <p>Last is when the last snapshot schedule was taken</p> <code>last_pruned</code>  string  (Optional) <p>LastPruned is when the last snapshot schedule was pruned</p> <code>created_count</code>  int  (Optional) <p>CreatedCount is total amount of snapshots</p> <code>pruned_count</code>  int  (Optional) <p>PrunedCount is total amount of pruned snapshots</p> <code>active</code>  bool  (Optional) <p>Active is whether the scheduled is active or not</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.FilesystemSnapshotScheduleStatusSpec","title":"FilesystemSnapshotScheduleStatusSpec","text":"<p> (Appears on:CephFilesystemStatus) </p> <p>FilesystemSnapshotScheduleStatusSpec is the status of the snapshot schedule</p> Field Description <code>snapshotSchedules</code>  []FilesystemSnapshotSchedulesSpec  (Optional) <p>SnapshotSchedules is the list of snapshots scheduled</p> <code>lastChecked</code>  string  (Optional) <p>LastChecked is the last time time the status was checked</p> <code>lastChanged</code>  string  (Optional) <p>LastChanged is the last time time the status last changed</p> <code>details</code>  string  (Optional) <p>Details contains potential status errors</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.FilesystemSnapshotSchedulesSpec","title":"FilesystemSnapshotSchedulesSpec","text":"<p> (Appears on:FilesystemSnapshotScheduleStatusSpec) </p> <p>FilesystemSnapshotSchedulesSpec is the list of snapshot scheduled for images in a pool</p> Field Description <code>fs</code>  string  (Optional) <p>Fs is the name of the Ceph Filesystem</p> <code>subvol</code>  string  (Optional) <p>Subvol is the name of the sub volume</p> <code>path</code>  string  (Optional) <p>Path is the path on the filesystem</p> <code>rel_path</code>  string  (Optional) <code>schedule</code>  string  (Optional) <code>retention</code>  FilesystemSnapshotScheduleStatusRetention  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.FilesystemSpec","title":"FilesystemSpec","text":"<p> (Appears on:CephFilesystem) </p> <p>FilesystemSpec represents the spec of a file system</p> Field Description <code>metadataPool</code>  NamedPoolSpec  <p>The metadata pool settings</p> <code>dataPools</code>  []NamedPoolSpec  <p>The data pool settings, with optional predefined pool name.</p> <code>preservePoolNames</code>  bool  (Optional) <p>Preserve pool names as specified</p> <code>preservePoolsOnDelete</code>  bool  (Optional) <p>Preserve pools on filesystem deletion</p> <code>preserveFilesystemOnDelete</code>  bool  (Optional) <p>Preserve the fs in the cluster on CephFilesystem CR deletion. Setting this to true automatically implies PreservePoolsOnDelete is true.</p> <code>metadataServer</code>  MetadataServerSpec  <p>The mds pod info</p> <code>mirroring</code>  FSMirroringSpec  (Optional) <p>The mirroring settings</p> <code>statusCheck</code>  MirrorHealthCheckSpec  <p>The mirroring statusCheck</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.FilesystemsSpec","title":"FilesystemsSpec","text":"<p> (Appears on:FilesystemMirroringInfo) </p> <p>FilesystemsSpec is spec for the mirrored filesystem</p> Field Description <code>filesystem_id</code>  int  (Optional) <p>FilesystemID is the filesystem identifier</p> <code>name</code>  string  (Optional) <p>Name is name of the filesystem</p> <code>directory_count</code>  int  (Optional) <p>DirectoryCount is the number of directories in the filesystem</p> <code>peers</code>  []FilesystemMirrorInfoPeerSpec  (Optional) <p>Peers represents the mirroring peers</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.GaneshaRADOSSpec","title":"GaneshaRADOSSpec","text":"<p> (Appears on:NFSGaneshaSpec) </p> <p>GaneshaRADOSSpec represents the specification of a Ganesha RADOS object</p> Field Description <code>pool</code>  string  (Optional) <p>The Ceph pool used store the shared configuration for NFS-Ganesha daemons. This setting is deprecated, as it is internally required to be \u201c.nfs\u201d.</p> <code>namespace</code>  string  (Optional) <p>The namespace inside the Ceph pool (set by \u2018pool\u2019) where shared NFS-Ganesha config is stored. This setting is deprecated as it is internally set to the name of the CephNFS.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.GaneshaServerSpec","title":"GaneshaServerSpec","text":"<p> (Appears on:NFSGaneshaSpec) </p> <p>GaneshaServerSpec represents the specification of a Ganesha Server</p> Field Description <code>active</code>  int  <p>The number of active Ganesha servers</p> <code>placement</code>  Placement  (Optional) <p>The affinity to place the ganesha pods</p> <code>annotations</code>  Annotations  (Optional) <p>The annotations-related configuration to add/set on each Pod related object.</p> <code>labels</code>  Labels  (Optional) <p>The labels-related configuration to add/set on each Pod related object.</p> <code>resources</code>  Kubernetes core/v1.ResourceRequirements  (Optional) <p>Resources set resource requests and limits</p> <code>priorityClassName</code>  string  (Optional) <p>PriorityClassName sets the priority class on the pods</p> <code>logLevel</code>  string  (Optional) <p>LogLevel set logging level</p> <code>hostNetwork</code>  bool  (Optional) <p>Whether host networking is enabled for the Ganesha server. If not set, the network settings from the cluster CR will be applied.</p> <code>livenessProbe</code>  ProbeSpec  (Optional) <p>A liveness-probe to verify that Ganesha server has valid run-time state. If LivenessProbe.Disabled is false and LivenessProbe.Probe is nil uses default probe.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.GatewaySpec","title":"GatewaySpec","text":"<p> (Appears on:ObjectStoreSpec) </p> <p>GatewaySpec represents the specification of Ceph Object Store Gateway</p> Field Description <code>port</code>  int32  (Optional) <p>The port the rgw service will be listening on (http)</p> <code>securePort</code>  int32  (Optional) <p>The port the rgw service will be listening on (https)</p> <code>instances</code>  int32  (Optional) <p>The number of pods in the rgw replicaset.</p> <code>sslCertificateRef</code>  string  (Optional) <p>The name of the secret that stores the ssl certificate for secure rgw connections</p> <code>caBundleRef</code>  string  (Optional) <p>The name of the secret that stores custom ca-bundle with root and intermediate certificates.</p> <code>placement</code>  Placement  (Optional) <p>The affinity to place the rgw pods (default is to place on any available node)</p> <code>disableMultisiteSyncTraffic</code>  bool  (Optional) <p>DisableMultisiteSyncTraffic, when true, prevents this object store\u2019s gateways from transmitting multisite replication data. Note that this value does not affect whether gateways receive multisite replication traffic: see ObjectZone.spec.customEndpoints for that. If false or unset, this object store\u2019s gateways will be able to transmit multisite replication data.</p> <code>annotations</code>  Annotations  (Optional) <p>The annotations-related configuration to add/set on each Pod related object.</p> <code>labels</code>  Labels  (Optional) <p>The labels-related configuration to add/set on each Pod related object.</p> <code>resources</code>  Kubernetes core/v1.ResourceRequirements  (Optional) <p>The resource requirements for the rgw pods</p> <code>priorityClassName</code>  string  (Optional) <p>PriorityClassName sets priority classes on the rgw pods</p> <code>externalRgwEndpoints</code>  []EndpointAddress  (Optional) <p>ExternalRgwEndpoints points to external RGW endpoint(s). Multiple endpoints can be given, but for stability of ObjectBucketClaims, we highly recommend that users give only a single external RGW endpoint that is a load balancer that sends requests to the multiple RGWs.</p> <code>service</code>  RGWServiceSpec  (Optional) <p>The configuration related to add/set on each rgw service.</p> <code>hostNetwork</code>  bool  (Optional) <p>Whether host networking is enabled for the rgw daemon. If not set, the network settings from the cluster CR will be applied.</p> <code>dashboardEnabled</code>  bool  (Optional) <p>Whether rgw dashboard is enabled for the rgw daemon. If not set, the rgw dashboard will be enabled.</p> <code>additionalVolumeMounts</code>  AdditionalVolumeMounts  <p>AdditionalVolumeMounts allows additional volumes to be mounted to the RGW pod. The root directory for each additional volume mount is <code>/var/rgw</code>. Example: for an additional mount at subPath <code>ldap</code>, mounted from a secret that has key <code>bindpass.secret</code>, the file would reside at <code>/var/rgw/ldap/bindpass.secret</code>.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.HTTPEndpointSpec","title":"HTTPEndpointSpec","text":"<p> (Appears on:TopicEndpointSpec) </p> <p>HTTPEndpointSpec represent the spec of an HTTP endpoint of a Bucket Topic</p> Field Description <code>uri</code>  string  <p>The URI of the HTTP endpoint to push notification to</p> <code>disableVerifySSL</code>  bool  (Optional) <p>Indicate whether the server certificate is validated by the client or not</p> <code>sendCloudEvents</code>  bool  (Optional) <p>Send the notifications with the CloudEvents header: https://github.com/cloudevents/spec/blob/main/cloudevents/adapters/aws-s3.md</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.HealthCheckSpec","title":"HealthCheckSpec","text":"<p> (Appears on:DaemonHealthSpec, MirrorHealthCheckSpec) </p> <p>HealthCheckSpec represents the health check of an object store bucket</p> Field Description <code>disabled</code>  bool  (Optional) <code>interval</code>  Kubernetes meta/v1.Duration  (Optional) <p>Interval is the internal in second or minute for the health check to run like 60s for 60 seconds</p> <code>timeout</code>  string  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.HybridStorageSpec","title":"HybridStorageSpec","text":"<p> (Appears on:ReplicatedSpec) </p> <p>HybridStorageSpec represents the settings for hybrid storage pool</p> Field Description <code>primaryDeviceClass</code>  string  <p>PrimaryDeviceClass represents high performance tier (for example SSD or NVME) for Primary OSD</p> <code>secondaryDeviceClass</code>  string  <p>SecondaryDeviceClass represents low performance tier (for example HDDs) for remaining OSDs</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.IPFamilyType","title":"IPFamilyType (<code>string</code> alias)","text":"<p> (Appears on:NetworkSpec) </p> <p>IPFamilyType represents the single stack Ipv4 or Ipv6 protocol.</p> Value Description <p>\"IPv4\"</p> <p>IPv4 internet protocol version</p> <p>\"IPv6\"</p> <p>IPv6 internet protocol version</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ImplicitTenantSetting","title":"ImplicitTenantSetting (<code>string</code> alias)","text":"<p> (Appears on:KeystoneSpec) </p> Value Description <p>\"\"</p> <p>\"false\"</p> <p>\"s3\"</p> <p>\"swift\"</p> <p>\"true\"</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.KafkaEndpointSpec","title":"KafkaEndpointSpec","text":"<p> (Appears on:TopicEndpointSpec) </p> <p>KafkaEndpointSpec represent the spec of a Kafka endpoint of a Bucket Topic</p> Field Description <code>uri</code>  string  <p>The URI of the Kafka endpoint to push notification to</p> <code>useSSL</code>  bool  (Optional) <p>Indicate whether to use SSL when communicating with the broker</p> <code>disableVerifySSL</code>  bool  (Optional) <p>Indicate whether the server certificate is validated by the client or not</p> <code>ackLevel</code>  string  (Optional) <p>The ack level required for this topic (none/broker)</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.KerberosConfigFiles","title":"KerberosConfigFiles","text":"<p> (Appears on:KerberosSpec) </p> <p>KerberosConfigFiles represents the source(s) from which Kerberos configuration should come.</p> Field Description <code>volumeSource</code>  ConfigFileVolumeSource  <p>VolumeSource accepts a pared down version of the standard Kubernetes VolumeSource for Kerberos configuration files like what is normally used to configure Volumes for a Pod. For example, a ConfigMap, Secret, or HostPath. The volume may contain multiple files, all of which will be loaded.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.KerberosKeytabFile","title":"KerberosKeytabFile","text":"<p> (Appears on:KerberosSpec) </p> <p>KerberosKeytabFile represents the source(s) from which the Kerberos keytab file should come.</p> Field Description <code>volumeSource</code>  ConfigFileVolumeSource  <p>VolumeSource accepts a pared down version of the standard Kubernetes VolumeSource for the Kerberos keytab file like what is normally used to configure Volumes for a Pod. For example, a Secret or HostPath. There are two requirements for the source\u2019s content: 1. The config file must be mountable via <code>subPath: krb5.keytab</code>. For example, in a Secret, the data item must be named <code>krb5.keytab</code>, or <code>items</code> must be defined to select the key and give it path <code>krb5.keytab</code>. A HostPath directory must have the <code>krb5.keytab</code> file. 2. The volume or config file must have mode 0600.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.KerberosSpec","title":"KerberosSpec","text":"<p> (Appears on:NFSSecuritySpec) </p> <p>KerberosSpec represents configuration for Kerberos.</p> Field Description <code>principalName</code>  string  (Optional) <p>PrincipalName corresponds directly to NFS-Ganesha\u2019s NFS_KRB5:PrincipalName config. In practice, this is the service prefix of the principal name. The default is \u201cnfs\u201d. This value is combined with (a) the namespace and name of the CephNFS (with a hyphen between) and (b) the Realm configured in the user-provided krb5.conf to determine the full principal name: /-@. e.g., nfs/rook-ceph-my-nfs@example.net. See https://github.com/nfs-ganesha/nfs-ganesha/wiki/RPCSEC_GSS for more detail. <code>domainName</code>  string  (Optional) <p>DomainName should be set to the Kerberos Realm.</p> <code>configFiles</code>  KerberosConfigFiles  (Optional) <p>ConfigFiles defines where the Kerberos configuration should be sourced from. Config files will be placed into the <code>/etc/krb5.conf.rook/</code> directory.</p> <p>If this is left empty, Rook will not add any files. This allows you to manage the files yourself however you wish. For example, you may build them into your custom Ceph container image or use the Vault agent injector to securely add the files via annotations on the CephNFS spec (passed to the NFS server pods).</p> <p>Rook configures Kerberos to log to stderr. We suggest removing logging sections from config files to avoid consuming unnecessary disk space from logging to files.</p> <code>keytabFile</code>  KerberosKeytabFile  (Optional) <p>KeytabFile defines where the Kerberos keytab should be sourced from. The keytab file will be placed into <code>/etc/krb5.keytab</code>. If this is left empty, Rook will not add the file. This allows you to manage the <code>krb5.keytab</code> file yourself however you wish. For example, you may build it into your custom Ceph container image or use the Vault agent injector to securely add the file via annotations on the CephNFS spec (passed to the NFS server pods).</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.KeyManagementServiceSpec","title":"KeyManagementServiceSpec","text":"<p> (Appears on:ObjectStoreSecuritySpec, SecuritySpec) </p> <p>KeyManagementServiceSpec represent various details of the KMS server</p> Field Description <code>connectionDetails</code>  map[string]string  (Optional) <p>ConnectionDetails contains the KMS connection details (address, port etc)</p> <code>tokenSecretName</code>  string  (Optional) <p>TokenSecretName is the kubernetes secret containing the KMS token</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.KeyRotationSpec","title":"KeyRotationSpec","text":"<p> (Appears on:SecuritySpec) </p> <p>KeyRotationSpec represents the settings for Key Rotation.</p> Field Description <code>enabled</code>  bool  (Optional) <p>Enabled represents whether the key rotation is enabled.</p> <code>schedule</code>  string  (Optional) <p>Schedule represents the cron schedule for key rotation.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.KeyType","title":"KeyType (<code>string</code> alias)","text":"<p>KeyType type safety</p> Value Description <p>\"exporter\"</p> <p>\"cleanup\"</p> <p>\"clusterMetadata\"</p> <p>\"cmdreporter\"</p> <p>\"crashcollector\"</p> <p>\"dashboard\"</p> <p>\"mds\"</p> <p>\"mgr\"</p> <p>\"mon\"</p> <p>\"arbiter\"</p> <p>\"monitoring\"</p> <p>\"osd\"</p> <p>\"prepareosd\"</p> <p>\"rgw\"</p> <p>\"keyrotation\"</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.KeystoneSpec","title":"KeystoneSpec","text":"<p> (Appears on:AuthSpec) </p> <p>KeystoneSpec represents the Keystone authentication configuration of a Ceph Object Store Gateway</p> Field Description <code>url</code>  string  <p>The URL for the Keystone server.</p> <code>serviceUserSecretName</code>  string  <p>The name of the secret containing the credentials for the service user account used by RGW. It has to be in the same namespace as the object store resource.</p> <code>acceptedRoles</code>  []string  <p>The roles requires to serve requests.</p> <code>implicitTenants</code>  ImplicitTenantSetting  (Optional) <p>Create new users in their own tenants of the same name. Possible values are true, false, swift and s3. The latter have the effect of splitting the identity space such that only the indicated protocol will use implicit tenants.</p> <code>tokenCacheSize</code>  int  (Optional) <p>The maximum number of entries in each Keystone token cache.</p> <code>revocationInterval</code>  int  (Optional) <p>The number of seconds between token revocation checks.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.Labels","title":"Labels (<code>map[string]string</code> alias)","text":"<p> (Appears on:FilesystemMirroringSpec, GaneshaServerSpec, GatewaySpec, MetadataServerSpec, RBDMirroringSpec) </p> <p>Labels are label for a given daemons</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.LabelsSpec","title":"LabelsSpec (<code>map[github.com/rook/rook/pkg/apis/ceph.rook.io/v1.KeyType]github.com/rook/rook/pkg/apis/ceph.rook.io/v1.Labels</code> alias)","text":"<p> (Appears on:ClusterSpec) </p> <p>LabelsSpec is the main spec label for all daemons</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.LogCollectorSpec","title":"LogCollectorSpec","text":"<p> (Appears on:ClusterSpec) </p> <p>LogCollectorSpec is the logging spec</p> Field Description <code>enabled</code>  bool  (Optional) <p>Enabled represents whether the log collector is enabled</p> <code>periodicity</code>  string  (Optional) <p>Periodicity is the periodicity of the log rotation.</p> <code>maxLogSize</code>  k8s.io/apimachinery/pkg/api/resource.Quantity  (Optional) <p>MaxLogSize is the maximum size of the log per ceph daemons. Must be at least 1M.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.MetadataServerSpec","title":"MetadataServerSpec","text":"<p> (Appears on:FilesystemSpec) </p> <p>MetadataServerSpec represents the specification of a Ceph Metadata Server</p> Field Description <code>activeCount</code>  int32  <p>The number of metadata servers that are active. The remaining servers in the cluster will be in standby mode.</p> <code>activeStandby</code>  bool  (Optional) <p>Whether each active MDS instance will have an active standby with a warm metadata cache for faster failover. If false, standbys will still be available, but will not have a warm metadata cache.</p> <code>placement</code>  Placement  (Optional) <p>The affinity to place the mds pods (default is to place on all available node) with a daemonset</p> <code>annotations</code>  Annotations  (Optional) <p>The annotations-related configuration to add/set on each Pod related object.</p> <code>labels</code>  Labels  (Optional) <p>The labels-related configuration to add/set on each Pod related object.</p> <code>resources</code>  Kubernetes core/v1.ResourceRequirements  (Optional) <p>The resource requirements for the mds pods</p> <code>priorityClassName</code>  string  (Optional) <p>PriorityClassName sets priority classes on components</p> <code>livenessProbe</code>  ProbeSpec  (Optional) <code>startupProbe</code>  ProbeSpec  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.MgrSpec","title":"MgrSpec","text":"<p> (Appears on:ClusterSpec) </p> <p>MgrSpec represents options to configure a ceph mgr</p> Field Description <code>count</code>  int  (Optional) <p>Count is the number of manager daemons to run</p> <code>allowMultiplePerNode</code>  bool  (Optional) <p>AllowMultiplePerNode allows to run multiple managers on the same node (not recommended)</p> <code>modules</code>  []Module  (Optional) <p>Modules is the list of ceph manager modules to enable/disable</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.Migration","title":"Migration","text":"<p> (Appears on:StorageScopeSpec) </p> <p>Migration handles the OSD migration</p> Field Description <code>confirmation</code>  string  (Optional) <p>A user confirmation to migrate the OSDs. It destroys each OSD one at a time, cleans up the backing disk and prepares OSD with same ID on that disk</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.MigrationStatus","title":"MigrationStatus","text":"<p> (Appears on:OSDStatus) </p> <p>MigrationStatus status represents the current status of any OSD migration.</p> Field Description <code>pending</code>  int"},{"location":"CRDs/specification/#ceph.rook.io/v1.MirrorHealthCheckSpec","title":"MirrorHealthCheckSpec","text":"<p> (Appears on:FilesystemSpec, PoolSpec) </p> <p>MirrorHealthCheckSpec represents the health specification of a Ceph Storage Pool mirror</p> Field Description <code>mirror</code>  HealthCheckSpec  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.MirroringInfo","title":"MirroringInfo","text":"<p> (Appears on:MirroringInfoSpec) </p> <p>MirroringInfo is the mirroring info of a given pool/radosnamespace</p> Field Description <code>mode</code>  string  (Optional) <p>Mode is the mirroring mode</p> <code>site_name</code>  string  (Optional) <p>SiteName is the current site name</p> <code>peers</code>  []PeersSpec  (Optional) <p>Peers are the list of peer sites connected to that cluster</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.MirroringInfoSpec","title":"MirroringInfoSpec","text":"<p> (Appears on:CephBlockPoolRadosNamespaceStatus, CephBlockPoolStatus) </p> <p>MirroringInfoSpec is the status of the pool/radosnamespace mirroring</p> Field Description <code>MirroringInfo</code>  MirroringInfo  <p> (Members of <code>MirroringInfo</code> are embedded into this type.) </p> (Optional) <code>lastChecked</code>  string  (Optional) <code>lastChanged</code>  string  (Optional) <code>details</code>  string  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.MirroringPeerSpec","title":"MirroringPeerSpec","text":"<p> (Appears on:FSMirroringSpec, MirroringSpec, RBDMirroringSpec) </p> <p>MirroringPeerSpec represents the specification of a mirror peer</p> Field Description <code>secretNames</code>  []string  (Optional) <p>SecretNames represents the Kubernetes Secret names to add rbd-mirror or cephfs-mirror peers</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.MirroringSpec","title":"MirroringSpec","text":"<p> (Appears on:PoolSpec) </p> <p>MirroringSpec represents the setting for a mirrored pool</p> Field Description <code>enabled</code>  bool  (Optional) <p>Enabled whether this pool is mirrored or not</p> <code>mode</code>  string  (Optional) <p>Mode is the mirroring mode: either pool or image</p> <code>snapshotSchedules</code>  []SnapshotScheduleSpec  (Optional) <p>SnapshotSchedules is the scheduling of snapshot for mirrored images/pools</p> <code>peers</code>  MirroringPeerSpec  (Optional) <p>Peers represents the peers spec</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.MirroringStatus","title":"MirroringStatus","text":"<p> (Appears on:MirroringStatusSpec) </p> <p>MirroringStatus is the pool/radosNamespace mirror status</p> Field Description <code>summary</code>  MirroringStatusSummarySpec  (Optional) <p>Summary is the mirroring status summary</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.MirroringStatusSpec","title":"MirroringStatusSpec","text":"<p> (Appears on:CephBlockPoolRadosNamespaceStatus, CephBlockPoolStatus) </p> <p>MirroringStatusSpec is the status of the pool/radosNamespace mirroring</p> Field Description <code>MirroringStatus</code>  MirroringStatus  <p> (Members of <code>MirroringStatus</code> are embedded into this type.) </p> (Optional) <p>MirroringStatus is the mirroring status of a pool/radosNamespace</p> <code>lastChecked</code>  string  (Optional) <p>LastChecked is the last time time the status was checked</p> <code>lastChanged</code>  string  (Optional) <p>LastChanged is the last time time the status last changed</p> <code>details</code>  string  (Optional) <p>Details contains potential status errors</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.MirroringStatusSummarySpec","title":"MirroringStatusSummarySpec","text":"<p> (Appears on:MirroringStatus) </p> <p>MirroringStatusSummarySpec is the summary output of the command</p> Field Description <code>health</code>  string  (Optional) <p>Health is the mirroring health</p> <code>daemon_health</code>  string  (Optional) <p>DaemonHealth is the health of the mirroring daemon</p> <code>image_health</code>  string  (Optional) <p>ImageHealth is the health of the mirrored image</p> <code>states</code>  StatesSpec  (Optional) <p>States is the various state for all mirrored images</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.Module","title":"Module","text":"<p> (Appears on:MgrSpec) </p> <p>Module represents mgr modules that the user wants to enable or disable</p> Field Description <code>name</code>  string  (Optional) <p>Name is the name of the ceph manager module</p> <code>enabled</code>  bool  (Optional) <p>Enabled determines whether a module should be enabled or not</p> <code>settings</code>  ModuleSettings  <p>Settings to further configure the module</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ModuleSettings","title":"ModuleSettings","text":"<p> (Appears on:Module) </p> Field Description <code>balancerMode</code>  string  <p>BalancerMode sets the <code>balancer</code> module with different modes like <code>upmap</code>, <code>crush-compact</code> etc</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.MonSpec","title":"MonSpec","text":"<p> (Appears on:ClusterSpec) </p> <p>MonSpec represents the specification of the monitor</p> Field Description <code>count</code>  int  (Optional) <p>Count is the number of Ceph monitors</p> <code>allowMultiplePerNode</code>  bool  (Optional) <p>AllowMultiplePerNode determines if we can run multiple monitors on the same node (not recommended)</p> <code>failureDomainLabel</code>  string  (Optional) <code>zones</code>  []MonZoneSpec  (Optional) <p>Zones are specified when we want to provide zonal awareness to mons</p> <code>stretchCluster</code>  StretchClusterSpec  (Optional) <p>StretchCluster is the stretch cluster specification</p> <code>volumeClaimTemplate</code>  VolumeClaimTemplate  (Optional) <p>VolumeClaimTemplate is the PVC definition</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.MonZoneSpec","title":"MonZoneSpec","text":"<p> (Appears on:MonSpec, StretchClusterSpec) </p> <p>MonZoneSpec represents the specification of a zone in a Ceph Cluster</p> Field Description <code>name</code>  string  (Optional) <p>Name is the name of the zone</p> <code>arbiter</code>  bool  (Optional) <p>Arbiter determines if the zone contains the arbiter used for stretch cluster mode</p> <code>volumeClaimTemplate</code>  VolumeClaimTemplate  (Optional) <p>VolumeClaimTemplate is the PVC template</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.MonitoringSpec","title":"MonitoringSpec","text":"<p> (Appears on:ClusterSpec) </p> <p>MonitoringSpec represents the settings for Prometheus based Ceph monitoring</p> Field Description <code>enabled</code>  bool  (Optional) <p>Enabled determines whether to create the prometheus rules for the ceph cluster. If true, the prometheus types must exist or the creation will fail. Default is false.</p> <code>metricsDisabled</code>  bool  (Optional) <p>Whether to disable the metrics reported by Ceph. If false, the prometheus mgr module and Ceph exporter are enabled. If true, the prometheus mgr module and Ceph exporter are both disabled. Default is false.</p> <code>externalMgrEndpoints</code>  []Kubernetes core/v1.EndpointAddress  (Optional) <p>ExternalMgrEndpoints points to an existing Ceph prometheus exporter endpoint</p> <code>externalMgrPrometheusPort</code>  uint16  (Optional) <p>ExternalMgrPrometheusPort Prometheus exporter port</p> <code>port</code>  int  (Optional) <p>Port is the prometheus server port</p> <code>interval</code>  Kubernetes meta/v1.Duration  (Optional) <p>Interval determines prometheus scrape interval</p> <code>exporter</code>  CephExporterSpec  (Optional) <p>Ceph exporter configuration</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.MultiClusterServiceSpec","title":"MultiClusterServiceSpec","text":"<p> (Appears on:NetworkSpec) </p> Field Description <code>enabled</code>  bool  (Optional) <p>Enable multiClusterService to export the mon and OSD services to peer cluster. Ensure that peer clusters are connected using an MCS API compatible application, like Globalnet Submariner.</p> <code>clusterID</code>  string  <p>ClusterID uniquely identifies a cluster. It is used as a prefix to nslookup exported services. For example: ...svc.clusterset.local"},{"location":"CRDs/specification/#ceph.rook.io/v1.NFSGaneshaSpec","title":"NFSGaneshaSpec","text":"<p> (Appears on:CephNFS) </p> <p>NFSGaneshaSpec represents the spec of an nfs ganesha server</p> Field Description <code>rados</code>  GaneshaRADOSSpec  (Optional) <p>RADOS is the Ganesha RADOS specification</p> <code>server</code>  GaneshaServerSpec  <p>Server is the Ganesha Server specification</p> <code>security</code>  NFSSecuritySpec  (Optional) <p>Security allows specifying security configurations for the NFS cluster</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.NFSSecuritySpec","title":"NFSSecuritySpec","text":"<p> (Appears on:NFSGaneshaSpec) </p> <p>NFSSecuritySpec represents security configurations for an NFS server pod</p> Field Description <code>sssd</code>  SSSDSpec  (Optional) <p>SSSD enables integration with System Security Services Daemon (SSSD). SSSD can be used to provide user ID mapping from a number of sources. See https://sssd.io for more information about the SSSD project.</p> <code>kerberos</code>  KerberosSpec  (Optional) <p>Kerberos configures NFS-Ganesha to secure NFS client connections with Kerberos.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.NamedBlockPoolSpec","title":"NamedBlockPoolSpec","text":"<p> (Appears on:CephBlockPool) </p> <p>NamedBlockPoolSpec allows a block pool to be created with a non-default name. This is more specific than the NamedPoolSpec so we get schema validation on the allowed pool names that can be specified.</p> Field Description <code>name</code>  string  (Optional) <p>The desired name of the pool if different from the CephBlockPool CR name.</p> <code>PoolSpec</code>  PoolSpec  <p> (Members of <code>PoolSpec</code> are embedded into this type.) </p> <p>The core pool configuration</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.NamedPoolSpec","title":"NamedPoolSpec","text":"<p> (Appears on:FilesystemSpec) </p> <p>NamedPoolSpec represents the named ceph pool spec</p> Field Description <code>name</code>  string  <p>Name of the pool</p> <code>PoolSpec</code>  PoolSpec  <p> (Members of <code>PoolSpec</code> are embedded into this type.) </p> <p>PoolSpec represents the spec of ceph pool</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.NetworkProviderType","title":"NetworkProviderType (<code>string</code> alias)","text":"<p> (Appears on:NetworkSpec) </p> <p>NetworkProviderType defines valid network providers for Rook.</p> Value Description <p>\"\"</p> <p>\"host\"</p> <p>\"multus\"</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.NetworkSpec","title":"NetworkSpec","text":"<p> (Appears on:ClusterSpec) </p> <p>NetworkSpec for Ceph includes backward compatibility code</p> Field Description <code>provider</code>  NetworkProviderType  (Optional) <p>Provider is what provides network connectivity to the cluster e.g. \u201chost\u201d or \u201cmultus\u201d. If the Provider is updated from being empty to \u201chost\u201d on a running cluster, then the operator will automatically fail over all the mons to apply the \u201chost\u201d network settings.</p> <code>selectors</code>  map[github.com/rook/rook/pkg/apis/ceph.rook.io/v1.CephNetworkType]string  (Optional) <p>Selectors define NetworkAttachmentDefinitions to be used for Ceph public and/or cluster networks when the \u201cmultus\u201d network provider is used. This config section is not used for other network providers.</p> <p>Valid keys are \u201cpublic\u201d and \u201ccluster\u201d. Refer to Ceph networking documentation for more: https://docs.ceph.com/en/latest/rados/configuration/network-config-ref/</p> <p>Refer to Multus network annotation documentation for help selecting values: https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/how-to-use.md#run-pod-with-network-annotation</p> <p>Rook will make a best-effort attempt to automatically detect CIDR address ranges for given network attachment definitions. Rook\u2019s methods are robust but may be imprecise for sufficiently complicated networks. Rook\u2019s auto-detection process obtains a new IP address lease for each CephCluster reconcile. If Rook fails to detect, incorrectly detects, only partially detects, or if underlying networks do not support reusing old IP addresses, it is best to use the \u2018addressRanges\u2019 config section to specify CIDR ranges for the Ceph cluster.</p> <p>As a contrived example, one can use a theoretical Kubernetes-wide network for Ceph client traffic and a theoretical Rook-only network for Ceph replication traffic as shown: selectors: public: \u201cdefault/cluster-fast-net\u201d cluster: \u201crook-ceph/ceph-backend-net\u201d</p> <code>addressRanges</code>  AddressRangesSpec  (Optional) <p>AddressRanges specify a list of CIDRs that Rook will apply to Ceph\u2019s \u2018public_network\u2019 and/or \u2018cluster_network\u2019 configurations. This config section may be used for the \u201chost\u201d or \u201cmultus\u201d network providers.</p> <code>connections</code>  ConnectionsSpec  (Optional) <p>Settings for network connections such as compression and encryption across the wire.</p> <code>hostNetwork</code>  bool  (Optional) <p>HostNetwork to enable host network. If host networking is enabled or disabled on a running cluster, then the operator will automatically fail over all the mons to apply the new network settings.</p> <code>ipFamily</code>  IPFamilyType  (Optional) <p>IPFamily is the single stack IPv6 or IPv4 protocol</p> <code>dualStack</code>  bool  (Optional) <p>DualStack determines whether Ceph daemons should listen on both IPv4 and IPv6</p> <code>multiClusterService</code>  MultiClusterServiceSpec  (Optional) <p>Enable multiClusterService to export the Services between peer clusters</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.Node","title":"Node","text":"<p> (Appears on:StorageScopeSpec) </p> <p>Node is a storage nodes</p> Field Description <code>name</code>  string  (Optional) <code>resources</code>  Kubernetes core/v1.ResourceRequirements  (Optional) <code>config</code>  map[string]string  (Optional) <code>Selection</code>  Selection  <p> (Members of <code>Selection</code> are embedded into this type.) </p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.NodesByName","title":"NodesByName (<code>[]github.com/rook/rook/pkg/apis/ceph.rook.io/v1.Node</code> alias)","text":"<p>NodesByName implements an interface to sort nodes by name</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.NotificationFilterRule","title":"NotificationFilterRule","text":"<p> (Appears on:NotificationFilterSpec) </p> <p>NotificationFilterRule represent a single rule in the Notification Filter spec</p> Field Description <code>name</code>  string  <p>Name of the metadata or tag</p> <code>value</code>  string  <p>Value to filter on</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.NotificationFilterSpec","title":"NotificationFilterSpec","text":"<p> (Appears on:BucketNotificationSpec) </p> <p>NotificationFilterSpec represent the spec of a Bucket Notification filter</p> Field Description <code>keyFilters</code>  []NotificationKeyFilterRule  (Optional) <p>Filters based on the object\u2019s key</p> <code>metadataFilters</code>  []NotificationFilterRule  (Optional) <p>Filters based on the object\u2019s metadata</p> <code>tagFilters</code>  []NotificationFilterRule  (Optional) <p>Filters based on the object\u2019s tags</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.NotificationKeyFilterRule","title":"NotificationKeyFilterRule","text":"<p> (Appears on:NotificationFilterSpec) </p> <p>NotificationKeyFilterRule represent a single key rule in the Notification Filter spec</p> Field Description <code>name</code>  string  <p>Name of the filter - prefix/suffix/regex</p> <code>value</code>  string  <p>Value to filter on</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.OSDStatus","title":"OSDStatus","text":"<p> (Appears on:CephStorage) </p> <p>OSDStatus represents OSD status of the ceph Cluster</p> Field Description <code>storeType</code>  map[string]int  <p>StoreType is a mapping between the OSD backend stores and number of OSDs using these stores</p> <code>migrationStatus</code>  MigrationStatus"},{"location":"CRDs/specification/#ceph.rook.io/v1.OSDStore","title":"OSDStore","text":"<p> (Appears on:StorageScopeSpec) </p> <p>OSDStore is the backend storage type used for creating the OSDs</p> Field Description <code>type</code>  string  (Optional) <p>Type of backend storage to be used while creating OSDs. If empty, then bluestore will be used</p> <code>updateStore</code>  string  (Optional) <p>UpdateStore updates the backend store for existing OSDs. It destroys each OSD one at a time, cleans up the backing disk and prepares same OSD on that disk</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectEndpointSpec","title":"ObjectEndpointSpec","text":"<p> (Appears on:ObjectStoreHostingSpec) </p> <p>ObjectEndpointSpec represents an object store endpoint</p> Field Description <code>dnsName</code>  string  <p>DnsName is the DNS name (in RFC-1123 format) of the endpoint. If the DNS name corresponds to an endpoint with DNS wildcard support, do not include the wildcard itself in the list of hostnames. E.g., use \u201cmystore.example.com\u201d instead of \u201c*.mystore.example.com\u201d.</p> <code>port</code>  int32  <p>Port is the port on which S3 connections can be made for this endpoint.</p> <code>useTls</code>  bool  <p>UseTls defines whether the endpoint uses TLS (HTTPS) or not (HTTP).</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectEndpoints","title":"ObjectEndpoints","text":"<p> (Appears on:ObjectStoreStatus) </p> Field Description <code>insecure</code>  []string  (Optional) <code>secure</code>  []string  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectHealthCheckSpec","title":"ObjectHealthCheckSpec","text":"<p> (Appears on:ObjectStoreSpec) </p> <p>ObjectHealthCheckSpec represents the health check of an object store</p> Field Description <code>readinessProbe</code>  ProbeSpec  (Optional) <code>startupProbe</code>  ProbeSpec  (Optional)"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectRealmSpec","title":"ObjectRealmSpec","text":"<p> (Appears on:CephObjectRealm) </p> <p>ObjectRealmSpec represent the spec of an ObjectRealm</p> Field Description <code>pull</code>  PullSpec"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectSharedPoolsSpec","title":"ObjectSharedPoolsSpec","text":"<p> (Appears on:ObjectStoreSpec, ObjectZoneSpec) </p> <p>ObjectSharedPoolsSpec represents object store pool info when configuring RADOS namespaces in existing pools.</p> Field Description <code>metadataPoolName</code>  string  (Optional) <p>The metadata pool used for creating RADOS namespaces in the object store</p> <code>dataPoolName</code>  string  (Optional) <p>The data pool used for creating RADOS namespaces in the object store</p> <code>preserveRadosNamespaceDataOnDelete</code>  bool  (Optional) <p>Whether the RADOS namespaces should be preserved on deletion of the object store</p> <code>poolPlacements</code>  []PoolPlacementSpec  (Optional) <p>PoolPlacements control which Pools are associated with a particular RGW bucket. Once PoolPlacements are defined, RGW client will be able to associate pool with ObjectStore bucket by providing \u201c\u201d during s3 bucket creation or \u201cX-Storage-Policy\u201d header during swift container creation. See: https://docs.ceph.com/en/latest/radosgw/placement/#placement-targets PoolPlacement with name: \u201cdefault\u201d will be used as a default pool if no option is provided during bucket creation. If default placement is not provided, spec.sharedPools.dataPoolName and spec.sharedPools.MetadataPoolName will be used as default pools. If spec.sharedPools are also empty, then RGW pools (spec.dataPool and spec.metadataPool) will be used as defaults."},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectStoreHostingSpec","title":"ObjectStoreHostingSpec","text":"<p> (Appears on:ObjectStoreSpec) </p> <p>ObjectStoreHostingSpec represents the hosting settings for the object store</p> Field Description <code>advertiseEndpoint</code>  ObjectEndpointSpec  (Optional) <p>AdvertiseEndpoint is the default endpoint Rook will return for resources dependent on this object store. This endpoint will be returned to CephObjectStoreUsers, Object Bucket Claims, and COSI Buckets/Accesses. By default, Rook returns the endpoint for the object store\u2019s Kubernetes service using HTTPS with <code>gateway.securePort</code> if it is defined (otherwise, HTTP with <code>gateway.port</code>).</p> <code>dnsNames</code>  []string  (Optional) <p>A list of DNS host names on which object store gateways will accept client S3 connections. When specified, object store gateways will reject client S3 connections to hostnames that are not present in this list, so include all endpoints. The object store\u2019s advertiseEndpoint and Kubernetes service endpoint, plus CephObjectZone <code>customEndpoints</code> are automatically added to the list but may be set here again if desired. Each DNS name must be valid according RFC-1123. If the DNS name corresponds to an endpoint with DNS wildcard support, do not include the wildcard itself in the list of hostnames. E.g., use \u201cmystore.example.com\u201d instead of \u201c*.mystore.example.com\u201d.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectStoreSecuritySpec","title":"ObjectStoreSecuritySpec","text":"<p> (Appears on:ObjectStoreSpec) </p> <p>ObjectStoreSecuritySpec is spec to define security features like encryption</p> Field Description <code>SecuritySpec</code>  SecuritySpec  (Optional) <code>s3</code>  KeyManagementServiceSpec  (Optional) <p>The settings for supporting AWS-SSE:S3 with RGW</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectStoreSpec","title":"ObjectStoreSpec","text":"<p> (Appears on:CephObjectStore) </p> <p>ObjectStoreSpec represent the spec of a pool</p> Field Description <code>metadataPool</code>  PoolSpec  (Optional) <p>The metadata pool settings</p> <code>dataPool</code>  PoolSpec  (Optional) <p>The data pool settings</p> <code>sharedPools</code>  ObjectSharedPoolsSpec  (Optional) <p>The pool information when configuring RADOS namespaces in existing pools.</p> <code>preservePoolsOnDelete</code>  bool  (Optional) <p>Preserve pools on object store deletion</p> <code>gateway</code>  GatewaySpec  (Optional) <p>The rgw pod info</p> <code>protocols</code>  ProtocolSpec  (Optional) <p>The protocol specification</p> <code>auth</code>  AuthSpec  (Optional) <p>The authentication configuration</p> <code>zone</code>  ZoneSpec  (Optional) <p>The multisite info</p> <code>healthCheck</code>  ObjectHealthCheckSpec  (Optional) <p>The RGW health probes</p> <code>security</code>  ObjectStoreSecuritySpec  (Optional) <p>Security represents security settings</p> <code>allowUsersInNamespaces</code>  []string  (Optional) <p>The list of allowed namespaces in addition to the object store namespace where ceph object store users may be created. Specify \u201c*\u201d to allow all namespaces, otherwise list individual namespaces that are to be allowed. This is useful for applications that need object store credentials to be created in their own namespace, where neither OBCs nor COSI is being used to create buckets. The default is empty.</p> <code>hosting</code>  ObjectStoreHostingSpec  (Optional) <p>Hosting settings for the object store. A common use case for hosting configuration is to inform Rook of endpoints that support DNS wildcards, which in turn allows virtual host-style bucket addressing.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectStoreStatus","title":"ObjectStoreStatus","text":"<p> (Appears on:CephObjectStore) </p> <p>ObjectStoreStatus represents the status of a Ceph Object Store resource</p> Field Description <code>phase</code>  ConditionType  (Optional) <code>message</code>  string  (Optional) <code>endpoints</code>  ObjectEndpoints  (Optional) <code>info</code>  map[string]string  (Optional) <code>conditions</code>  []Condition  <code>observedGeneration</code>  int64  (Optional) <p>ObservedGeneration is the latest generation observed by the controller.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectStoreUserSpec","title":"ObjectStoreUserSpec","text":"<p> (Appears on:CephObjectStoreUser) </p> <p>ObjectStoreUserSpec represent the spec of an Objectstoreuser</p> Field Description <code>store</code>  string  (Optional) <p>The store the user will be created in</p> <code>displayName</code>  string  (Optional) <p>The display name for the ceph users</p> <code>capabilities</code>  ObjectUserCapSpec  (Optional) <code>quotas</code>  ObjectUserQuotaSpec  (Optional) <code>clusterNamespace</code>  string  (Optional) <p>The namespace where the parent CephCluster and CephObjectStore are found</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectStoreUserStatus","title":"ObjectStoreUserStatus","text":"<p> (Appears on:CephObjectStoreUser) </p> <p>ObjectStoreUserStatus represents the status Ceph Object Store Gateway User</p> Field Description <code>phase</code>  string  (Optional) <code>info</code>  map[string]string  (Optional) <code>observedGeneration</code>  int64  (Optional) <p>ObservedGeneration is the latest generation observed by the controller.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectUserCapSpec","title":"ObjectUserCapSpec","text":"<p> (Appears on:ObjectStoreUserSpec) </p> <p>Additional admin-level capabilities for the Ceph object store user</p> Field Description <code>user</code>  string  (Optional) <p>Admin capabilities to read/write Ceph object store users. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>users</code>  string  (Optional) <p>Admin capabilities to read/write Ceph object store users. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>bucket</code>  string  (Optional) <p>Admin capabilities to read/write Ceph object store buckets. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>buckets</code>  string  (Optional) <p>Admin capabilities to read/write Ceph object store buckets. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>metadata</code>  string  (Optional) <p>Admin capabilities to read/write Ceph object store metadata. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>usage</code>  string  (Optional) <p>Admin capabilities to read/write Ceph object store usage. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>zone</code>  string  (Optional) <p>Admin capabilities to read/write Ceph object store zones. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>roles</code>  string  (Optional) <p>Admin capabilities to read/write roles for user. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>info</code>  string  (Optional) <p>Admin capabilities to read/write information about the user. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>amz-cache</code>  string  (Optional) <p>Add capabilities for user to send request to RGW Cache API header. Documented in https://docs.ceph.com/en/latest/radosgw/rgw-cache/#cache-api</p> <code>bilog</code>  string  (Optional) <p>Add capabilities for user to change bucket index logging. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>mdlog</code>  string  (Optional) <p>Add capabilities for user to change metadata logging. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>datalog</code>  string  (Optional) <p>Add capabilities for user to change data logging. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>user-policy</code>  string  (Optional) <p>Add capabilities for user to change user policies. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>oidc-provider</code>  string  (Optional) <p>Add capabilities for user to change oidc provider. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p> <code>ratelimit</code>  string  (Optional) <p>Add capabilities for user to set rate limiter for user and bucket. Documented in https://docs.ceph.com/en/latest/radosgw/admin/?#add-remove-admin-capabilities</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectUserQuotaSpec","title":"ObjectUserQuotaSpec","text":"<p> (Appears on:ObjectStoreUserSpec) </p> <p>ObjectUserQuotaSpec can be used to set quotas for the object store user to limit their usage. See the Ceph docs for more</p> Field Description <code>maxBuckets</code>  int  (Optional) <p>Maximum bucket limit for the ceph user</p> <code>maxSize</code>  k8s.io/apimachinery/pkg/api/resource.Quantity  (Optional) <p>Maximum size limit of all objects across all the user\u2019s buckets See https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity for more info.</p> <code>maxObjects</code>  int64  (Optional) <p>Maximum number of objects across all the user\u2019s buckets</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectZoneGroupSpec","title":"ObjectZoneGroupSpec","text":"<p> (Appears on:CephObjectZoneGroup) </p> <p>ObjectZoneGroupSpec represent the spec of an ObjectZoneGroup</p> Field Description <code>realm</code>  string  <p>The display name for the ceph users</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ObjectZoneSpec","title":"ObjectZoneSpec","text":"<p> (Appears on:CephObjectZone) </p> <p>ObjectZoneSpec represent the spec of an ObjectZone</p> Field Description <code>zoneGroup</code>  string  <p>The display name for the ceph users</p> <code>metadataPool</code>  PoolSpec  (Optional) <p>The metadata pool settings</p> <code>dataPool</code>  PoolSpec  (Optional) <p>The data pool settings</p> <code>sharedPools</code>  ObjectSharedPoolsSpec  (Optional) <p>The pool information when configuring RADOS namespaces in existing pools.</p> <code>customEndpoints</code>  []string  (Optional) <p>If this zone cannot be accessed from other peer Ceph clusters via the ClusterIP Service endpoint created by Rook, you must set this to the externally reachable endpoint(s). You may include the port in the definition. For example: \u201chttps://my-object-store.my-domain.net:443\u201d. In many cases, you should set this to the endpoint of the ingress resource that makes the CephObjectStore associated with this CephObjectStoreZone reachable to peer clusters. The list can have one or more endpoints pointing to different RGW servers in the zone.</p> <p>If a CephObjectStore endpoint is omitted from this list, that object store\u2019s gateways will not receive multisite replication data (see CephObjectStore.spec.gateway.disableMultisiteSyncTraffic).</p> <code>preservePoolsOnDelete</code>  bool  (Optional) <p>Preserve pools on object zone deletion</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.PeerRemoteSpec","title":"PeerRemoteSpec","text":"<p> (Appears on:FilesystemMirrorInfoPeerSpec) </p> Field Description <code>client_name</code>  string  (Optional) <p>ClientName is cephx name</p> <code>cluster_name</code>  string  (Optional) <p>ClusterName is the name of the cluster</p> <code>fs_name</code>  string  (Optional) <p>FsName is the filesystem name</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.PeerStatSpec","title":"PeerStatSpec","text":"<p> (Appears on:FilesystemMirrorInfoPeerSpec) </p> <p>PeerStatSpec are the mirror stat with a given peer</p> Field Description <code>failure_count</code>  int  (Optional) <p>FailureCount is the number of mirroring failure</p> <code>recovery_count</code>  int  (Optional) <p>RecoveryCount is the number of recovery attempted after failures</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.PeersSpec","title":"PeersSpec","text":"<p> (Appears on:MirroringInfo) </p> <p>PeersSpec contains peer details</p> Field Description <code>uuid</code>  string  (Optional) <p>UUID is the peer UUID</p> <code>direction</code>  string  (Optional) <p>Direction is the peer mirroring direction</p> <code>site_name</code>  string  (Optional) <p>SiteName is the current site name</p> <code>mirror_uuid</code>  string  (Optional) <p>MirrorUUID is the mirror UUID</p> <code>client_name</code>  string  (Optional) <p>ClientName is the CephX user used to connect to the peer</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.Placement","title":"Placement","text":"<p> (Appears on:CephCOSIDriverSpec, FilesystemMirroringSpec, GaneshaServerSpec, GatewaySpec, MetadataServerSpec, RBDMirroringSpec, StorageClassDeviceSet) </p> <p>Placement is the placement for an object</p> Field Description <code>nodeAffinity</code>  Kubernetes core/v1.NodeAffinity  (Optional) <p>NodeAffinity is a group of node affinity scheduling rules</p> <code>podAffinity</code>  Kubernetes core/v1.PodAffinity  (Optional) <p>PodAffinity is a group of inter pod affinity scheduling rules</p> <code>podAntiAffinity</code>  Kubernetes core/v1.PodAntiAffinity  (Optional) <p>PodAntiAffinity is a group of inter pod anti affinity scheduling rules</p> <code>tolerations</code>  []Kubernetes core/v1.Toleration  (Optional) <p>The pod this Toleration is attached to tolerates any taint that matches the triple  using the matching operator  <code>topologySpreadConstraints</code>  []Kubernetes core/v1.TopologySpreadConstraint  (Optional) <p>TopologySpreadConstraints specifies how to spread matching pods among the given topology</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.PlacementSpec","title":"PlacementSpec (<code>map[github.com/rook/rook/pkg/apis/ceph.rook.io/v1.KeyType]github.com/rook/rook/pkg/apis/ceph.rook.io/v1.Placement</code> alias)","text":"<p> (Appears on:ClusterSpec) </p> <p>PlacementSpec is the placement for core ceph daemons part of the CephCluster CRD</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.PlacementStorageClassSpec","title":"PlacementStorageClassSpec","text":"<p> (Appears on:PoolPlacementSpec) </p> Field Description <code>name</code>  string  <p>Name is the StorageClass name. Ceph allows arbitrary name for StorageClasses, however most clients/libs insist on AWS names so it is recommended to use one of the valid x-amz-storage-class values for better compatibility: REDUCED_REDUNDANCY | STANDARD_IA | ONEZONE_IA | INTELLIGENT_TIERING | GLACIER | DEEP_ARCHIVE | OUTPOSTS | GLACIER_IR | SNOW | EXPRESS_ONEZONE See AWS docs: https://aws.amazon.com/de/s3/storage-classes/</p> <code>dataPoolName</code>  string  <p>DataPoolName is the data pool used to store ObjectStore objects data.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.PoolPlacementSpec","title":"PoolPlacementSpec","text":"<p> (Appears on:ObjectSharedPoolsSpec) </p> Field Description <code>name</code>  string  <p>Pool placement name. Name can be arbitrary. Placement with name \u201cdefault\u201d will be used as default.</p> <code>default</code>  bool  (Optional) <p>Sets given placement as default. Only one placement in the list can be marked as default. Default is false.</p> <code>metadataPoolName</code>  string  <p>The metadata pool used to store ObjectStore bucket index.</p> <code>dataPoolName</code>  string  <p>The data pool used to store ObjectStore objects data.</p> <code>dataNonECPoolName</code>  string  (Optional) <p>The data pool used to store ObjectStore data that cannot use erasure coding (ex: multi-part uploads). If dataPoolName is not erasure coded, then there is no need for dataNonECPoolName.</p> <code>storageClasses</code>  []PlacementStorageClassSpec  (Optional) <p>StorageClasses can be selected by user to override dataPoolName during object creation. Each placement has default STANDARD StorageClass pointing to dataPoolName. This list allows defining additional StorageClasses on top of default STANDARD storage class.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.PoolSpec","title":"PoolSpec","text":"<p> (Appears on:NamedBlockPoolSpec, NamedPoolSpec, ObjectStoreSpec, ObjectZoneSpec) </p> <p>PoolSpec represents the spec of ceph pool</p> Field Description <code>failureDomain</code>  string  (Optional) <p>The failure domain: osd/host/(region or zone if available) - technically also any type in the crush map</p> <code>crushRoot</code>  string  (Optional) <p>The root of the crush hierarchy utilized by the pool</p> <code>deviceClass</code>  string  (Optional) <p>The device class the OSD should set to for use in the pool</p> <code>enableCrushUpdates</code>  bool  (Optional) <p>Allow rook operator to change the pool CRUSH tunables once the pool is created</p> <code>compressionMode</code>  string  (Optional) <p>DEPRECATED: use Parameters instead, e.g., Parameters[\u201ccompression_mode\u201d] = \u201cforce\u201d The inline compression mode in Bluestore OSD to set to (options are: none, passive, aggressive, force) Do NOT set a default value for kubebuilder as this will override the Parameters</p> <code>replicated</code>  ReplicatedSpec  (Optional) <p>The replication settings</p> <code>erasureCoded</code>  ErasureCodedSpec  (Optional) <p>The erasure code settings</p> <code>parameters</code>  map[string]string  (Optional) <p>Parameters is a list of properties to enable on a given pool</p> <code>enableRBDStats</code>  bool  <p>EnableRBDStats is used to enable gathering of statistics for all RBD images in the pool</p> <code>mirroring</code>  MirroringSpec  <p>The mirroring settings</p> <code>statusCheck</code>  MirrorHealthCheckSpec  <p>The mirroring statusCheck</p> <code>quotas</code>  QuotaSpec  (Optional) <p>The quota settings</p> <code>application</code>  string  (Optional) <p>The application name to set on the pool. Only expected to be set for rgw pools.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.PriorityClassNamesSpec","title":"PriorityClassNamesSpec (<code>map[github.com/rook/rook/pkg/apis/ceph.rook.io/v1.KeyType]string</code> alias)","text":"<p> (Appears on:ClusterSpec) </p> <p>PriorityClassNamesSpec is a map of priority class names to be assigned to components</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ProbeSpec","title":"ProbeSpec","text":"<p> (Appears on:GaneshaServerSpec, MetadataServerSpec, ObjectHealthCheckSpec) </p> <p>ProbeSpec is a wrapper around Probe so it can be enabled or disabled for a Ceph daemon</p> Field Description <code>disabled</code>  bool  (Optional) <p>Disabled determines whether probe is disable or not</p> <code>probe</code>  Kubernetes core/v1.Probe  (Optional) <p>Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ProtocolSpec","title":"ProtocolSpec","text":"<p> (Appears on:ObjectStoreSpec) </p> <p>ProtocolSpec represents a Ceph Object Store protocol specification</p> Field Description <code>s3</code>  S3Spec  (Optional) <p>The spec for S3</p> <code>swift</code>  SwiftSpec  (Optional) <p>The spec for Swift</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.PullSpec","title":"PullSpec","text":"<p> (Appears on:ObjectRealmSpec) </p> <p>PullSpec represents the pulling specification of a Ceph Object Storage Gateway Realm</p> Field Description <code>endpoint</code>  string"},{"location":"CRDs/specification/#ceph.rook.io/v1.QuotaSpec","title":"QuotaSpec","text":"<p> (Appears on:PoolSpec) </p> <p>QuotaSpec represents the spec for quotas in a pool</p> Field Description <code>maxBytes</code>  uint64  (Optional) <p>MaxBytes represents the quota in bytes Deprecated in favor of MaxSize</p> <code>maxSize</code>  string  (Optional) <p>MaxSize represents the quota in bytes as a string</p> <code>maxObjects</code>  uint64  (Optional) <p>MaxObjects represents the quota in objects</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.RBDMirroringSpec","title":"RBDMirroringSpec","text":"<p> (Appears on:CephRBDMirror) </p> <p>RBDMirroringSpec represents the specification of an RBD mirror daemon</p> Field Description <code>count</code>  int  <p>Count represents the number of rbd mirror instance to run</p> <code>peers</code>  MirroringPeerSpec  (Optional) <p>Peers represents the peers spec</p> <code>placement</code>  Placement  (Optional) <p>The affinity to place the rgw pods (default is to place on any available node)</p> <code>annotations</code>  Annotations  (Optional) <p>The annotations-related configuration to add/set on each Pod related object.</p> <code>labels</code>  Labels  (Optional) <p>The labels-related configuration to add/set on each Pod related object.</p> <code>resources</code>  Kubernetes core/v1.ResourceRequirements  (Optional) <p>The resource requirements for the rbd mirror pods</p> <code>priorityClassName</code>  string  (Optional) <p>PriorityClassName sets priority class on the rbd mirror pods</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.RGWServiceSpec","title":"RGWServiceSpec","text":"<p> (Appears on:GatewaySpec) </p> <p>RGWServiceSpec represent the spec for RGW service</p> Field Description <code>annotations</code>  Annotations  <p>The annotations-related configuration to add/set on each rgw service. nullable optional</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.RadosNamespaceMirroring","title":"RadosNamespaceMirroring","text":"<p> (Appears on:CephBlockPoolRadosNamespaceSpec) </p> <p>RadosNamespaceMirroring represents the mirroring configuration of CephBlockPoolRadosNamespace</p> Field Description <code>remoteNamespace</code>  string  (Optional) <p>RemoteNamespace is the name of the CephBlockPoolRadosNamespace on the secondary cluster CephBlockPool</p> <code>mode</code>  RadosNamespaceMirroringMode  <p>Mode is the mirroring mode; either pool or image</p> <code>snapshotSchedules</code>  []SnapshotScheduleSpec  (Optional) <p>SnapshotSchedules is the scheduling of snapshot for mirrored images</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.RadosNamespaceMirroringMode","title":"RadosNamespaceMirroringMode (<code>string</code> alias)","text":"<p> (Appears on:RadosNamespaceMirroring) </p> <p>RadosNamespaceMirroringMode represents the mode of the RadosNamespace</p> Value Description <p>\"image\"</p> <p>RadosNamespaceMirroringModeImage represents the image mode</p> <p>\"pool\"</p> <p>RadosNamespaceMirroringModePool represents the pool mode</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ReadAffinitySpec","title":"ReadAffinitySpec","text":"<p> (Appears on:CSIDriverSpec) </p> <p>ReadAffinitySpec defines the read affinity settings for CSI driver.</p> Field Description <code>enabled</code>  bool  (Optional) <p>Enables read affinity for CSI driver.</p> <code>crushLocationLabels</code>  []string  (Optional) <p>CrushLocationLabels defines which node labels to use as CRUSH location. This should correspond to the values set in the CRUSH map.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ReplicatedSpec","title":"ReplicatedSpec","text":"<p> (Appears on:PoolSpec) </p> <p>ReplicatedSpec represents the spec for replication in a pool</p> Field Description <code>size</code>  uint  <p>Size - Number of copies per object in a replicated storage pool, including the object itself (required for replicated pool type)</p> <code>targetSizeRatio</code>  float64  (Optional) <p>TargetSizeRatio gives a hint (%) to Ceph in terms of expected consumption of the total cluster capacity</p> <code>requireSafeReplicaSize</code>  bool  (Optional) <p>RequireSafeReplicaSize if false allows you to set replica 1</p> <code>replicasPerFailureDomain</code>  uint  (Optional) <p>ReplicasPerFailureDomain the number of replica in the specified failure domain</p> <code>subFailureDomain</code>  string  (Optional) <p>SubFailureDomain the name of the sub-failure domain</p> <code>hybridStorage</code>  HybridStorageSpec  (Optional) <p>HybridStorage represents hybrid storage tier settings</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ResourceSpec","title":"ResourceSpec (<code>map[string]k8s.io/api/core/v1.ResourceRequirements</code> alias)","text":"<p> (Appears on:ClusterSpec) </p> <p>ResourceSpec is a collection of ResourceRequirements that describes the compute resource requirements</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.S3Spec","title":"S3Spec","text":"<p> (Appears on:ProtocolSpec) </p> <p>S3Spec represents Ceph Object Store specification for the S3 API</p> Field Description <code>enabled</code>  bool  (Optional) <p>Whether to enable S3. This defaults to true (even if protocols.s3 is not present in the CRD). This maintains backwards compatibility \u2013 by default S3 is enabled.</p> <code>authUseKeystone</code>  bool  (Optional) <p>Whether to use Keystone for authentication. This option maps directly to the rgw_s3_auth_use_keystone option. Enabling it allows generating S3 credentials via an OpenStack API call, see the docs. If not given, the defaults of the corresponding RGW option apply.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SSSDSidecar","title":"SSSDSidecar","text":"<p> (Appears on:SSSDSpec) </p> <p>SSSDSidecar represents configuration when SSSD is run in a sidecar.</p> Field Description <code>image</code>  string  <p>Image defines the container image that should be used for the SSSD sidecar.</p> <code>sssdConfigFile</code>  SSSDSidecarConfigFile  (Optional) <p>SSSDConfigFile defines where the SSSD configuration should be sourced from. The config file will be placed into <code>/etc/sssd/sssd.conf</code>. If this is left empty, Rook will not add the file. This allows you to manage the <code>sssd.conf</code> file yourself however you wish. For example, you may build it into your custom Ceph container image or use the Vault agent injector to securely add the file via annotations on the CephNFS spec (passed to the NFS server pods).</p> <code>additionalFiles</code>  AdditionalVolumeMounts  (Optional) <p>AdditionalFiles defines any number of additional files that should be mounted into the SSSD sidecar with a directory root of <code>/etc/sssd/rook-additional/</code>. These files may be referenced by the sssd.conf config file.</p> <code>resources</code>  Kubernetes core/v1.ResourceRequirements  (Optional) <p>Resources allow specifying resource requests/limits on the SSSD sidecar container.</p> <code>debugLevel</code>  int  (Optional) <p>DebugLevel sets the debug level for SSSD. If unset or set to 0, Rook does nothing. Otherwise, this may be a value between 1 and 10. See SSSD docs for more info: https://sssd.io/troubleshooting/basics.html#sssd-debug-logs</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SSSDSidecarConfigFile","title":"SSSDSidecarConfigFile","text":"<p> (Appears on:SSSDSidecar) </p> <p>SSSDSidecarConfigFile represents the source(s) from which the SSSD configuration should come.</p> Field Description <code>volumeSource</code>  ConfigFileVolumeSource  <p>VolumeSource accepts a pared down version of the standard Kubernetes VolumeSource for the SSSD configuration file like what is normally used to configure Volumes for a Pod. For example, a ConfigMap, Secret, or HostPath. There are two requirements for the source\u2019s content: 1. The config file must be mountable via <code>subPath: sssd.conf</code>. For example, in a ConfigMap, the data item must be named <code>sssd.conf</code>, or <code>items</code> must be defined to select the key and give it path <code>sssd.conf</code>. A HostPath directory must have the <code>sssd.conf</code> file. 2. The volume or config file must have mode 0600.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SSSDSpec","title":"SSSDSpec","text":"<p> (Appears on:NFSSecuritySpec) </p> <p>SSSDSpec represents configuration for System Security Services Daemon (SSSD).</p> Field Description <code>sidecar</code>  SSSDSidecar  (Optional) <p>Sidecar tells Rook to run SSSD in a sidecar alongside the NFS-Ganesha server in each NFS pod.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SanitizeDataSourceProperty","title":"SanitizeDataSourceProperty (<code>string</code> alias)","text":"<p> (Appears on:SanitizeDisksSpec) </p> <p>SanitizeDataSourceProperty represents a sanitizing data source</p> Value Description <p>\"random\"</p> <p>SanitizeDataSourceRandom uses `shred\u2019s default entropy source</p> <p>\"zero\"</p> <p>SanitizeDataSourceZero uses /dev/zero as sanitize source</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SanitizeDisksSpec","title":"SanitizeDisksSpec","text":"<p> (Appears on:CleanupPolicySpec) </p> <p>SanitizeDisksSpec represents a disk sanitizing specification</p> Field Description <code>method</code>  SanitizeMethodProperty  (Optional) <p>Method is the method we use to sanitize disks</p> <code>dataSource</code>  SanitizeDataSourceProperty  (Optional) <p>DataSource is the data source to use to sanitize the disk with</p> <code>iteration</code>  int32  (Optional) <p>Iteration is the number of pass to apply the sanitizing</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SanitizeMethodProperty","title":"SanitizeMethodProperty (<code>string</code> alias)","text":"<p> (Appears on:SanitizeDisksSpec) </p> <p>SanitizeMethodProperty represents a disk sanitizing method</p> Value Description <p>\"complete\"</p> <p>SanitizeMethodComplete will sanitize everything on the disk</p> <p>\"quick\"</p> <p>SanitizeMethodQuick will sanitize metadata only on the disk</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SecuritySpec","title":"SecuritySpec","text":"<p> (Appears on:ClusterSpec, ObjectStoreSecuritySpec) </p> <p>SecuritySpec is security spec to include various security items such as kms</p> Field Description <code>kms</code>  KeyManagementServiceSpec  (Optional) <p>KeyManagementService is the main Key Management option</p> <code>keyRotation</code>  KeyRotationSpec  (Optional) <p>KeyRotation defines options for Key Rotation.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.Selection","title":"Selection","text":"<p> (Appears on:Node, StorageScopeSpec) </p> Field Description <code>useAllDevices</code>  bool  (Optional) <p>Whether to consume all the storage devices found on a machine</p> <code>deviceFilter</code>  string  (Optional) <p>A regular expression to allow more fine-grained selection of devices on nodes across the cluster</p> <code>devicePathFilter</code>  string  (Optional) <p>A regular expression to allow more fine-grained selection of devices with path names</p> <code>devices</code>  []Device  (Optional) <p>List of devices to use as storage devices</p> <code>volumeClaimTemplates</code>  []VolumeClaimTemplate  (Optional) <p>PersistentVolumeClaims to use as storage</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SnapshotSchedule","title":"SnapshotSchedule","text":"<p> (Appears on:SnapshotSchedulesSpec) </p> <p>SnapshotSchedule is a schedule</p> Field Description <code>interval</code>  string  (Optional) <p>Interval is the interval in which snapshots will be taken</p> <code>start_time</code>  string  (Optional) <p>StartTime is the snapshot starting time</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SnapshotScheduleRetentionSpec","title":"SnapshotScheduleRetentionSpec","text":"<p> (Appears on:FSMirroringSpec) </p> <p>SnapshotScheduleRetentionSpec is a retention policy</p> Field Description <code>path</code>  string  (Optional) <p>Path is the path to snapshot</p> <code>duration</code>  string  (Optional) <p>Duration represents the retention duration for a snapshot</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SnapshotScheduleSpec","title":"SnapshotScheduleSpec","text":"<p> (Appears on:FSMirroringSpec, MirroringSpec, RadosNamespaceMirroring) </p> <p>SnapshotScheduleSpec represents the snapshot scheduling settings of a mirrored pool</p> Field Description <code>path</code>  string  (Optional) <p>Path is the path to snapshot, only valid for CephFS</p> <code>interval</code>  string  (Optional) <p>Interval represent the periodicity of the snapshot.</p> <code>startTime</code>  string  (Optional) <p>StartTime indicates when to start the snapshot</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SnapshotScheduleStatusSpec","title":"SnapshotScheduleStatusSpec","text":"<p> (Appears on:CephBlockPoolRadosNamespaceStatus, CephBlockPoolStatus) </p> <p>SnapshotScheduleStatusSpec is the status of the snapshot schedule</p> Field Description <code>snapshotSchedules</code>  []SnapshotSchedulesSpec  (Optional) <p>SnapshotSchedules is the list of snapshots scheduled</p> <code>lastChecked</code>  string  (Optional) <p>LastChecked is the last time time the status was checked</p> <code>lastChanged</code>  string  (Optional) <p>LastChanged is the last time time the status last changed</p> <code>details</code>  string  (Optional) <p>Details contains potential status errors</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SnapshotSchedulesSpec","title":"SnapshotSchedulesSpec","text":"<p> (Appears on:SnapshotScheduleStatusSpec) </p> <p>SnapshotSchedulesSpec is the list of snapshot scheduled for images in a pool</p> Field Description <code>pool</code>  string  (Optional) <p>Pool is the pool name</p> <code>namespace</code>  string  (Optional) <p>Namespace is the RADOS namespace the image is part of</p> <code>image</code>  string  (Optional) <p>Image is the mirrored image</p> <code>items</code>  []SnapshotSchedule  (Optional) <p>Items is the list schedules times for a given snapshot</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.StatesSpec","title":"StatesSpec","text":"<p> (Appears on:MirroringStatusSummarySpec) </p> <p>StatesSpec are rbd images mirroring state</p> Field Description <code>starting_replay</code>  int  (Optional) <p>StartingReplay is when the replay of the mirroring journal starts</p> <code>replaying</code>  int  (Optional) <p>Replaying is when the replay of the mirroring journal is on-going</p> <code>syncing</code>  int  (Optional) <p>Syncing is when the image is syncing</p> <code>stopping_replay</code>  int  (Optional) <p>StopReplaying is when the replay of the mirroring journal stops</p> <code>stopped</code>  int  (Optional) <p>Stopped is when the mirroring state is stopped</p> <code>unknown</code>  int  (Optional) <p>Unknown is when the mirroring state is unknown</p> <code>error</code>  int  (Optional) <p>Error is when the mirroring state is errored</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.Status","title":"Status","text":"<p> (Appears on:CephBucketNotification, CephFilesystemMirror, CephNFS, CephObjectRealm, CephObjectZone, CephObjectZoneGroup, CephRBDMirror) </p> <p>Status represents the status of an object</p> Field Description <code>phase</code>  string  (Optional) <code>observedGeneration</code>  int64  (Optional) <p>ObservedGeneration is the latest generation observed by the controller.</p> <code>conditions</code>  []Condition"},{"location":"CRDs/specification/#ceph.rook.io/v1.StorageClassDeviceSet","title":"StorageClassDeviceSet","text":"<p> (Appears on:StorageScopeSpec) </p> <p>StorageClassDeviceSet is a storage class device set</p> Field Description <code>name</code>  string  <p>Name is a unique identifier for the set</p> <code>count</code>  int  <p>Count is the number of devices in this set</p> <code>resources</code>  Kubernetes core/v1.ResourceRequirements  (Optional) <code>placement</code>  Placement  (Optional) <code>preparePlacement</code>  Placement  (Optional) <code>config</code>  map[string]string  (Optional) <p>Provider-specific device configuration</p> <code>volumeClaimTemplates</code>  []VolumeClaimTemplate  <p>VolumeClaimTemplates is a list of PVC templates for the underlying storage devices</p> <code>portable</code>  bool  (Optional) <p>Portable represents OSD portability across the hosts</p> <code>tuneDeviceClass</code>  bool  (Optional) <p>TuneSlowDeviceClass Tune the OSD when running on a slow Device Class</p> <code>tuneFastDeviceClass</code>  bool  (Optional) <p>TuneFastDeviceClass Tune the OSD when running on a fast Device Class</p> <code>schedulerName</code>  string  (Optional) <p>Scheduler name for OSD pod placement</p> <code>encrypted</code>  bool  (Optional) <p>Whether to encrypt the deviceSet</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.StorageScopeSpec","title":"StorageScopeSpec","text":"<p> (Appears on:ClusterSpec) </p> Field Description <code>nodes</code>  []Node  (Optional) <code>useAllNodes</code>  bool  (Optional) <code>scheduleAlways</code>  bool  (Optional) <p>Whether to always schedule OSDs on a node even if the node is not currently scheduleable or ready</p> <code>onlyApplyOSDPlacement</code>  bool  (Optional) <code>config</code>  map[string]string  (Optional) <code>Selection</code>  Selection  <p> (Members of <code>Selection</code> are embedded into this type.) </p> <code>storageClassDeviceSets</code>  []StorageClassDeviceSet  (Optional) <code>migration</code>  Migration  (Optional) <p>Migration handles the OSD migration</p> <code>store</code>  OSDStore  (Optional) <code>flappingRestartIntervalHours</code>  int  (Optional) <p>FlappingRestartIntervalHours defines the time for which the OSD pods, that failed with zero exit code, will sleep before restarting. This is needed for OSD flapping where OSD daemons are marked down more than 5 times in 600 seconds by Ceph. Preventing the OSD pods to restart immediately in such scenarios will prevent Rook from marking OSD as <code>up</code> and thus peering of the PGs mapped to the OSD. User needs to manually restart the OSD pod if they manage to fix the underlying OSD flapping issue before the restart interval. The sleep will be disabled if this interval is set to 0.</p> <code>fullRatio</code>  float64  (Optional) <p>FullRatio is the ratio at which the cluster is considered full and ceph will stop accepting writes. Default is 0.95.</p> <code>nearFullRatio</code>  float64  (Optional) <p>NearFullRatio is the ratio at which the cluster is considered nearly full and will raise a ceph health warning. Default is 0.85.</p> <code>backfillFullRatio</code>  float64  (Optional) <p>BackfillFullRatio is the ratio at which the cluster is too full for backfill. Backfill will be disabled if above this threshold. Default is 0.90.</p> <code>allowDeviceClassUpdate</code>  bool  (Optional) <p>Whether to allow updating the device class after the OSD is initially provisioned</p> <code>allowOsdCrushWeightUpdate</code>  bool  (Optional) <p>Whether Rook will resize the OSD CRUSH weight when the OSD PVC size is increased. This allows cluster data to be rebalanced to make most effective use of new OSD space. The default is false since data rebalancing can cause temporary cluster slowdown.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.StoreType","title":"StoreType (<code>string</code> alias)","text":"Value Description <p>\"bluestore\"</p> <p>StoreTypeBlueStore is the bluestore backend storage for OSDs</p> <p>\"bluestore-rdr\"</p> <p>StoreTypeBlueStoreRDR is the bluestore-rdr backed storage for OSDs</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.StretchClusterSpec","title":"StretchClusterSpec","text":"<p> (Appears on:MonSpec) </p> <p>StretchClusterSpec represents the specification of a stretched Ceph Cluster</p> Field Description <code>failureDomainLabel</code>  string  (Optional) <p>FailureDomainLabel the failure domain name (e,g: zone)</p> <code>subFailureDomain</code>  string  (Optional) <p>SubFailureDomain is the failure domain within a zone</p> <code>zones</code>  []MonZoneSpec  (Optional) <p>Zones is the list of zones</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.SwiftSpec","title":"SwiftSpec","text":"<p> (Appears on:ProtocolSpec) </p> <p>SwiftSpec represents Ceph Object Store specification for the Swift API</p> Field Description <code>accountInUrl</code>  bool  (Optional) <p>Whether or not the Swift account name should be included in the Swift API URL. If set to false (the default), then the Swift API will listen on a URL formed like http://host:port//v1. If set to true, the Swift API URL will be http://host:port//v1/AUTH_. You must set this option to true (and update the Keystone service catalog) if you want radosgw to support publicly-readable containers and temporary URLs. <code>urlPrefix</code>  string  (Optional) <p>The URL prefix for the Swift API, to distinguish it from the S3 API endpoint. The default is swift, which makes the Swift API available at the URL http://host:port/swift/v1 (or http://host:port/swift/v1/AUTH_%(tenant_id)s if rgw swift account in url is enabled).</p> <code>versioningEnabled</code>  bool  (Optional) <p>Enables the Object Versioning of OpenStack Object Storage API. This allows clients to put the X-Versions-Location attribute on containers that should be versioned.</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.TopicEndpointSpec","title":"TopicEndpointSpec","text":"<p> (Appears on:BucketTopicSpec) </p> <p>TopicEndpointSpec contains exactly one of the endpoint specs of a Bucket Topic</p> Field Description <code>http</code>  HTTPEndpointSpec  (Optional) <p>Spec of HTTP endpoint</p> <code>amqp</code>  AMQPEndpointSpec  (Optional) <p>Spec of AMQP endpoint</p> <code>kafka</code>  KafkaEndpointSpec  (Optional) <p>Spec of Kafka endpoint</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.VolumeClaimTemplate","title":"VolumeClaimTemplate","text":"<p> (Appears on:MonSpec, MonZoneSpec, Selection, StorageClassDeviceSet) </p> <p>VolumeClaimTemplate is a simplified version of K8s corev1\u2019s PVC. It has no type meta or status.</p> Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta  (Optional) <p>Standard object\u2019s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</p> Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  Kubernetes core/v1.PersistentVolumeClaimSpec  (Optional) <p>spec defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims</p> <code>accessModes</code>  []Kubernetes core/v1.PersistentVolumeAccessMode  (Optional) <p>accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1</p> <code>selector</code>  Kubernetes meta/v1.LabelSelector  (Optional) <p>selector is a label query over volumes to consider for binding.</p> <code>resources</code>  Kubernetes core/v1.VolumeResourceRequirements  (Optional) <p>resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources</p> <code>volumeName</code>  string  (Optional) <p>volumeName is the binding reference to the PersistentVolume backing this claim.</p> <code>storageClassName</code>  string  (Optional) <p>storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1</p> <code>volumeMode</code>  Kubernetes core/v1.PersistentVolumeMode  (Optional) <p>volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.</p> <code>dataSource</code>  Kubernetes core/v1.TypedLocalObjectReference  (Optional) <p>dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.</p> <code>dataSourceRef</code>  Kubernetes core/v1.TypedObjectReference  (Optional) <p>dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn\u2019t specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn\u2019t set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.</p> <code>volumeAttributesClassName</code>  string  (Optional) <p>volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim. If specified, the CSI driver will create or update the volume with the attributes defined in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName, it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass will be applied to the claim but it\u2019s not allowed to reset this field to empty string once it is set. If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass will be set by the persistentvolume controller if it exists. If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource exists. More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/ (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).</p>"},{"location":"CRDs/specification/#ceph.rook.io/v1.ZoneSpec","title":"ZoneSpec","text":"<p> (Appears on:ObjectStoreSpec) </p> <p>ZoneSpec represents a Ceph Object Store Gateway Zone specification</p> Field Description <code>name</code>  string  <p>RGW Zone the Object Store is in</p> <p> Generated with <code>gen-crd-api-reference-docs</code>. </p>"},{"location":"CRDs/Block-Storage/ceph-block-pool-crd/","title":"CephBlockPool CRD","text":"<p>Rook allows creation and customization of storage pools through the custom resource definitions (CRDs). The following settings are available for pools.</p>"},{"location":"CRDs/Block-Storage/ceph-block-pool-crd/#examples","title":"Examples","text":""},{"location":"CRDs/Block-Storage/ceph-block-pool-crd/#replicated","title":"Replicated","text":"<p>For optimal performance, while also adding redundancy, this sample will configure Ceph to make three full copies of the data on multiple nodes.</p> <p>Note</p> <p>This sample requires at least 1 OSD per node, with each OSD located on 3 different nodes.</p> <p>Each OSD must be located on a different node, because the <code>failureDomain</code> is set to <code>host</code> and the <code>replicated.size</code> is set to <code>3</code>.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\n  name: replicapool\n  namespace: rook-ceph\nspec:\n  failureDomain: host\n  replicated:\n    size: 3\n  deviceClass: hdd\n</code></pre>"},{"location":"CRDs/Block-Storage/ceph-block-pool-crd/#hybrid-storage-pools","title":"Hybrid Storage Pools","text":"<p>Hybrid storage is a combination of two different storage tiers. For example, SSD and HDD. This helps to improve the read performance of cluster by placing, say, 1st copy of data on the higher performance tier (SSD or NVME) and remaining replicated copies on lower cost tier (HDDs).</p> <p>WARNING Hybrid storage pools are likely to suffer from lower availability if a node goes down. The data across the two tiers may actually end up on the same node, instead of being spread across unique nodes (or failure domains) as expected. Instead of using hybrid pools, consider configuring primary affinity from the toolbox.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\n  name: replicapool\n  namespace: rook-ceph\nspec:\n  failureDomain: host\n  replicated:\n    size: 3\n    hybridStorage:\n      primaryDeviceClass: ssd\n      secondaryDeviceClass: hdd\n</code></pre> <p>Important</p> <p>The device classes <code>primaryDeviceClass</code> and <code>secondaryDeviceClass</code> must have at least one OSD associated with them or else the pool creation will fail.</p>"},{"location":"CRDs/Block-Storage/ceph-block-pool-crd/#erasure-coded","title":"Erasure Coded","text":"<p>This sample will lower the overall storage capacity requirement, while also adding redundancy by using erasure coding.</p> <p>Note</p> <p>This sample requires at least 3 bluestore OSDs.</p> <p>The OSDs can be located on a single Ceph node or spread across multiple nodes, because the <code>failureDomain</code> is set to <code>osd</code> and the <code>erasureCoded</code> chunk settings require at least 3 different OSDs (2 <code>dataChunks</code> + 1 <code>codingChunks</code>).</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\n  name: ecpool\n  namespace: rook-ceph\nspec:\n  failureDomain: osd\n  erasureCoded:\n    dataChunks: 2\n    codingChunks: 1\n  deviceClass: hdd\n</code></pre> <p>High performance applications typically will not use erasure coding due to the performance overhead of creating and distributing the chunks in the cluster.</p> <p>When creating an erasure-coded pool, it is highly recommended to create the pool when you have bluestore OSDs in your cluster (see the OSD configuration settings. Filestore OSDs have limitations that are unsafe and lower performance.</p>"},{"location":"CRDs/Block-Storage/ceph-block-pool-crd/#mirroring","title":"Mirroring","text":"<p>RADOS Block Device (RBD) mirroring is a process of asynchronous replication of Ceph block device images between two or more Ceph clusters. Mirroring ensures point-in-time consistent replicas of all changes to an image, including reads and writes, block device resizing, snapshots, clones and flattening. It is generally useful when planning for Disaster Recovery. Mirroring is for clusters that are geographically distributed and stretching a single cluster is not possible due to high latencies.</p> <p>The following will enable mirroring of the pool at the image level:</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\n  name: replicapool\n  namespace: rook-ceph\nspec:\n  replicated:\n    size: 3\n  mirroring:\n    enabled: true\n    mode: image\n    # schedule(s) of snapshot\n    snapshotSchedules:\n      - interval: 24h # daily snapshots\n        startTime: 14:00:00-05:00\n</code></pre> <p>Once mirroring is enabled, Rook will by default create its own bootstrap peer token so that it can be used by another cluster. The bootstrap peer token can be found in a Kubernetes Secret. The name of the Secret is present in the Status field of the CephBlockPool CR:</p> <pre><code>status:\n  info:\n    rbdMirrorBootstrapPeerSecretName: pool-peer-token-replicapool\n</code></pre> <p>This secret can then be fetched like so:</p> <pre><code>kubectl get secret -n rook-ceph pool-peer-token-replicapool -o jsonpath='{.data.token}'|base64 -d\neyJmc2lkIjoiOTFlYWUwZGQtMDZiMS00ZDJjLTkxZjMtMTMxMWM5ZGYzODJiIiwiY2xpZW50X2lkIjoicmJkLW1pcnJvci1wZWVyIiwia2V5IjoiQVFEN1psOWZ3V1VGRHhBQWdmY0gyZi8xeUhYeGZDUTU5L1N0NEE9PSIsIm1vbl9ob3N0IjoiW3YyOjEwLjEwMS4xOC4yMjM6MzMwMCx2MToxMC4xMDEuMTguMjIzOjY3ODldIn0=\n</code></pre> <p>The secret must be decoded. The result will be another base64 encoded blob that you will import in the destination cluster:</p> <pre><code>external-cluster-console # rbd mirror pool peer bootstrap import &lt;token file path&gt;\n</code></pre> <p>See the official rbd mirror documentation on how to add a bootstrap peer.</p> <p>Note</p> <p>Disabling mirroring for the CephBlockPool requires disabling mirroring on all the CephBlockPoolRadosNamespaces present underneath.</p>"},{"location":"CRDs/Block-Storage/ceph-block-pool-crd/#data-spread-across-subdomains","title":"Data spread across subdomains","text":"<p>Imagine the following topology with datacenters containing racks and then hosts:</p> <pre><code>.\n\u251c\u2500\u2500 datacenter-1\n\u2502   \u251c\u2500\u2500 rack-1\n\u2502   \u2502   \u251c\u2500\u2500 host-1\n\u2502   \u2502   \u251c\u2500\u2500 host-2\n\u2502   \u2514\u2500\u2500 rack-2\n\u2502       \u251c\u2500\u2500 host-3\n\u2502       \u251c\u2500\u2500 host-4\n\u2514\u2500\u2500 datacenter-2\n    \u251c\u2500\u2500 rack-3\n    \u2502   \u251c\u2500\u2500 host-5\n    \u2502   \u251c\u2500\u2500 host-6\n    \u2514\u2500\u2500 rack-4\n        \u251c\u2500\u2500 host-7\n        \u2514\u2500\u2500 host-8\n</code></pre> <p>As an administrator I would like to place 4 copies across both datacenter where each copy inside a datacenter is across a rack. This can be achieved by the following:</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\n  name: replicapool\n  namespace: rook-ceph\nspec:\n  replicated:\n    size: 4\n    replicasPerFailureDomain: 2\n    subFailureDomain: rack\n</code></pre>"},{"location":"CRDs/Block-Storage/ceph-block-pool-crd/#pool-settings","title":"Pool Settings","text":""},{"location":"CRDs/Block-Storage/ceph-block-pool-crd/#metadata","title":"Metadata","text":"<ul> <li><code>name</code>: The name of the pool to create.</li> <li><code>namespace</code>: The namespace of the Rook cluster where the pool is created.</li> </ul>"},{"location":"CRDs/Block-Storage/ceph-block-pool-crd/#spec","title":"Spec","text":"<ul> <li><code>replicated</code>: Settings for a replicated pool. If specified, <code>erasureCoded</code> settings must not be specified.<ul> <li><code>size</code>: The desired number of copies to make of the data in the pool.</li> <li><code>requireSafeReplicaSize</code>: set to false if you want to create a pool with size 1, setting pool size 1 could lead to data loss without recovery. Make sure you are ABSOLUTELY CERTAIN that is what you want.</li> <li><code>replicasPerFailureDomain</code>: Sets up the number of replicas to place in a given failure domain. For instance, if the failure domain is a datacenter (cluster is stretched) then you will have 2 replicas per datacenter where each replica ends up on a different host. This gives you a total of 4 replicas and for this, the <code>size</code> must be set to 4. The default is 1.</li> <li><code>subFailureDomain</code>: Name of the CRUSH bucket representing a sub-failure domain. In a stretched configuration this option represent the \"last\" bucket where replicas will end up being written. Imagine the cluster is stretched across two datacenters, you can then have 2 copies per datacenter and each copy on a different CRUSH bucket. The default is \"host\".</li> </ul> </li> <li><code>erasureCoded</code>: Settings for an erasure-coded pool. If specified, <code>replicated</code> settings must not be specified. See below for more details on erasure coding.<ul> <li><code>dataChunks</code>: Number of chunks to divide the original object into</li> <li><code>codingChunks</code>: Number of coding chunks to generate</li> </ul> </li> <li> <p><code>failureDomain</code>: The failure domain across which the data will be spread. This can be set to a value of either <code>osd</code> or <code>host</code>, with <code>host</code> being the default setting. A failure domain can also be set to a different type (e.g. <code>rack</code>), if the OSDs are created on nodes with the supported topology labels. If the <code>failureDomain</code> is changed on the pool, the operator will create a new CRUSH rule and update the pool.     If a <code>replicated</code> pool of size <code>3</code> is configured and the <code>failureDomain</code> is set to <code>host</code>, all three copies of the replicated data will be placed on OSDs located on <code>3</code> different Ceph hosts. This case is guaranteed to tolerate a failure of two hosts without a loss of data. Similarly, a failure domain set to <code>osd</code>, can tolerate a loss of two OSD devices.</p> <p>If erasure coding is used, the data and coding chunks are spread across the configured failure domain.</p> <p>Caution</p> <p>Neither Rook, nor Ceph, prevent the creation of a cluster where the replicated data (or Erasure Coded chunks) can be written safely. By design, Ceph will delay checking for suitable OSDs until a write request is made and this write can hang if there are not sufficient OSDs to satisfy the request.</p> <ul> <li><code>deviceClass</code>: Sets up the CRUSH rule for the pool to distribute data only on the specified device class. If left empty or unspecified, the pool will use the cluster's default CRUSH root, which usually distributes data over all OSDs, regardless of their class. If <code>deviceClass</code> is specified on any pool, ensure that it is added to every pool in the cluster, otherwise Ceph will warn about pools with overlapping roots.</li> <li><code>crushRoot</code>: The root in the crush map to be used by the pool. If left empty or unspecified, the default root will be used. Creating a crush hierarchy for the OSDs currently requires the Rook toolbox to run the Ceph tools described here.</li> <li><code>enableCrushUpdates</code>: Enables rook to update the pool crush rule using Pool Spec. Can cause data remapping if crush rule changes, Defaults to false.</li> <li><code>enableRBDStats</code>: Enables collecting RBD per-image IO statistics by enabling dynamic OSD performance counters. Defaults to false. For more info see the ceph documentation.</li> <li><code>name</code>: The name of Ceph pools is based on the <code>metadata.name</code> of the CephBlockPool CR. Some built-in Ceph pools require names that are incompatible with K8s resource names. These special pools can be configured by setting this <code>name</code> to override the name of the Ceph pool that is created instead of using the <code>metadata.name</code> for the pool. Only the following pool names are supported: <code>.nfs</code>, <code>.mgr</code>, and <code>.rgw.root</code>. See the example builtin mgr pool.</li> <li><code>application</code>: The type of application set on the pool. By default, Ceph pools for CephBlockPools will be <code>rbd</code>, CephObjectStore pools will be <code>rgw</code>, and CephFilesystem pools will be <code>cephfs</code>.</li> </ul> </li> <li> <p><code>parameters</code>: Sets any parameters listed to the given pool</p> <ul> <li><code>target_size_ratio:</code> gives a hint (%) to Ceph in terms of expected consumption of the total cluster capacity of a given pool, for more info see the ceph documentation</li> <li><code>compression_mode</code>: Sets up the pool for inline compression when using a Bluestore OSD. If left unspecified does not setup any compression mode for the pool. Values supported are the same as Bluestore inline compression modes, such as <code>none</code>, <code>passive</code>, <code>aggressive</code>, and <code>force</code>.</li> </ul> </li> <li> <p><code>mirroring</code>: Sets up mirroring of the pool</p> <ul> <li><code>enabled</code>: whether mirroring is enabled on that pool (default: false)</li> <li><code>mode</code>: mirroring mode to run, possible values are \"pool\" or \"image\" (required). Refer to the mirroring modes Ceph documentation for more details.</li> <li><code>snapshotSchedules</code>: schedule(s) snapshot at the pool level. One or more schedules are supported.<ul> <li><code>interval</code>: frequency of the snapshots. The interval can be specified in days, hours, or minutes using d, h, m suffix respectively.</li> <li><code>startTime</code>: optional, determines at what time the snapshot process starts, specified using the ISO 8601 time format.</li> </ul> </li> <li><code>peers</code>: to configure mirroring peers. See the prerequisite RBD Mirror documentation first.<ul> <li><code>secretNames</code>:  a list of peers to connect to. Currently only a single peer is supported where a peer represents a Ceph cluster.</li> </ul> </li> </ul> </li> <li> <p><code>statusCheck</code>: Sets up pool mirroring status</p> <ul> <li><code>mirror</code>: displays the mirroring status<ul> <li><code>disabled</code>: whether to enable or disable pool mirroring status</li> <li><code>interval</code>: time interval to refresh the mirroring status (default 60s)</li> </ul> </li> </ul> </li> <li> <p><code>quotas</code>: Set byte and object quotas. See the ceph documentation for more info.</p> <ul> <li><code>maxSize</code>: quota in bytes as a string with quantity suffixes (e.g. \"10Gi\")</li> <li><code>maxObjects</code>: quota in objects as an integer</li> </ul> <p>Note</p> <p>A value of 0 disables the quota.</p> </li> </ul>"},{"location":"CRDs/Block-Storage/ceph-block-pool-crd/#add-specific-pool-properties","title":"Add specific pool properties","text":"<p>With <code>poolProperties</code> you can set any pool property:</p> <pre><code>spec:\n  parameters:\n    &lt;name of the parameter&gt;: &lt;parameter value&gt;\n</code></pre> <p>For instance:</p> <pre><code>spec:\n  parameters:\n    min_size: 1\n</code></pre>"},{"location":"CRDs/Block-Storage/ceph-block-pool-crd/#erasure-coding","title":"Erasure Coding","text":"<p>Erasure coding allows you to keep your data safe while reducing the storage overhead. Instead of creating multiple replicas of the data, erasure coding divides the original data into chunks of equal size, then generates extra chunks of that same size for redundancy.</p> <p>For example, if you have an object of size 2MB, the simplest erasure coding with two data chunks would divide the object into two chunks of size 1MB each (data chunks). One more chunk (coding chunk) of size 1MB will be generated. In total, 3MB will be stored in the cluster. The object will be able to suffer the loss of any one of the chunks and still be able to reconstruct the original object.</p> <p>The number of data and coding chunks you choose will depend on your resiliency to loss and how much storage overhead is acceptable in your storage cluster. Here are some examples to illustrate how the number of chunks affects the storage and loss toleration.</p> Data chunks (k) Coding chunks (m) Total storage Losses Tolerated OSDs required 2 1 1.5x 1 3 2 2 2x 2 4 4 2 1.5x 2 6 16 4 1.25x 4 20 <p>The <code>failureDomain</code> must be also be taken into account when determining the number of chunks. The failure domain determines the level in the Ceph CRUSH hierarchy where the chunks must be uniquely distributed. This decision will impact whether node losses or disk losses are tolerated. There could also be performance differences of placing the data across nodes or osds.</p> <ul> <li><code>host</code>: All chunks will be placed on unique hosts</li> <li><code>osd</code>: All chunks will be placed on unique OSDs</li> </ul> <p>If you do not have a sufficient number of hosts or OSDs for unique placement the pool can be created, writing to the pool will hang.</p> <p>Rook currently only configures two levels in the CRUSH map. It is also possible to configure other levels such as <code>rack</code> with by adding topology labels to the nodes.</p>"},{"location":"CRDs/Block-Storage/ceph-block-pool-rados-namespace-crd/","title":"CephBlockPoolRados Namespace CRD","text":"<p>This guide assumes you have created a Rook cluster as explained in the main Quickstart guide</p> <p>RADOS currently uses pools both for data distribution (pools are shared into PGs, which map to OSDs) and as the granularity for security (capabilities can restrict access by pool).  Overloading pools for both purposes makes it hard to do multi-tenancy because it is not a good idea to have a very large number of pools.</p> <p>A namespace would be a division of a pool into separate logical namespaces. For more information about BlockPool and namespace refer to the Ceph docs</p> <p>Having multiple namespaces in a pool would allow multiple Kubernetes clusters to share one unique ceph cluster without creating a pool per kubernetes cluster and it will also allow to have tenant isolation between multiple tenants in a single Kubernetes cluster without creating multiple pools for tenants.</p> <p>Rook allows creation of Ceph BlockPool RadosNamespaces through the custom resource definitions (CRDs).</p>"},{"location":"CRDs/Block-Storage/ceph-block-pool-rados-namespace-crd/#example","title":"Example","text":"<p>To get you started, here is a simple example of a CR to create a CephBlockPoolRadosNamespace on the CephBlockPool \"replicapool\".</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPoolRadosNamespace\nmetadata:\n  name: namespace-a\n  namespace: rook-ceph # namespace:cluster\nspec:\n  # The name of the CephBlockPool CR where the namespace is created.\n  blockPoolName: replicapool\n</code></pre>"},{"location":"CRDs/Block-Storage/ceph-block-pool-rados-namespace-crd/#settings","title":"Settings","text":"<p>If any setting is unspecified, a suitable default will be used automatically.</p>"},{"location":"CRDs/Block-Storage/ceph-block-pool-rados-namespace-crd/#metadata","title":"Metadata","text":"<ul> <li><code>name</code>: The name that will be used for the Ceph BlockPool rados namespace.</li> </ul>"},{"location":"CRDs/Block-Storage/ceph-block-pool-rados-namespace-crd/#spec","title":"Spec","text":"<ul> <li> <p><code>blockPoolName</code>: The metadata name of the CephBlockPool CR where the rados namespace will be created.</p> </li> <li> <p><code>mirroring</code>: Sets up mirroring of the rados namespace (requires Ceph v20 or newer)</p> <ul> <li><code>mode</code>: mirroring mode to run, possible values are \"pool\" or \"image\" (required). Refer to the mirroring modes Ceph documentation for more details</li> <li><code>remoteNamespace</code>: Name of the rados namespace on the peer cluster where the namespace should get mirrored. The default is the same rados namespace.</li> <li><code>snapshotSchedules</code>: schedule(s) snapshot at the rados namespace level. It is an array and one or more schedules are supported.<ul> <li><code>interval</code>: frequency of the snapshots. The interval can be specified in days, hours, or minutes using d, h, m suffix respectively.</li> <li><code>startTime</code>: optional, determines at what time the snapshot process starts, specified using the ISO 8601 time format.</li> </ul> </li> </ul> </li> </ul> <p>Note</p> <p>If mirroring is enabled, whether to monitor the status and the interval of status updates is based on the <code>statusCheck</code> spec values of the parent CephBlockPool CR.</p>"},{"location":"CRDs/Block-Storage/ceph-block-pool-rados-namespace-crd/#creating-a-storage-class","title":"Creating a Storage Class","text":"<p>Once the RADOS namespace is created, an RBD-based StorageClass can be created to create PVs in this RADOS namespace. For this purpose, the <code>clusterID</code> value from the CephBlockPoolRadosNamespace status needs to be put into the <code>clusterID</code> field of the StorageClass spec.</p> <p>Extract the clusterID from the CephBlockPoolRadosNamespace CR:</p> <pre><code>$ kubectl -n rook-ceph  get cephblockpoolradosnamespace/namespace-a -o jsonpath='{.status.info.clusterID}'\n80fc4f4bacc064be641633e6ed25ba7e\n</code></pre> <p>In this example, replace <code>namespace-a</code> by the actual name of the radosnamespace created before. Now set the <code>clusterID</code> retrieved from the previous step into the <code>clusterID</code> of the storage class.</p> <p>Example:</p> <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: rook-ceph-block-rados-ns\nprovisioner: rook-ceph.rbd.csi.ceph.com # csi-provisioner-name\nparameters:\n  clusterID: 80fc4f4bacc064be641633e6ed25ba7e\n  pool: replicapool\n  ...\n</code></pre>"},{"location":"CRDs/Block-Storage/ceph-block-pool-rados-namespace-crd/#mirroring","title":"Mirroring","text":"<p>First, enable mirroring for the parent CephBlockPool.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\n  name: replicapool\n  namespace: rook-ceph\nspec:\n  replicated:\n    size: 3\n  mirroring:\n    enabled: true\n    mode: image\n    # schedule(s) of snapshot\n    snapshotSchedules:\n      - interval: 24h # daily snapshots\n        startTime: 14:00:00-05:00\n</code></pre> <p>Second, configure the rados namespace CRD with the mirroring:</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPoolRadosNamespace\nmetadata:\n  name: namespace-a\n  namespace: rook-ceph # namespace:cluster\nspec:\n  # The name of the CephBlockPool CR where the namespace is created.\n  blockPoolName: replicapool\n  mirroring:\n    mode: image\n    remoteNamespace: namespace-a # default is the same as the local rados namespace\n    # schedule(s) of snapshot\n    snapshotSchedules:\n      - interval: 24h # daily snapshots\n        startTime: 14:00:00-05:00\n</code></pre>"},{"location":"CRDs/Block-Storage/ceph-rbd-mirror-crd/","title":"CephRBDMirror CRD","text":"<p>Rook allows creation and updating rbd-mirror daemon(s) through the custom resource definitions (CRDs). RBD images can be asynchronously mirrored between two Ceph clusters. For more information about user management and capabilities see the Ceph docs.</p>"},{"location":"CRDs/Block-Storage/ceph-rbd-mirror-crd/#creating-daemons","title":"Creating daemons","text":"<p>To get you started, here is a simple example of a CRD to deploy an rbd-mirror daemon.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephRBDMirror\nmetadata:\n  name: my-rbd-mirror\n  namespace: rook-ceph\nspec:\n  count: 1\n</code></pre>"},{"location":"CRDs/Block-Storage/ceph-rbd-mirror-crd/#prerequisites","title":"Prerequisites","text":"<p>This guide assumes you have created a Rook cluster as explained in the main Quickstart guide</p>"},{"location":"CRDs/Block-Storage/ceph-rbd-mirror-crd/#settings","title":"Settings","text":"<p>If any setting is unspecified, a suitable default will be used automatically.</p>"},{"location":"CRDs/Block-Storage/ceph-rbd-mirror-crd/#rbdmirror-metadata","title":"RBDMirror metadata","text":"<ul> <li><code>name</code>: The name that will be used for the Ceph RBD Mirror daemon.</li> <li><code>namespace</code>: The Kubernetes namespace that will be created for the Rook cluster. The services, pods, and other resources created by the operator will be added to this namespace.</li> </ul>"},{"location":"CRDs/Block-Storage/ceph-rbd-mirror-crd/#rbdmirror-settings","title":"RBDMirror Settings","text":"<ul> <li><code>count</code>: The number of rbd mirror instance to run.</li> <li><code>placement</code>: The rbd mirror pods can be given standard Kubernetes placement restrictions with <code>nodeAffinity</code>, <code>tolerations</code>, <code>podAffinity</code>, and <code>podAntiAffinity</code> similar to placement defined for daemons configured by the cluster CRD..</li> <li><code>annotations</code>: Key value pair list of annotations to add.</li> <li><code>labels</code>: Key value pair list of labels to add.</li> <li><code>resources</code>: The resource requirements for the rbd mirror pods.</li> <li><code>priorityClassName</code>: The priority class to set on the rbd mirror pods.</li> </ul>"},{"location":"CRDs/Block-Storage/ceph-rbd-mirror-crd/#configuring-mirroring-peers","title":"Configuring mirroring peers","text":"<ul> <li> <p>Configure mirroring peers individually for each CephBlockPool. Refer to the CephBlockPool documentation for more detail.</p> </li> <li> <p>Configure mirroring peers individually for each CephBlockPoolRadosNamespace. Refer to the CephBlockPoolRadosNamespace documentation for more detail.</p> </li> </ul>"},{"location":"CRDs/Cluster/ceph-cluster-crd/","title":"CephCluster CRD","text":"<p>Rook allows creation and customization of storage clusters through the custom resource definitions (CRDs). There are primarily four different modes in which to create your cluster.</p> <ol> <li>Host Storage Cluster: Consume storage from host paths and raw devices</li> <li>PVC Storage Cluster: Dynamically provision storage underneath Rook by specifying the storage class Rook should use to consume storage (via PVCs)</li> <li>Stretched Storage Cluster: Distribute Ceph mons across three zones, while storage (OSDs) is only configured in two zones</li> <li>External Ceph Cluster: Connect your K8s applications to an external Ceph cluster</li> </ol> <p>See the separate topics for a description and examples of each of these scenarios.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#settings","title":"Settings","text":"<p>Settings can be specified at the global level to apply to the cluster as a whole, while other settings can be specified at more fine-grained levels.  If any setting is unspecified, a suitable default will be used automatically.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#cluster-metadata","title":"Cluster metadata","text":"<ul> <li><code>name</code>: The name that will be used internally for the Ceph cluster. Most commonly the name is the same as the namespace since multiple clusters are not supported in the same namespace.</li> <li><code>namespace</code>: The Kubernetes namespace that will be created for the Rook cluster. The services, pods, and other resources created by the operator will be added to this namespace. The common scenario is to create a single Rook cluster. If multiple clusters are created, they must not have conflicting devices or host paths.</li> </ul>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#cluster-settings","title":"Cluster Settings","text":"<ul> <li><code>external</code>:<ul> <li><code>enable</code>: if <code>true</code>, the cluster will not be managed by Rook but via an external entity. This mode is intended to connect to an existing cluster. In this case, Rook will only consume the external cluster. However, Rook will be able to deploy various daemons in Kubernetes such as object gateways, mds and nfs if an image is provided and will refuse otherwise. If this setting is enabled all the other options will be ignored except <code>cephVersion.image</code> and <code>dataDirHostPath</code>. See external cluster configuration. If <code>cephVersion.image</code> is left blank, Rook will refuse the creation of extra CRs like object, file and nfs.</li> </ul> </li> <li><code>cephVersion</code>: The version information for launching the ceph daemons.<ul> <li><code>image</code>: The image used for running the ceph daemons. For example, <code>quay.io/ceph/ceph:v18.2.4</code>. For more details read the container images section.     For the latest ceph images, see the Ceph DockerHub.     To ensure a consistent version of the image is running across all nodes in the cluster, it is recommended to use a very specific image version.     Tags also exist that would give the latest version, but they are only recommended for test environments. For example, the tag <code>v19</code> will be updated each time a new Squid build is released.     Using the general <code>v19</code> tag is not recommended in production because it may lead to inconsistent versions of the image running across different nodes in the cluster.</li> <li><code>allowUnsupported</code>: If <code>true</code>, allow an unsupported major version of the Ceph release. Currently Reef and Squid are supported. Future versions such as Tentacle (v20) would require this to be set to <code>true</code>. Should be set to <code>false</code> in production.</li> <li><code>imagePullPolicy</code>: The image pull policy for the ceph daemon pods. Possible values are <code>Always</code>, <code>IfNotPresent</code>, and <code>Never</code>. The default is <code>IfNotPresent</code>.</li> </ul> </li> <li><code>dataDirHostPath</code>: The path on the host (hostPath) where config and data should be stored for each of the services. If there are multiple clusters, the directory must be unique for each cluster. If the directory does not exist, it will be created. Because this directory persists on the host, it will remain after pods are deleted. Following paths and any of their subpaths must not be used: <code>/etc/ceph</code>, <code>/rook</code> or <code>/var/log/ceph</code>.<ul> <li>WARNING: For test scenarios, if you delete a cluster and start a new cluster on the same hosts, the path used by <code>dataDirHostPath</code> must be deleted. Otherwise, stale keys and other config will remain from the previous cluster and the new mons will fail to start. If this value is empty, each pod will get an ephemeral directory to store their config files that is tied to the lifetime of the pod running on that node. More details can be found in the Kubernetes empty dir docs.</li> </ul> </li> <li><code>skipUpgradeChecks</code>: if set to true Rook won't perform any upgrade checks on Ceph daemons during an upgrade. Use this at YOUR OWN RISK, only if you know what you're doing. To understand Rook's upgrade process of Ceph, read the upgrade doc.</li> <li><code>continueUpgradeAfterChecksEvenIfNotHealthy</code>: if set to true Rook will continue the OSD daemon upgrade process even if the PGs are not clean, or continue with the MDS upgrade even the file system is not healthy.</li> <li><code>upgradeOSDRequiresHealthyPGs</code>: if set to true OSD upgrade process won't start until PGs are healthy.</li> <li><code>dashboard</code>: Settings for the Ceph dashboard. To view the dashboard in your browser see the dashboard guide.<ul> <li><code>enabled</code>: Whether to enable the dashboard to view cluster status</li> <li><code>urlPrefix</code>: Allows to serve the dashboard under a subpath (useful when you are accessing the dashboard via a reverse proxy)</li> <li><code>port</code>: Allows to change the default port where the dashboard is served</li> <li><code>ssl</code>: Whether to serve the dashboard via SSL, ignored on Ceph versions older than <code>13.2.2</code></li> </ul> </li> <li><code>monitoring</code>: Settings for monitoring Ceph using Prometheus. To enable monitoring on your cluster see the monitoring guide.<ul> <li><code>enabled</code>: Whether to enable the prometheus service monitor for an internal cluster. For an external cluster, whether to create an endpoint port for the metrics. Default is false.</li> <li><code>metricsDisabled</code>: Whether to disable the metrics reported by Ceph. If false, the prometheus mgr module and Ceph exporter are enabled. If true, the prometheus mgr module and Ceph exporter are both disabled. Default is false.</li> <li><code>externalMgrEndpoints</code>: external cluster manager endpoints</li> <li><code>externalMgrPrometheusPort</code>: external prometheus manager module port. See external cluster configuration for more details.</li> <li><code>port</code>: The internal prometheus manager module port where the prometheus mgr module listens. The port may need to be configured when host networking is enabled.</li> <li><code>interval</code>: The interval for the prometheus module to to scrape targets.</li> <li><code>exporter</code>: Ceph exporter metrics config.<ul> <li><code>perfCountersPrioLimit</code>: Specifies which performance counters are exported. Corresponds to <code>--prio-limit</code> Ceph exporter flag. <code>0</code> - all counters are exported, default is <code>5</code>.</li> <li><code>statsPeriodSeconds</code>: Time to wait before sending requests again to exporter server (seconds). Corresponds to <code>--stats-period</code> Ceph exporter flag. Default is <code>5</code>.</li> </ul> </li> </ul> </li> <li><code>network</code>: For the network settings for the cluster, refer to the network configuration settings</li> <li><code>mon</code>: contains mon related options mon settings For more details on the mons and when to choose a number other than <code>3</code>, see the mon health doc.</li> <li><code>mgr</code>: manager top level section<ul> <li><code>count</code>: set number of ceph managers between <code>1</code> to <code>2</code>. The default value is 2.     If there are two managers, it is important for all mgr services point to the active mgr and not the standby mgr. Rook automatically     updates the label <code>mgr_role</code> on the mgr pods to be either <code>active</code> or <code>standby</code>. Therefore, services need just to add the label     <code>mgr_role=active</code> to their selector to point to the active mgr. This applies to all services that rely on the ceph mgr such as     the dashboard or the prometheus metrics collector.</li> <li><code>modules</code>: A list of Ceph manager modules to enable or disable. Note the \"dashboard\" and \"monitoring\" modules are already configured by other settings.</li> </ul> </li> <li><code>crashCollector</code>: The settings for crash collector daemon(s).<ul> <li><code>disable</code>: is set to <code>true</code>, the crash collector will not run on any node where a Ceph daemon runs</li> <li><code>daysToRetain</code>: specifies the number of days to keep crash entries in the Ceph cluster. By default the entries are kept indefinitely.</li> </ul> </li> <li><code>logCollector</code>: The settings for log collector daemon.<ul> <li><code>enabled</code>: if set to <code>true</code>, the log collector will run as a side-car next to each Ceph daemon. The Ceph configuration option <code>log_to_file</code> will be turned on, meaning Ceph daemons will log on files in addition to still logging to container's stdout. These logs will be rotated. In case a daemon terminates with a segfault, the coredump files will be commonly be generated in <code>/var/lib/systemd/coredump</code> directory on the host, depending on the underlying OS location. (default: <code>true</code>)</li> <li><code>periodicity</code>: how often to rotate daemon's log. (default: 24h). Specified with a time suffix which may be <code>h</code> for hours or <code>d</code> for days. Rotating too often will slightly impact the daemon's performance since the signal briefly interrupts the program.</li> </ul> </li> <li><code>annotations</code>: annotations configuration settings</li> <li><code>labels</code>: labels configuration settings</li> <li><code>placement</code>: placement configuration settings</li> <li><code>resources</code>: resources configuration settings</li> <li><code>priorityClassNames</code>: priority class names configuration settings</li> <li><code>storage</code>: Storage selection and configuration that will be used across the cluster.  Note that these settings can be overridden for specific nodes.<ul> <li><code>useAllNodes</code>: <code>true</code> or <code>false</code>, indicating if all nodes in the cluster should be used for storage according to the cluster level storage selection and configuration values.     If individual nodes are specified under the <code>nodes</code> field, then <code>useAllNodes</code> must be set to <code>false</code>.</li> <li><code>nodes</code>: Names of individual nodes in the cluster that should have their storage included in accordance with either the cluster level configuration specified above or any node specific overrides described in the next section below.     <code>useAllNodes</code> must be set to <code>false</code> to use specific nodes and their config.     See node settings below.</li> <li><code>config</code>: Config settings applied to all OSDs on the node unless overridden by <code>devices</code>. See the config settings below.</li> <li><code>allowDeviceClassUpdate</code>: Whether to allow changing the device class of an OSD after it is created. The default is false     to prevent unintentional data movement or CRUSH changes if the device class is changed accidentally.</li> <li><code>allowOsdCrushWeightUpdate</code>: Whether Rook will resize the OSD CRUSH weight when the OSD PVC size is increased.     This allows cluster data to be rebalanced to make most effective use of new OSD space.     The default is false since data rebalancing can cause temporary cluster slowdown.</li> <li>storage selection settings</li> <li>Storage Class Device Sets</li> <li><code>onlyApplyOSDPlacement</code>: Whether the placement specific for OSDs is merged with the <code>all</code> placement. If <code>false</code>, the OSD placement will be merged with the <code>all</code> placement. If true, the <code>OSD placement will be applied</code> and the <code>all</code> placement will be ignored. The placement for OSDs is computed from several different places depending on the type of OSD:<ul> <li>For non-PVCs: <code>placement.all</code> and <code>placement.osd</code></li> <li>For PVCs: <code>placement.all</code> and inside the storageClassDeviceSets from the <code>placement</code> or <code>preparePlacement</code></li> </ul> </li> <li><code>flappingRestartIntervalHours</code>: Defines the time for which an OSD pod will sleep before restarting, if it stopped due to flapping. Flapping occurs where OSDs are marked <code>down</code> by Ceph more than 5 times in 600 seconds. The OSDs will stay down when flapping since they likely have a bad disk or other issue that needs investigation. If the issue with the OSD is fixed manually, the OSD pod can be manually restarted. The sleep is disabled if this interval is set to 0.</li> <li><code>scheduleAlways</code>: Whether to always schedule OSD pods on nodes declared explicitly in the \"nodes\" section, even if they are     temporarily not schedulable. If set to true, consider adding placement tolerations for unschedulable nodes.</li> <li><code>fullRatio</code>: The ratio at which Ceph should block IO if the OSDs are too full. The default is 0.95.</li> <li><code>backfillFullRatio</code>: The ratio at which Ceph should stop backfilling data if the OSDs are too full. The default is 0.90.</li> <li><code>nearFullRatio</code>: The ratio at which Ceph should raise a health warning if the cluster is almost full. The default is 0.85.</li> </ul> </li> <li><code>disruptionManagement</code>: The section for configuring management of daemon disruptions<ul> <li><code>managePodBudgets</code>: if <code>true</code>, the operator will create and manage PodDisruptionBudgets for OSD, Mon, RGW, and MDS daemons. OSD PDBs are managed dynamically via the strategy outlined in the design. The operator will block eviction of OSDs by default and unblock them safely when drains are detected.</li> <li><code>osdMaintenanceTimeout</code>: is a duration in minutes that determines how long an entire failureDomain like <code>region/zone/host</code> will be held in <code>noout</code> (in addition to the default DOWN/OUT interval) when it is draining. The default value is <code>30</code> minutes.</li> <li><code>pgHealthCheckTimeout</code>: A duration in minutes that the operator will wait for the placement groups to become healthy (see <code>pgHealthyRegex</code>) after a drain was completed and OSDs came back up. Operator will continue with the next drain if the timeout exceeds. No values or <code>0</code> means that the operator will wait until the placement groups are healthy before unblocking the next drain.</li> <li><code>pgHealthyRegex</code>: The regular expression that is used to determine which PG states should be considered healthy. The default is <code>^(active\\+clean|active\\+clean\\+scrubbing|active\\+clean\\+scrubbing\\+deep)$</code>.</li> </ul> </li> <li><code>removeOSDsIfOutAndSafeToRemove</code>: If <code>true</code> the operator will remove the OSDs that are down and whose data has been restored to other OSDs. In Ceph terms, the OSDs are <code>out</code> and <code>safe-to-destroy</code> when they are removed.</li> <li><code>cleanupPolicy</code>: cleanup policy settings</li> <li><code>security</code>: security page for key management configuration</li> <li><code>cephConfig</code>: Set Ceph config options using the Ceph Mon config store</li> <li><code>csi</code>: Set CSI Driver options</li> </ul>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#ceph-container-images","title":"Ceph container images","text":"<p>Official releases of Ceph Container images are available from Docker Hub.</p> <p>These are general purpose Ceph container with all necessary daemons and dependencies installed.</p> TAG MEANING vRELNUM Latest release in this series (e.g., v19 = Squid) vRELNUM.Y Latest stable release in this stable series (e.g., v19.2) vRELNUM.Y.Z A specific release (e.g., v19.2.0) vRELNUM.Y.Z-YYYYMMDD A specific build (e.g., v19.2.0-20240927) <p>A specific will contain a specific release of Ceph as well as security fixes from the Operating System.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#mon-settings","title":"Mon Settings","text":"<ul> <li><code>count</code>: Set the number of mons to be started. The number must be between <code>1</code> and <code>9</code>. The recommended value is most commonly <code>3</code>.     For highest availability, an odd number of mons should be specified.     For higher durability in case of mon loss, an even number can be specified although availability may be lower.     To maintain quorum a majority of mons must be up. For example, if there are three mons, two must be up.     If there are four mons, three must be up. If there are two mons, both must be up.     If quorum is lost, see the disaster recovery guide to restore quorum from a single mon.</li> <li><code>allowMultiplePerNode</code>: Whether to allow the placement of multiple mons on a single node. Default is <code>false</code> for production. Should only be set to <code>true</code> in test environments.</li> <li><code>volumeClaimTemplate</code>: A <code>PersistentVolumeSpec</code> used by Rook to create PVCs     for monitor storage. This field is optional, and when not provided, HostPath     volume mounts are used.  The current set of fields from template that are used     are <code>storageClassName</code> and the <code>storage</code> resource request and limit. The     default storage size request for new PVCs is <code>10Gi</code>. Ensure that associated     storage class is configured to use <code>volumeBindingMode: WaitForFirstConsumer</code>.     This setting only applies to new monitors that are created when the requested     number of monitors increases, or when a monitor fails and is recreated. An     example CRD configuration is provided below.</li> <li><code>failureDomainLabel</code>: The label that is expected on each node where the mons     are expected to be deployed. The labels must be found in the list of     well-known topology labels.</li> <li> <p><code>zones</code>: The failure domain names where the Mons are expected to be deployed.     There must be at least three zones specified in the list. Each zone can be     backed by a different storage class by specifying the <code>volumeClaimTemplate</code>.</p> <ul> <li><code>name</code>: The name of the zone, which is the value of the domain label.</li> <li><code>volumeClaimTemplate</code>: A <code>PersistentVolumeSpec</code> used by Rook to create PVCs     for monitor storage. This field is optional, and when not provided, HostPath     volume mounts are used.  The current set of fields from template that are used     are <code>storageClassName</code> and the <code>storage</code> resource request and limit. The     default storage size request for new PVCs is <code>10Gi</code>. Ensure that associated     storage class is configured to use <code>volumeBindingMode: WaitForFirstConsumer</code>.     This setting only applies to new monitors that are created when the requested     number of monitors increases, or when a monitor fails and is recreated. An     example CRD configuration is provided below.</li> </ul> </li> <li> <p><code>stretchCluster</code>: The stretch cluster settings that define the zones (or other failure domain labels) across which to configure the cluster.</p> <ul> <li><code>failureDomainLabel</code>: The label that is expected on each node where the cluster is expected to be deployed. The labels must be found in the list of well-known topology labels.</li> <li><code>subFailureDomain</code>: With a zone, the data replicas must be spread across OSDs in the subFailureDomain. The default is <code>host</code>.</li> <li><code>zones</code>: The failure domain names where the Mons and OSDs are expected to be deployed. There must be three zones specified in the list. This element is always named <code>zone</code> even if a non-default <code>failureDomainLabel</code> is specified. The elements have two values:<ul> <li><code>name</code>: The name of the zone, which is the value of the domain label.</li> <li><code>arbiter</code>: Whether the zone is expected to be the arbiter zone which only runs a single mon. Exactly one zone must be labeled <code>true</code>.</li> <li><code>volumeClaimTemplate</code>: A <code>PersistentVolumeSpec</code> used by Rook to create PVCs     for monitor storage. This field is optional, and when not provided, HostPath     volume mounts are used.  The current set of fields from template that are used     are <code>storageClassName</code> and the <code>storage</code> resource request and limit. The     default storage size request for new PVCs is <code>10Gi</code>. Ensure that associated     storage class is configured to use <code>volumeBindingMode: WaitForFirstConsumer</code>.     This setting only applies to new monitors that are created when the requested     number of monitors increases, or when a monitor fails and is recreated. An     example CRD configuration is provided below. The two zones that are not the arbiter zone are expected to have OSDs deployed.</li> </ul> </li> </ul> </li> </ul> <p>If these settings are changed in the CRD the operator will update the number of mons during a periodic check of the mon health, which by default is every 45 seconds.</p> <p>To change the defaults that the operator uses to determine the mon health and whether to failover a mon, refer to the health settings. The intervals should be small enough that you have confidence the mons will maintain quorum, while also being long enough to ignore network blips where mons are failed over too often.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#mgr-settings","title":"Mgr Settings","text":"<p>You can use the cluster CR to enable or disable any manager module. This can be configured like so:</p> <pre><code>mgr:\n  modules:\n  - name: &lt;name of the module&gt;\n    enabled: true\n</code></pre> <p>Some modules will have special configuration to ensure the module is fully functional after being enabled. Specifically:</p> <ul> <li><code>pg_autoscaler</code>: Rook will configure all new pools with PG autoscaling by setting: <code>osd_pool_default_pg_autoscale_mode = on</code></li> </ul>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#network-configuration-settings","title":"Network Configuration Settings","text":"<p>If not specified, the default SDN will be used. Configure the network that will be enabled for the cluster and services.</p> <ul> <li><code>provider</code>: Specifies the network provider that will be used to connect the network interface. You can choose between <code>host</code>, and <code>multus</code>.</li> <li><code>selectors</code>: Used for <code>multus</code> provider only. Select NetworkAttachmentDefinitions to use for Ceph networks.<ul> <li><code>public</code>: Select the NetworkAttachmentDefinition to use for the public network.</li> <li><code>cluster</code>: Select the NetworkAttachmentDefinition to use for the cluster network.</li> </ul> </li> <li><code>addressRanges</code>: Used for <code>host</code> or <code>multus</code> providers only. Allows overriding the address ranges (CIDRs) that Ceph will listen on.<ul> <li><code>public</code>: A list of individual network ranges in CIDR format to use for Ceph's public network.</li> <li><code>cluster</code>: A list of individual network ranges in CIDR format to use for Ceph's cluster network.</li> </ul> </li> <li><code>ipFamily</code>: Specifies the network stack Ceph daemons should listen on.</li> <li><code>dualStack</code>: Specifies that Ceph daemon should listen on both IPv4 and IPv6 network stacks.</li> <li><code>connections</code>: Settings for network connections using Ceph's msgr2 protocol<ul> <li><code>requireMsgr2</code>: Whether to require communication over msgr2. If true, the msgr v1 port (6789) will be disabled     and clients will be required to connect to the Ceph cluster with the v2 port (3300).     Requires a kernel that supports msgr2 (kernel 5.11 or CentOS 8.4 or newer). Default is false.</li> <li><code>encryption</code>: Settings for encryption on the wire to Ceph daemons<ul> <li><code>enabled</code>: Whether to encrypt the data in transit across the wire to prevent eavesdropping the data on the network.     The default is false. When encryption is enabled, all communication between clients and Ceph daemons, or between     Ceph daemons will be encrypted. When encryption is not enabled, clients still establish a strong initial authentication     and data integrity is still validated with a crc check.     IMPORTANT: Encryption requires the 5.11 kernel for the latest nbd and cephfs drivers. Alternatively for testing only,     set \"mounter: rbd-nbd\" in the rbd storage class, or \"mounter: fuse\" in the cephfs storage class.     The nbd and fuse drivers are not recommended in production since restarting the csi driver pod will disconnect the volumes.     If this setting is enabled, CephFS volumes also require setting <code>CSI_CEPHFS_KERNEL_MOUNT_OPTIONS</code> to <code>\"ms_mode=secure\"</code> in operator.yaml.</li> </ul> </li> <li><code>compression</code>:<ul> <li><code>enabled</code>: Whether to compress the data in transit across the wire. The default is false.     See the kernel requirements above for encryption.</li> </ul> </li> </ul> </li> </ul> <p>Caution</p> <p>Changing networking configuration after a Ceph cluster has been deployed is only supported for the network encryption settings. Changing other network settings is NOT supported and will likely result in a non-functioning cluster.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#provider","title":"Provider","text":"<p>Selecting a non-default network provider is an advanced topic. Read more in the Network Providers documentation.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#ipfamily","title":"IPFamily","text":"<p>Provide single-stack IPv4 or IPv6 protocol to assign corresponding addresses to pods and services. This field is optional. Possible inputs are IPv6 and IPv4. Empty value will be treated as IPv4. To enable dual stack see the network configuration section.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#node-settings","title":"Node Settings","text":"<p>In addition to the cluster level settings specified above, each individual node can also specify configuration to override the cluster level settings and defaults. If a node does not specify any configuration then it will inherit the cluster level settings.</p> <ul> <li><code>name</code>: The name of the node, which should match its <code>kubernetes.io/hostname</code> label.</li> <li><code>config</code>: Config settings applied to all OSDs on the node unless overridden by <code>devices</code>. See the config settings below.</li> <li>storage selection settings</li> </ul> <p>When <code>useAllNodes</code> is set to <code>true</code>, Rook attempts to make Ceph cluster management as hands-off as possible while still maintaining reasonable data safety. If a usable node comes online, Rook will begin to use it automatically. To maintain a balance between hands-off usability and data safety, Nodes are removed from Ceph as OSD hosts only (1) if the node is deleted from Kubernetes itself or (2) if the node has its taints or affinities modified in such a way that the node is no longer usable by Rook. Any changes to taints or affinities, intentional or unintentional, may affect the data reliability of the Ceph cluster. In order to help protect against this somewhat, deletion of nodes by taint or affinity modifications must be \"confirmed\" by deleting the Rook Ceph operator pod and allowing the operator deployment to restart the pod.</p> <p>For production clusters, we recommend that <code>useAllNodes</code> is set to <code>false</code> to prevent the Ceph cluster from suffering reduced data reliability unintentionally due to a user mistake. When <code>useAllNodes</code> is set to <code>false</code>, Rook relies on the user to be explicit about when nodes are added to or removed from the Ceph cluster. Nodes are only added to the Ceph cluster if the node is added to the Ceph cluster resource. Similarly, nodes are only removed if the node is removed from the Ceph cluster resource.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#node-updates","title":"Node Updates","text":"<p>Nodes can be added and removed over time by updating the Cluster CRD, for example with <code>kubectl -n rook-ceph edit cephcluster rook-ceph</code>. This will bring up your default text editor and allow you to add and remove storage nodes from the cluster. This feature is only available when <code>useAllNodes</code> has been set to <code>false</code>.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#storage-selection-settings","title":"Storage Selection Settings","text":"<p>Below are the settings for host-based cluster. This type of cluster can specify devices for OSDs, both at the cluster and individual node level, for selecting which storage resources will be included in the cluster.</p> <ul> <li><code>useAllDevices</code>: <code>true</code> or <code>false</code>, indicating whether all devices found on nodes in the cluster should be automatically consumed by OSDs. Not recommended unless you have a very controlled environment where you will not risk formatting of devices with existing data. When <code>true</code>, all devices and partitions will be used. Is overridden by <code>deviceFilter</code> if specified. LVM logical volumes are not picked by <code>useAllDevices</code>.</li> <li><code>deviceFilter</code>: A regular expression for short kernel names of devices (e.g. <code>sda</code>) that allows selection of devices and partitions to be consumed by OSDs.  LVM logical volumes are not picked by <code>deviceFilter</code>.If individual devices have been specified for a node then this filter will be ignored.  This field uses golang regular expression syntax. For example:<ul> <li><code>sdb</code>: Only selects the <code>sdb</code> device if found</li> <li><code>^sd.</code>: Selects all devices starting with <code>sd</code></li> <li><code>^sd[a-d]</code>: Selects devices starting with <code>sda</code>, <code>sdb</code>, <code>sdc</code>, and <code>sdd</code> if found</li> <li><code>^s</code>: Selects all devices that start with <code>s</code></li> <li><code>^[^r]</code>: Selects all devices that do not start with <code>r</code></li> </ul> </li> <li><code>devicePathFilter</code>: A regular expression for device paths (e.g. <code>/dev/disk/by-path/pci-0:1:2:3-scsi-1</code>) that allows selection of devices and partitions to be consumed by OSDs.  LVM logical volumes are not picked by <code>devicePathFilter</code>.If individual devices or <code>deviceFilter</code> have been specified for a node then this filter will be ignored.  This field uses golang regular expression syntax. For example:<ul> <li><code>^/dev/sd.</code>: Selects all devices starting with <code>sd</code></li> <li><code>^/dev/disk/by-path/pci-.*</code>: Selects all devices which are connected to PCI bus</li> </ul> </li> <li><code>devices</code>: A list of individual device names belonging to this node to include in the storage cluster.<ul> <li><code>name</code>: The name of the devices and partitions (e.g., <code>sda</code>). The full udev path can also be specified for devices, partitions, and logical volumes (e.g. <code>/dev/disk/by-id/ata-ST4000DM004-XXXX</code> - this will not change after reboots).</li> <li><code>config</code>: Device-specific config settings. See the config settings below</li> </ul> </li> </ul> <p>Host-based cluster supports raw devices, partitions, logical volumes, encrypted devices, and multipath devices. Be sure to see the quickstart doc prerequisites for additional considerations.</p> <p>Below are the settings for a PVC-based cluster.</p> <ul> <li><code>storageClassDeviceSets</code>: Explained in Storage Class Device Sets</li> </ul>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#storage-class-device-sets","title":"Storage Class Device Sets","text":"<p>The following are the settings for Storage Class Device Sets which can be configured to create OSDs that are backed by block mode PVs.</p> <ul> <li><code>name</code>: A name for the set.</li> <li><code>count</code>: The number of devices in the set.</li> <li><code>resources</code>: The CPU and RAM requests/limits for the devices. (Optional)</li> <li> <p><code>placement</code>: The placement criteria for the devices. (Optional) Default is no placement criteria.</p> <p>The syntax is the same as for other placement configuration. It supports <code>nodeAffinity</code>, <code>podAffinity</code>, <code>podAntiAffinity</code> and <code>tolerations</code> keys.</p> <p>It is recommended to configure the placement such that the OSDs will be as evenly spread across nodes as possible. At a minimum, anti-affinity should be added so at least one OSD will be placed on each available nodes.</p> <p>However, if there are more OSDs than nodes, this anti-affinity will not be effective. Another placement scheme to consider is to add labels to the nodes in such a way that the OSDs can be grouped on those nodes, create multiple storageClassDeviceSets, and add node affinity to each of the device sets that will place the OSDs in those sets of nodes.</p> <p>Rook will automatically add required nodeAffinity to the OSD daemons to match the topology labels that are found on the nodes where the OSD prepare jobs ran. To ensure data durability, the OSDs are required to run in the same topology that the Ceph CRUSH map expects. For example, if the nodes are labeled with rack topology labels, the OSDs will be constrained to a certain rack. Without the topology labels, Rook will not constrain the OSDs beyond what is required by the PVs, for example to run in the zone where provisioned. See the OSD Topology section for the related labels.</p> </li> <li> <p><code>preparePlacement</code>: The placement criteria for the preparation of the OSD devices. Creating OSDs is a two-step process and the prepare job may require different placement than the OSD daemons. If the <code>preparePlacement</code> is not specified, the <code>placement</code> will instead be applied for consistent placement for the OSD prepare jobs and OSD deployments. The <code>preparePlacement</code> is only useful for <code>portable</code> OSDs in the device sets. OSDs that are not portable will be tied to the host where the OSD prepare job initially runs.</p> <ul> <li>For example, provisioning may require topology spread constraints across zones, but the OSD daemons may require constraints across hosts within the zones.</li> </ul> </li> <li><code>portable</code>: If <code>true</code>, the OSDs will be allowed to move between nodes during failover. This requires a storage class that supports portability (e.g. <code>aws-ebs</code>, but not the local storage provisioner). If <code>false</code>, the OSDs will be assigned to a node permanently. Rook will configure Ceph's CRUSH map to support the portability.</li> <li><code>tuneDeviceClass</code>: For example, Ceph cannot detect AWS volumes as HDDs from the storage class \"gp2-csi\", so you can improve Ceph performance by setting this to true.</li> <li><code>tuneFastDeviceClass</code>: For example, Ceph cannot detect Azure disks as SSDs from the storage class \"managed-premium\", so you can improve Ceph performance by setting this to true..</li> <li><code>volumeClaimTemplates</code>: A list of PVC templates to use for provisioning the underlying storage devices.<ul> <li><code>metadata.name</code>: \"data\", \"metadata\", or \"wal\". If a single template is provided, the name must be \"data\". If the name is \"metadata\" or \"wal\", the devices are used to store the Ceph metadata or WAL respectively. In both cases, the devices must be raw devices or LVM logical volumes.<ul> <li><code>resources.requests.storage</code>: The desired capacity for the underlying storage devices.</li> <li><code>storageClassName</code>: The StorageClass to provision PVCs from. Default would be to use the cluster-default StorageClass.</li> <li><code>volumeMode</code>: The volume mode to be set for the PVC. Which should be Block</li> <li><code>accessModes</code>: The access mode for the PVC to be bound by OSD.</li> </ul> </li> </ul> </li> <li><code>schedulerName</code>: Scheduler name for OSD pod placement. (Optional)</li> <li><code>encrypted</code>: whether to encrypt all the OSDs in a given storageClassDeviceSet</li> </ul> <p>See the table in OSD Configuration Settings to know the allowed configurations.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#osd-configuration-settings","title":"OSD Configuration Settings","text":"<p>The following storage selection settings are specific to Ceph and do not apply to other backends. All variables are key-value pairs represented as strings.</p> <ul> <li><code>metadataDevice</code>: Name of a device, partition or lvm to use for the metadata of OSDs on each node.  Performance can be improved by using a low latency device (such as SSD or NVMe) as the metadata device, while other spinning platter (HDD) devices on a node are used to store data. Provisioning will fail if the user specifies a <code>metadataDevice</code> but that device is not used as a metadata device by Ceph. Notably, <code>ceph-volume</code> will not use a device of the same device class (HDD, SSD, NVMe) as OSD devices for metadata, resulting in this failure.</li> <li><code>databaseSizeMB</code>:  The size in MB of a bluestore database. Include quotes around the size.</li> <li><code>walSizeMB</code>:  The size in MB of a bluestore write ahead log (WAL). Include quotes around the size.</li> <li><code>deviceClass</code>: The CRUSH device class to use for this selection of storage devices. (By default, if a device's class has not already been set, OSDs will automatically set a device's class to either <code>hdd</code>, <code>ssd</code>, or <code>nvme</code>  based on the hardware properties exposed by the Linux kernel.) These storage classes can then be used to select the devices backing a storage pool by specifying them as the value of the pool spec's <code>deviceClass</code> field. If updating the device class of an OSD after the OSD is already created, <code>allowDeviceClassUpdate: true</code> must be set. Otherwise updates to this <code>deviceClass</code> will be ignored.</li> <li><code>initialWeight</code>: The initial OSD weight in TiB units. By default, this value is derived from OSD's capacity.</li> <li><code>primaryAffinity</code>: The primary-affinity value of an OSD, within range <code>[0, 1]</code> (default: <code>1</code>).</li> <li><code>osdsPerDevice</code>**: The number of OSDs to create on each device. High performance devices such as NVMe can handle running multiple OSDs. If desired, this can be overridden for each node and each device.</li> <li><code>encryptedDevice</code>**: Encrypt OSD volumes using dmcrypt (\"true\" or \"false\"). By default this option is disabled. See encryption for more information on encryption in Ceph. (Resizing is not supported for host-based clusters.)</li> <li><code>crushRoot</code>: The value of the <code>root</code> CRUSH map label. The default is <code>default</code>. Generally, you should not need to change this. However, if any of your topology labels may have the value <code>default</code>, you need to change <code>crushRoot</code> to avoid conflicts, since CRUSH map values need to be unique.</li> <li><code>enableCrushUpdates</code>: Enables rook to update the pool crush rule using Pool Spec. Can cause data remapping if crush rule changes, Defaults to false.</li> <li><code>migration</code>: Existing PVC based OSDs can be migrated to enable or disable encryption. Refer to the osd management topic for details.</li> </ul> <p>Allowed configurations are:</p> block device type host-based cluster PVC-based cluster disk part <code>encryptedDevice</code> must be <code>false</code> <code>encrypted</code> must be <code>false</code> lvm <code>metadataDevice</code> must be <code>\"\"</code>, <code>osdsPerDevice</code> must be <code>1</code>, and <code>encryptedDevice</code> must be <code>false</code> <code>metadata.name</code> must not be <code>metadata</code> or <code>wal</code> and <code>encrypted</code> must be <code>false</code> crypt mpath"},{"location":"CRDs/Cluster/ceph-cluster-crd/#limitations-of-metadata-device","title":"Limitations of metadata device","text":"<ul> <li>If <code>metadataDevice</code> is specified in the global OSD configuration or in the node level OSD configuration, the metadata device will be shared between all OSDs on the same node. In other words, OSDs will be initialized by <code>lvm batch</code>. In this case, we can't use partition device.</li> <li>If <code>metadataDevice</code> is specified in the device local configuration, we can use partition as metadata device. In other words, OSDs are initialized by <code>lvm prepare</code>.</li> </ul>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#annotations-and-labels","title":"Annotations and Labels","text":"<p>Annotations and Labels can be specified so that the Rook components will have those annotations / labels added to them.</p> <p>You can set annotations / labels for Rook components for the list of key value pairs:</p> <ul> <li><code>all</code>: Set annotations / labels for all components except <code>clusterMetadata</code>.</li> <li><code>mgr</code>: Set annotations / labels for MGRs</li> <li><code>mon</code>: Set annotations / labels for mons</li> <li><code>osd</code>: Set annotations / labels for OSDs</li> <li><code>dashboard</code>: Set annotations / labels for the dashboard service</li> <li><code>prepareosd</code>: Set annotations / labels for OSD Prepare Jobs</li> <li><code>monitoring</code>: Set annotations / labels for service monitor</li> <li><code>crashcollector</code>: Set annotations / labels for crash collectors</li> <li><code>clusterMetadata</code>: Set annotations  only to <code>rook-ceph-mon-endpoints</code> configmap and the  <code>rook-ceph-mon</code> and <code>rook-ceph-admin-keyring</code> secrets. These annotations will not be merged with the <code>all</code> annotations. The common usage is for backing up these critical resources with <code>kubed</code>. Note the clusterMetadata annotation will not be merged with the <code>all</code> annotation. When other keys are set, <code>all</code> will be merged together with the specific component.</li> </ul>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#placement-configuration-settings","title":"Placement Configuration Settings","text":"<p>Placement configuration for the cluster services. It includes the following keys: <code>mgr</code>, <code>mon</code>, <code>arbiter</code>, <code>osd</code>, <code>prepareosd</code>, <code>cleanup</code>, and <code>all</code>. Each service will have its placement configuration generated by merging the generic configuration under <code>all</code> with the most specific one (which will override any attributes).</p> <p>In stretch clusters, if the <code>arbiter</code> placement is specified, that placement will only be applied to the arbiter. Neither will the <code>arbiter</code> placement be merged with the <code>all</code> placement to allow the arbiter to be fully independent of other daemon placement. The remaining mons will still use the <code>mon</code> and/or <code>all</code> sections.</p> <p>Note</p> <p>Placement of OSD pods is controlled using the Storage Class Device Set, not the general <code>placement</code> configuration.</p> <p>A Placement configuration is specified (according to the kubernetes PodSpec) as:</p> <ul> <li><code>nodeAffinity</code>: kubernetes NodeAffinity</li> <li><code>podAffinity</code>: kubernetes PodAffinity</li> <li><code>podAntiAffinity</code>: kubernetes PodAntiAffinity</li> <li><code>tolerations</code>: list of kubernetes Toleration</li> <li><code>topologySpreadConstraints</code>: kubernetes TopologySpreadConstraints</li> </ul> <p>If you use <code>labelSelector</code> for <code>osd</code> pods, you must write two rules both for <code>rook-ceph-osd</code> and <code>rook-ceph-osd-prepare</code> like the example configuration. It comes from the design that there are these two pods for an OSD. For more detail, see the osd design doc and the related issue.</p> <p>The Rook Ceph operator creates a Job called <code>rook-ceph-detect-version</code> to detect the full Ceph version used by the given <code>cephVersion.image</code>. The placement from the <code>mon</code> section is used for the Job except for the <code>PodAntiAffinity</code> field.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#placement-example","title":"Placement Example","text":"<p>To control where various services will be scheduled by kubernetes, use the placement configuration sections below. The example under 'all' would have all services scheduled on kubernetes nodes labeled with 'role=storage-node<code>. Specific node affinity and tolerations that only apply to the</code>mon<code>daemons in this example require the label</code>role=storage-mon-node` and also tolerate the control plane taint.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephCluster\nmetadata:\n  name: rook-ceph\n  namespace: rook-ceph\nspec:\n  cephVersion:\n    image: quay.io/ceph/ceph:v18.2.4\n  dataDirHostPath: /var/lib/rook\n  mon:\n    count: 3\n    allowMultiplePerNode: false\n  # enable the ceph dashboard for viewing cluster status\n  dashboard:\n    enabled: true\n  placement:\n    all:\n      nodeAffinity:\n        requiredDuringSchedulingIgnoredDuringExecution:\n          nodeSelectorTerms:\n          - matchExpressions:\n            - key: role\n              operator: In\n              values:\n              - storage-node\n    mon:\n      nodeAffinity:\n        requiredDuringSchedulingIgnoredDuringExecution:\n          nodeSelectorTerms:\n          - matchExpressions:\n            - key: role\n              operator: In\n              values:\n              - storage-mon-node\n      tolerations:\n      - effect: NoSchedule\n        key: node-role.kubernetes.io/control-plane\n        operator: Exists\n</code></pre>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#cluster-wide-resources-configuration-settings","title":"Cluster-wide Resources Configuration Settings","text":"<p>Resources should be specified so that the Rook components are handled after Kubernetes Pod Quality of Service classes. This allows to keep Rook components running when for example a node runs out of memory and the Rook components are not killed depending on their Quality of Service class.</p> <p>You can set resource requests/limits for Rook components through the Resource Requirements/Limits structure in the following keys:</p> <ul> <li><code>mon</code>: Set resource requests/limits for mons</li> <li><code>osd</code>: Set resource requests/limits for OSDs.     This key applies for all OSDs regardless of their device classes.     In case of need to apply resource requests/limits for OSDs with particular device class use specific osd keys below.     If the memory resource is declared Rook will automatically set the OSD configuration <code>osd_memory_target</code> to the same value.     This aims to ensure that the actual OSD memory consumption is consistent with the OSD pods' resource declaration.</li> <li><code>osd-&lt;deviceClass&gt;</code>: Set resource requests/limits for OSDs on a specific device class.     Rook will automatically detect <code>hdd</code>, <code>ssd</code>, or <code>nvme</code> device classes. Custom device classes can also be set.</li> <li><code>mgr</code>: Set resource requests/limits for MGRs</li> <li><code>mgr-sidecar</code>: Set resource requests/limits for the MGR sidecar, which is only created when <code>mgr.count: 2</code>.     The sidecar requires very few resources since it only executes every 15 seconds to query Ceph for the active     mgr and update the mgr services if the active mgr changed.</li> <li><code>prepareosd</code>: Set resource requests/limits for OSD prepare job</li> <li><code>crashcollector</code>: Set resource requests/limits for crash. This pod runs wherever there is a Ceph pod running. It scrapes for Ceph daemon core dumps and sends them to the Ceph manager crash module so that core dumps are centralized and can be easily listed/accessed. You can read more about the Ceph Crash module.</li> <li><code>logcollector</code>: Set resource requests/limits for the log collector. When enabled, this container runs as side-car to each Ceph daemons.</li> <li><code>cmd-reporter</code>: Set resource requests/limits for the jobs that detect the ceph version and collect network info.</li> <li><code>cleanup</code>: Set resource requests/limits for cleanup job, responsible for wiping cluster's data after uninstall</li> <li><code>exporter</code>: Set resource requests/limits for Ceph exporter.</li> </ul> <p>In order to provide the best possible experience running Ceph in containers, Rook internally recommends minimum memory limits if resource limits are passed. If a user configures a limit or request value that is too low, Rook will still run the pod(s) and print a warning to the operator log.</p> <ul> <li><code>mon</code>: 1024MB</li> <li><code>mgr</code>: 512MB</li> <li><code>osd</code>: 2048MB</li> <li><code>crashcollector</code>: 60MB</li> <li><code>mgr-sidecar</code>: 100MB limit, 40MB requests</li> <li><code>prepareosd</code>: no limits (see the note)</li> <li><code>exporter</code>: 128MB limit, 50MB requests</li> </ul> <p>Note</p> <p>We recommend not setting memory limits on the OSD prepare job to prevent OSD provisioning failure due to memory constraints. The OSD prepare job bursts memory usage during the OSD provisioning depending on the size of the device, typically 1-2Gi for large disks. The OSD prepare job only bursts a single time per OSD. All future runs of the OSD prepare job will detect the OSD is already provisioned and skip the provisioning.</p> <p>Hint</p> <p>The resources for MDS daemons are not configured in the Cluster. Refer to the Ceph Filesystem CRD instead.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#resource-requirementslimits","title":"Resource Requirements/Limits","text":"<p>For more information on resource requests/limits see the official Kubernetes documentation: Kubernetes - Managing Compute Resources for Containers</p> <ul> <li><code>requests</code>: Requests for cpu or memory.<ul> <li><code>cpu</code>: Request for CPU (example: one CPU core <code>1</code>, 50% of one CPU core <code>500m</code>).</li> <li><code>memory</code>: Limit for Memory (example: one gigabyte of memory <code>1Gi</code>, half a gigabyte of memory <code>512Mi</code>).</li> </ul> </li> <li><code>limits</code>: Limits for cpu or memory.<ul> <li><code>cpu</code>: Limit for CPU (example: one CPU core <code>1</code>, 50% of one CPU core <code>500m</code>).</li> <li><code>memory</code>: Limit for Memory (example: one gigabyte of memory <code>1Gi</code>, half a gigabyte of memory <code>512Mi</code>).</li> </ul> </li> </ul> <p>Warning</p> <p>Before setting resource requests/limits, please take a look at the Ceph documentation for recommendations for each component: Ceph - Hardware Recommendations.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#node-specific-resources-for-osds","title":"Node Specific Resources for OSDs","text":"<p>This example shows that you can override these requests/limits for OSDs per node when using <code>useAllNodes: false</code> in the <code>node</code> item in the <code>nodes</code> list.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephCluster\nmetadata:\n  name: rook-ceph\n  namespace: rook-ceph\nspec:\n  cephVersion:\n    image: quay.io/ceph/ceph:v18.2.4\n  dataDirHostPath: /var/lib/rook\n  mon:\n    count: 3\n    allowMultiplePerNode: false\n  storage:\n    useAllNodes: false\n    nodes:\n    - name: \"172.17.4.201\"\n      resources:\n        limits:\n          memory: \"4096Mi\"\n        requests:\n          cpu: \"2\"\n          memory: \"4096Mi\"\n</code></pre>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#priority-class-names","title":"Priority Class Names","text":"<p>Priority class names can be specified so that the Rook components will have those priority class names added to them.</p> <p>You can set priority class names for Rook components for the list of key value pairs:</p> <ul> <li><code>all</code>: Set priority class names for MGRs, Mons, OSDs, and crashcollectors.</li> <li><code>mgr</code>: Set priority class names for MGRs. Examples default to system-cluster-critical.</li> <li><code>mon</code>: Set priority class names for Mons. Examples default to system-node-critical.</li> <li><code>osd</code>: Set priority class names for OSDs. Examples default to system-node-critical.</li> <li><code>crashcollector</code>: Set priority class names for crashcollectors.</li> <li><code>exporter</code>: Set priority class names for exporters.</li> <li><code>cleanup</code>: Set priority class names for cleanup Jobs.</li> </ul> <p>The specific component keys will act as overrides to <code>all</code>.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#health-settings","title":"Health settings","text":"<p>The Rook Ceph operator will monitor the state of the CephCluster on various components by default. The following CRD settings are available:</p> <ul> <li><code>healthCheck</code>: main ceph cluster health monitoring section</li> </ul> <p>Currently three health checks are implemented:</p> <ul> <li><code>mon</code>: health check on the ceph monitors, basically check whether monitors are members of the quorum. If after a certain timeout a given monitor has not joined the quorum back it will be failed over and replace by a new monitor.</li> <li><code>osd</code>: health check on the ceph osds</li> <li><code>status</code>: ceph health status check, periodically check the Ceph health state and reflects it in the CephCluster CR status field.</li> </ul> <p>The liveness probe and startup probe of each daemon can also be controlled via <code>livenessProbe</code> and <code>startupProbe</code> respectively. The settings are valid for <code>mon</code>, <code>mgr</code> and <code>osd</code>. Here is a complete example for both <code>daemonHealth</code>, <code>livenessProbe</code>, and <code>startupProbe</code>:</p> <pre><code>healthCheck:\n  daemonHealth:\n    mon:\n      disabled: false\n      interval: 45s\n      timeout: 600s\n    osd:\n      disabled: false\n      interval: 60s\n    status:\n      disabled: false\n  livenessProbe:\n    mon:\n      disabled: false\n    mgr:\n      disabled: false\n    osd:\n      disabled: false\n  startupProbe:\n    mon:\n      disabled: false\n    mgr:\n      disabled: false\n    osd:\n      disabled: false\n</code></pre> <p>The probe's timing values and thresholds (but not the probe itself) can also be overridden. For more info, refer to the Kubernetes documentation.</p> <p>For example, you could change the <code>mgr</code> probe by applying:</p> <pre><code>healthCheck:\n  startupProbe:\n    mgr:\n      disabled: false\n      probe:\n        initialDelaySeconds: 3\n        periodSeconds: 3\n        failureThreshold: 30\n  livenessProbe:\n    mgr:\n      disabled: false\n      probe:\n        initialDelaySeconds: 3\n        periodSeconds: 3\n</code></pre> <p>Changing the liveness probe is an advanced operation and should rarely be necessary. If you want to change these settings then modify the desired settings.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#status","title":"Status","text":"<p>The operator is regularly configuring and checking the health of the cluster. The results of the configuration and health checks can be seen in the <code>status</code> section of the CephCluster CR.</p> <pre><code>kubectl -n rook-ceph get CephCluster -o yaml\n</code></pre> <pre><code>[...]\n  status:\n    ceph:\n      health: HEALTH_OK\n      lastChecked: \"2021-03-02T21:22:11Z\"\n      capacity:\n        bytesAvailable: 22530293760\n        bytesTotal: 25757220864\n        bytesUsed: 3226927104\n        lastUpdated: \"2021-03-02T21:22:11Z\"\n    message: Cluster created successfully\n    phase: Ready\n    state: Created\n    storage:\n      deviceClasses:\n      - name: hdd\n    version:\n      image: quay.io/ceph/ceph:v18.2.4\n      version: 16.2.6-0\n    conditions:\n    - lastHeartbeatTime: \"2021-03-02T21:22:11Z\"\n      lastTransitionTime: \"2021-03-02T21:21:09Z\"\n      message: Cluster created successfully\n      reason: ClusterCreated\n      status: \"True\"\n      type: Ready\n</code></pre>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#ceph-status","title":"Ceph Status","text":"<p>Ceph is constantly monitoring the health of the data plane and reporting back if there are any warnings or errors. If everything is healthy from Ceph's perspective, you will see <code>HEALTH_OK</code>.</p> <p>If Ceph reports any warnings or errors, the details will be printed to the status. If further troubleshooting is needed to resolve these issues, the toolbox will likely be needed where you can run <code>ceph</code> commands to find more details.</p> <p>The <code>capacity</code> of the cluster is reported, including bytes available, total, and used. The available space will be less that you may expect due to overhead in the OSDs.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#conditions","title":"Conditions","text":"<p>The <code>conditions</code> represent the status of the Rook operator.</p> <ul> <li>If the cluster is fully configured and the operator is stable, the     <code>Ready</code> condition is raised with <code>ClusterCreated</code> reason and no other conditions. The cluster     will remain in the <code>Ready</code> condition after the first successful configuration since it     is expected the storage is consumable from this point on. If there are issues preventing     the storage layer from working, they are expected to show as Ceph health errors.</li> <li>If the cluster is externally connected successfully, the <code>Ready</code> condition will have the reason <code>ClusterConnected</code>.</li> <li>If the operator is currently being configured or the operator is checking for update,     there will be a <code>Progressing</code> condition.</li> <li>If there was a failure, the condition(s) status will be <code>false</code> and the <code>message</code> will     give a summary of the error. See the operator log for more details.</li> </ul>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#other-status","title":"Other Status","text":"<p>There are several other properties for the overall status including:</p> <ul> <li><code>message</code>, <code>phase</code>, and <code>state</code>: A summary of the overall current state of the cluster, which     is somewhat duplicated from the conditions for backward compatibility.</li> <li><code>storage.deviceClasses</code>: The names of the types of storage devices that Ceph discovered     in the cluster. These types will be <code>ssd</code> or <code>hdd</code> unless they have been overridden     with the <code>crushDeviceClass</code> in the <code>storageClassDeviceSets</code>.</li> <li><code>version</code>: The version of the Ceph image currently deployed.</li> </ul>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#osd-topology","title":"OSD Topology","text":"<p>The topology of the cluster is important in production environments where you want your data spread across failure domains. The topology can be controlled by adding labels to the nodes. When the labels are found on a node at first OSD deployment, Rook will add them to the desired level in the CRUSH map.</p> <p>The complete list of labels in hierarchy order from highest to lowest is:</p> <pre><code>topology.kubernetes.io/region\ntopology.kubernetes.io/zone\ntopology.rook.io/datacenter\ntopology.rook.io/room\ntopology.rook.io/pod\ntopology.rook.io/pdu\ntopology.rook.io/row\ntopology.rook.io/rack\ntopology.rook.io/chassis\n</code></pre> <p>For example, if the following labels were added to a node:</p> <pre><code>kubectl label node mynode topology.kubernetes.io/zone=zone1\nkubectl label node mynode topology.rook.io/rack=zone1-rack1\n</code></pre> <p>These labels would result in the following hierarchy for OSDs on that node (this command can be run in the Rook toolbox):</p> <pre><code>$ ceph osd tree\nID CLASS WEIGHT  TYPE NAME                 STATUS REWEIGHT PRI-AFF\n-1       0.01358 root default\n-5       0.01358     zone zone1\n-4       0.01358         rack rack1\n-3       0.01358             host mynode\n0   hdd 0.00679                 osd.0         up  1.00000 1.00000\n1   hdd 0.00679                 osd.1         up  1.00000 1.00000\n</code></pre> <p>Ceph requires unique names at every level in the hierarchy (CRUSH map). For example, you cannot have two racks with the same name that are in different zones. Racks in different zones must be named uniquely.</p> <p>Note that the <code>host</code> is added automatically to the hierarchy by Rook. The host cannot be specified with a topology label. All topology labels are optional.</p> <p>Hint</p> <p>When setting the node labels prior to <code>CephCluster</code> creation, these settings take immediate effect. However, applying this to an already deployed <code>CephCluster</code> requires removing each node from the cluster first and then re-adding it with new configuration to take effect. Do this node by node to keep your data safe! Check the result with <code>ceph osd tree</code> from the Rook Toolbox. The OSD tree should display the hierarchy for the nodes that already have been re-added.</p> <p>To utilize the <code>failureDomain</code> based on the node labels, specify the corresponding option in the CephBlockPool</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\n  name: replicapool\n  namespace: rook-ceph\nspec:\n  failureDomain: rack  # this matches the topology labels on nodes\n  replicated:\n    size: 3\n</code></pre> <p>This configuration will split the replication of volumes across unique racks in the data center setup.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#deleting-a-cephcluster","title":"Deleting a CephCluster","text":"<p>During deletion of a CephCluster resource, Rook protects against accidental or premature destruction of user data by blocking deletion if there are any other Rook Ceph Custom Resources that reference the CephCluster being deleted. Rook will warn about which other resources are blocking deletion in three ways until all blocking resources are deleted:</p> <ol> <li>An event will be registered on the CephCluster resource</li> <li>A status condition will be added to the CephCluster resource</li> <li>An error will be added to the Rook Ceph operator log</li> </ol>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#cleanup-policy","title":"Cleanup policy","text":"<p>Rook has the ability to cleanup resources and data that were deployed when a CephCluster is removed. The policy settings indicate which data should be forcibly deleted and in what way the data should be wiped. The <code>cleanupPolicy</code> has several fields:</p> <ul> <li><code>confirmation</code>: Only an empty string and <code>yes-really-destroy-data</code> are valid values for this field.     If this setting is empty, the <code>cleanupPolicy</code> settings will be ignored and Rook will not cleanup any resources during cluster removal.     To reinstall the cluster, the admin would then be required to follow the cleanup guide to delete the data on hosts.     If this setting is <code>yes-really-destroy-data</code>, the operator will automatically delete the data on hosts.     Because this cleanup policy is destructive, after the confirmation is set to <code>yes-really-destroy-data</code>     Rook will stop configuring the cluster as if the cluster is about to be destroyed.</li> <li><code>sanitizeDisks</code>: sanitizeDisks represents advanced settings that can be used to delete data on drives.<ul> <li><code>method</code>: indicates if the entire disk should be sanitized or simply ceph's metadata. Possible choices are <code>quick</code> (default) or <code>complete</code></li> <li><code>dataSource</code>: indicate where to get random bytes from to write on the disk. Possible choices are <code>zero</code> (default) or <code>random</code>.     Using random sources will consume entropy from the system and will take much more time then the zero source</li> <li><code>iteration</code>: overwrite N times instead of the default (1). Takes an integer value</li> </ul> </li> <li><code>allowUninstallWithVolumes</code>: If set to true, then the cephCluster deletion doesn't wait for the PVCs to be deleted. Default is <code>false</code>.</li> </ul> <p>To automate activation of the cleanup, you can use the following command. WARNING: DATA WILL BE PERMANENTLY DELETED:</p> <pre><code>kubectl -n rook-ceph patch cephcluster rook-ceph --type merge -p '{\"spec\":{\"cleanupPolicy\":{\"confirmation\":\"yes-really-destroy-data\"}}}'\n</code></pre> <p>Nothing will happen until the deletion of the CR is requested, so this can still be reverted. However, all new configuration by the operator will be blocked with this cleanup policy enabled.</p> <p>Rook waits for the deletion of PVs provisioned using the cephCluster before proceeding to delete the cephCluster. To force deletion of the cephCluster without waiting for the PVs to be deleted, you can set the <code>allowUninstallWithVolumes</code> to true under <code>spec.CleanupPolicy</code>.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#ceph-config","title":"Ceph Config","text":"<p>The Ceph config options are applied after the MONs are all in quorum and running. To set Ceph config options, you can add them to your <code>CephCluster</code> spec as shown below. See the Ceph config reference for detailed information about how to configure Ceph.</p> <pre><code>spec:\n  # [...]\n  cephConfig:\n    # Who's the target for these config options?\n    global:\n      # All values must be quoted so they are considered a string in YAML\n      osd_pool_default_size: \"3\"\n      mon_warn_on_pool_no_redundancy: \"false\"\n      osd_crush_update_on_start: \"false\"\n    # Make sure to quote special characters\n    \"osd.*\":\n      osd_max_scrubs: \"10\"\n</code></pre> <p>The Rook operator will actively apply these values, whereas the ceph.conf settings only take effect after the Ceph daemon pods are restarted.</p> <p>If both these <code>cephConfig</code> and ceph.conf settings are applied, the <code>cephConfig</code> settings will take higher precedence if there is an overlap.</p> <p>If Ceph settings need to be applied to mons before quorum is initially created, the ceph.conf settings should be used instead.</p> <p>Warning</p> <p>Rook performs no direct validation on these config options, so the validity of the settings is the user's responsibility.</p> <p>The operator does not unset any removed config options, it is the user's responsibility to unset or set the default value for each removed option manually using the Ceph CLI.</p>"},{"location":"CRDs/Cluster/ceph-cluster-crd/#csi-driver-options","title":"CSI Driver Options","text":"<p>The CSI driver options mentioned here are applied per Ceph cluster. The following options are available:</p> <ul> <li><code>readAffinity</code>: RBD and CephFS volumes allow serving reads from an OSD in proximity to the client. Refer to the read affinity section in the Ceph CSI Drivers for more details.<ul> <li><code>enabled</code>: Whether to enable read affinity for the CSI driver. Default is <code>false</code>.</li> <li><code>crushLocationLabels</code>:  Node labels to use as CRUSH location, corresponding to the values set in the CRUSH map. Defaults to the labels mentioned in the OSD topology topic.</li> </ul> </li> <li><code>cephfs</code>:<ul> <li><code>kernelMountOptions</code>: Mount options for kernel mounter. Refer to the kernel mount options for more details.</li> <li><code>fuseMountOptions</code>: Mount options for fuse mounter. Refer to the fuse mount options for more details.</li> </ul> </li> </ul>"},{"location":"CRDs/Cluster/host-cluster/","title":"Host Storage Cluster","text":"<p>A host storage cluster is one where Rook configures Ceph to store data directly on the host. The Ceph mons will store the metadata on the host (at a path defined by the <code>dataDirHostPath</code>), and the OSDs will consume raw devices or partitions.</p> <p>The Ceph persistent data is stored directly on a host path (Ceph Mons) and on raw devices (Ceph OSDs).</p> <p>To get you started, here are several example of the Cluster CR to configure the host.</p>"},{"location":"CRDs/Cluster/host-cluster/#all-devices","title":"All Devices","text":"<p>For the simplest possible configuration, this example shows that all devices or partitions should be consumed by Ceph. The mons will store the metadata on the host node under <code>/var/lib/rook</code>.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephCluster\nmetadata:\n  name: rook-ceph\n  namespace: rook-ceph\nspec:\n  cephVersion:\n    # see the \"Cluster Settings\" section below for more details on which image of ceph to run\n    image: quay.io/ceph/ceph:v18.2.4\n  dataDirHostPath: /var/lib/rook\n  mon:\n    count: 3\n    allowMultiplePerNode: false\n  storage:\n    useAllNodes: true\n    useAllDevices: true\n</code></pre>"},{"location":"CRDs/Cluster/host-cluster/#node-and-device-filters","title":"Node and Device Filters","text":"<p>More commonly, you will want to be more specific about which nodes and devices where Rook should configure the storage. The placement settings are very flexible to add node affinity, anti-affinity, or tolerations. For more options, see the placement documentation.</p> <p>In this example, Rook will only configure Ceph daemons to run on nodes that are labeled with <code>role=rook-node</code>, and more specifically the OSDs will only be created on nodes labeled with <code>role=rook-osd-node</code>.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephCluster\nmetadata:\n  name: rook-ceph\n  namespace: rook-ceph\nspec:\n  cephVersion:\n    image: quay.io/ceph/ceph:v18.2.4\n  dataDirHostPath: /var/lib/rook\n  mon:\n    count: 3\n    allowMultiplePerNode: false\n  dashboard:\n    enabled: true\n  # cluster level storage configuration and selection\n  storage:\n    useAllNodes: true\n    useAllDevices: true\n    # Only create OSDs on devices that match the regular expression filter, \"sdb\" in this example\n    deviceFilter: sdb\n  # To control where various services will be scheduled by kubernetes, use the placement configuration sections below.\n  # The example under 'all' would have all services scheduled on kubernetes nodes labeled with 'role=rook-node' and\n  # the OSDs would specifically only be created on nodes labeled with 'role=rook-osd-node'.\n  placement:\n    all:\n      nodeAffinity:\n        requiredDuringSchedulingIgnoredDuringExecution:\n          nodeSelectorTerms:\n          - matchExpressions:\n            - key: role\n              operator: In\n              values:\n              - rook-node\n    osd:\n      nodeAffinity:\n        requiredDuringSchedulingIgnoredDuringExecution:\n          nodeSelectorTerms:\n          - matchExpressions:\n            - key: role\n              operator: In\n              values:\n              - rook-osd-node\n</code></pre>"},{"location":"CRDs/Cluster/host-cluster/#specific-nodes-and-devices","title":"Specific Nodes and Devices","text":"<p>If you need fine-grained control for every node and every device that is being configured, individual nodes and their config can be specified. In this example, we see that specific node names and devices can be specified.</p> <p>Hint</p> <p>Each node's 'name' field should match their 'kubernetes.io/hostname' label.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephCluster\nmetadata:\n  name: rook-ceph\n  namespace: rook-ceph\nspec:\n  cephVersion:\n    image: quay.io/ceph/ceph:v18.2.4\n  dataDirHostPath: /var/lib/rook\n  mon:\n    count: 3\n    allowMultiplePerNode: false\n  dashboard:\n    enabled: true\n  # cluster level storage configuration and selection\n  storage:\n    useAllNodes: false\n    useAllDevices: false\n    deviceFilter:\n    config:\n      metadataDevice:\n      databaseSizeMB: \"1024\" # this value can be removed for environments with normal sized disks (100 GB or larger)\n    nodes:\n    - name: \"172.17.4.201\"\n      devices:             # specific devices to use for storage can be specified for each node\n      - name: \"sdb\" # Whole storage device\n      - name: \"sdc1\" # One specific partition. Should not have a file system on it.\n      - name: \"/dev/disk/by-id/ata-ST4000DM004-XXXX\" # both device name and explicit udev links are supported\n      config:         # configuration can be specified at the node level which overrides the cluster level config\n    - name: \"172.17.4.301\"\n      deviceFilter: \"^sd.\"\n</code></pre>"},{"location":"CRDs/Cluster/network-providers/","title":"Network Providers","text":"<p>Rook deploys CephClusters using Kubernetes' software-defined networks by default. This is simple for users, provides necessary connectivity, and has good node-level security. However, this comes at the expense of additional latency, and the storage network must contend with Kubernetes applications for network bandwidth. It also means that Kubernetes applications coexist on the same network as Ceph daemons and can reach the Ceph cluster easily via network scanning.</p> <p>Rook allows selecting alternative network providers to address some of these downsides, sometimes at the expense of others. Selecting alternative network providers is an advanced topic.</p> <p>Note</p> <p>This is an advanced networking topic. See also the CephCluster general networking settings.</p>"},{"location":"CRDs/Cluster/network-providers/#ceph-networking-fundamentals","title":"Ceph Networking Fundamentals","text":"<p>Ceph daemons can operate on up to two distinct networks: public, and cluster.</p> <p>Ceph daemons always use the public network. The public network is used for client communications with the Ceph cluster (reads/writes). Rook configures this as the Kubernetes pod network by default. Ceph-CSI uses this network for PVCs.</p> <p>The cluster network is optional and is used to isolate internal Ceph replication traffic. This includes additional copies of data replicated between OSDs during client reads/writes. This also includes OSD data recovery (re-replication) when OSDs or nodes go offline. If the cluster network is unspecified, the public network is used for this traffic instead.</p> <p>Refer to Ceph networking documentation for deeper explanations of any topics.</p>"},{"location":"CRDs/Cluster/network-providers/#specifying-ceph-network-selections","title":"Specifying Ceph Network Selections","text":"<p><code>network.addressRanges</code></p> <p>This configuration is always optional but is important to understand.</p> <p>Some Rook network providers allow specifying the public and network interfaces that Ceph will use for data traffic. Use <code>addressRanges</code> to specify this. For example:</p> <pre><code>  network:\n    provider: host\n    addressRanges:\n      public:\n        - \"192.168.100.0/24\"\n        - \"192.168.101.0/24\"\n      cluster:\n        - \"192.168.200.0/24\"\n</code></pre> <p>This <code>public</code> and <code>cluster</code> translate directly to Ceph's <code>public_network</code> and <code>host_network</code> configurations.</p> <p>The default network provider cannot make use of these configurations.</p> <p>Ceph public and cluster network configurations are allowed to change, but this should be done with great care. When updating underlying networks or Ceph network settings, Rook assumes that the current network configuration used by Ceph daemons will continue to operate as intended. Network changes are not applied to Ceph daemon pods (like OSDs and MDSes) until the pod is restarted. When making network changes, ensure that restarted pods will not lose connectivity to existing pods, and vice versa.</p>"},{"location":"CRDs/Cluster/network-providers/#host-networking","title":"Host Networking","text":"<p><code>network.provider: host</code></p> <p>Host networking allows the Ceph cluster to use network interfaces on Kubernetes hosts for communication. This eliminates latency from the software-defined pod network, but it provides no host-level security isolation.</p> <p>Ceph daemons will use any network available on the host for communication. To restrict Ceph to using only a specific specific host interfaces or networks, use <code>addressRanges</code> to select the network CIDRs Ceph will bind to on the host.</p> <p>If the Ceph mons are expected to bind to a public network that is different from the IP address assign to the K8s node where the mon is running, the IP address for the mon can be set by adding an annotation to the node:</p> <pre><code>network.rook.io/mon-ip: &lt;IPAddress&gt;\n</code></pre> <p>If the host networking setting is changed in a cluster where mons are already running, the existing mons will remain running with the same network settings with which they were created. To complete the conversion to or from host networking after you update this setting, you will need to failover the mons in order to have mons on the desired network configuration.</p>"},{"location":"CRDs/Cluster/network-providers/#multus","title":"Multus","text":"<p><code>network.provider: multus</code></p> <p>Rook supports using Multus NetworkAttachmentDefinitions for Ceph public and cluster networks.</p> <p>This allows Rook to attach any CNI to Ceph as a public and/or cluster network. This provides strong isolation between Kubernetes applications and Ceph cluster daemons.</p> <p>While any CNI may be used, the intent is to allow use of CNIs which allow Ceph to be connected to specific host interfaces. This improves latency and bandwidth while preserving host-level network isolation.</p>"},{"location":"CRDs/Cluster/network-providers/#multus-prerequisites","title":"Multus Prerequisites","text":"<p>In order for host network-enabled Ceph-CSI to communicate with a Multus-enabled CephCluster, some setup is required for Kubernetes hosts.</p> <p>These prerequisites require an understanding of how Multus networks are configured and how Rook uses them. Following sections will help clarify questions that may arise here.</p> <p>Two basic requirements must be met:</p> <ol> <li>Kubernetes hosts must be able to route successfully to the Multus public network.</li> <li>Pods on the Multus public network must be able to route successfully to Kubernetes hosts.</li> </ol> <p>These two requirements can be broken down further as follows:</p> <ol> <li>For routing Kubernetes hosts to the Multus public network, each host must ensure the following:<ol> <li>the host must have an interface connected to the Multus public network (the \"public-network-interface\").</li> <li>the \"public-network-interface\" must have an IP address.</li> <li>a route must exist to direct traffic destined for pods on the Multus public network through     the \"public-network-interface\".</li> </ol> </li> <li>For routing pods on the Multus public network to Kubernetes hosts, the public     NetworkAttachementDefinition must be configured to ensure the following:<ol> <li>The definition must have its IP Address Management (IPAM) configured to route traffic destined     for nodes through the network.</li> </ol> </li> <li>To ensure routing between the two networks works properly, no IP address assigned to a node can     overlap with any IP address assigned to a pod on the Multus public network.</li> </ol> <p>These requirements require careful planning, but some methods are able to meet these requirements more easily than others. Examples are provided after the full document to help understand and implement these requirements.</p> <p>Tip</p> <p>Keep in mind that there are often ten or more Rook/Ceph pods per host. The pod address space may need to be an order of magnitude larger (or more) than the host address space to allow the storage cluster to grow in the future.</p>"},{"location":"CRDs/Cluster/network-providers/#multus-configuration","title":"Multus Configuration","text":"<p>Refer to Multus documentation for details about how to set up and select Multus networks.</p> <p>Rook will attempt to auto-discover the network CIDRs for selected public and/or cluster networks. This process is not guaranteed to succeed. Furthermore, this process will get a new network lease for each CephCluster reconcile. Specify <code>addressRanges</code> manually if the auto-detection process fails or if the selected network configuration cannot automatically recycle released network leases.</p> <p>Only OSD pods will have both public and cluster networks attached (if specified). The rest of the Ceph component pods and CSI pods will only have the public network attached. The Rook operator will not have any networks attached; it proxies Ceph commands via a sidecar container in the mgr pod.</p> <p>A NetworkAttachmentDefinition must exist before it can be used by Multus for a Ceph network. A recommended definition will look like the following:</p> <pre><code>apiVersion: \"k8s.cni.cncf.io/v1\"\nkind: NetworkAttachmentDefinition\nmetadata:\n  name: ceph-multus-net\nspec:\n  config: '{\n      \"cniVersion\": \"0.3.1\",\n      \"type\": \"macvlan\",\n      \"master\": \"eth0\",\n      \"mode\": \"bridge\",\n      \"ipam\": {\n        \"type\": \"whereabouts\",\n        \"range\": \"192.168.200.0/24\"\n      }\n    }'\n</code></pre> <ul> <li>Note that the example above does not specify information that would route pods on the network to     Kubernetes hosts.</li> <li>Ensure that <code>master</code> matches the network interface on hosts that you want to use.     It must be the same across all hosts.</li> <li>CNI type macvlan is highly recommended.     It has less CPU and memory overhead compared to traditional Linux <code>bridge</code> configurations.</li> <li>IPAM type whereabouts is recommended     because it ensures each pod gets an IP address unique within the Kubernetes cluster. No DHCP     server is required. If a DHCP server is present on the network, ensure the IP range does not     overlap with the DHCP server's range.</li> </ul> <p>NetworkAttachmentDefinitions are selected for the desired Ceph network using <code>selectors</code>. Selector values should include the namespace in which the NAD is present. <code>public</code> and <code>cluster</code> may be selected independently. If <code>public</code> is left unspecified, Rook will configure Ceph to use the Kubernetes pod network for Ceph client traffic.</p> <p>Consider the example below which selects a hypothetical Kubernetes-wide Multus network in the default namespace for Ceph's public network and selects a Ceph-specific network in the <code>rook-ceph</code> namespace for Ceph's cluster network. The commented-out portion shows an example of how address ranges could be manually specified for the networks if needed.</p> <pre><code>  network:\n    provider: multus\n    selectors:\n      public: default/kube-multus-net\n      cluster: rook-ceph/ceph-multus-net\n    # addressRanges:\n    #   public:\n    #     - \"192.168.100.0/24\"\n    #     - \"192.168.101.0/24\"\n    #   cluster:\n    #     - \"192.168.200.0/24\"\n</code></pre>"},{"location":"CRDs/Cluster/network-providers/#validating-multus-configuration","title":"Validating Multus configuration","text":"<p>We highly recommend validating your Multus configuration before you install a CephCluster. A tool exists to facilitate validating the Multus configuration. After installing the Rook operator and before installing any Custom Resources, run the tool from the operator pod.</p> <p>The tool's CLI is designed to be as helpful as possible. Get help text for the multus validation tool like so:</p> <ol> <li> <p>Exec into the Rook operator pod</p> <pre><code>kubectl --namespace rook-ceph exec -it deploy/rook-ceph-operator -- bash\n</code></pre> </li> <li> <p>Output and read the tool's help text</p> <pre><code>rook multus validation run --help\n</code></pre> </li> <li> <p>Use the validation tool config file for advanced configuration.</p> <pre><code>rook multus validation config --help\n</code></pre> <p>Generate a sample config, that includes commented help text, using one of the available templates.</p> </li> <li> <p>Run the tool after configuring. If the tool fails, it will suggest what things may be preventing     Multus networks from working properly, and it will request the logs and outputs that will help     debug issues.</p> </li> </ol> <p>Note</p> <p>The tool requires host network access. Many Kubernetes distros have security limitations. Use the tool's <code>serviceAccountName</code> config option or <code>--service-account-name</code> CLI flag to instruct the tool to run using a particular ServiceAccount in order to allow necessary permissions. An example compatible with openshift is provided in the Rook repository at deploy/examples/multus-validation-test-openshift.yaml</p>"},{"location":"CRDs/Cluster/network-providers/#known-limitations-with-multus","title":"Known limitations with Multus","text":"<p>Daemons leveraging Kubernetes service IPs (Monitors, Managers, Rados Gateways) are not listening on the NAD specified in the <code>selectors</code>. Instead the daemon listens on the default network, however the NAD is attached to the container, allowing the daemon to communicate with the rest of the cluster. There is work in progress to fix this issue in the multus-service repository. At the time of writing it's unclear when this will be supported.</p>"},{"location":"CRDs/Cluster/network-providers/#multus-examples","title":"Multus examples","text":""},{"location":"CRDs/Cluster/network-providers/#macvlan-whereabouts-node-dynamic-ips","title":"Macvlan, Whereabouts, Node Dynamic IPs","text":"<p>The network plan for this cluster will be as follows:</p> <ul> <li>The underlying network supporting the public network will be attached to hosts at <code>eth0</code></li> <li>Macvlan will be used to attach pods to <code>eth0</code></li> <li>Pods and nodes will have separate IP ranges</li> <li>Nodes will get the IP range 192.168.252.0/22 (this allows up to 1024 hosts)</li> <li>Nodes will have IPs assigned dynamically via DHCP     (DHCP configuration is outside the scope of this document)</li> <li>Pods will get the IP range 192.168.0.0/18 (this allows up to 16,384 Rook/Ceph pods)</li> <li>Whereabouts will be used to assign IPs to the Multus public network</li> </ul> <p>Node configuration must allow nodes to route to pods on the Multus public network.</p> <p>Because pods will be connecting via Macvlan, and because Macvlan does not allow hosts and pods to route between each other, the host must also be connected via Macvlan.</p> <p>Because the host IP range is different from the pod IP range, a route must be added to include the pod range.</p> <p>Such a configuration should be equivalent to the following:</p> <pre><code>ip link add public-shim link eth0 type macvlan mode bridge\nip link set public-shim up\ndhclient public-shim # gets IP in range 192.168.252.0/22\nip route add 192.168.0.0/18 dev public-shim\n</code></pre> <p>The NetworkAttachmentDefinition for the public network would look like the following, using Whereabouts' <code>exclude</code> option to simplify the <code>range</code> request.</p> <p>The Whereabouts <code>routes[].dst</code> option (is not well documented) but allows adding routing pods to hosts via the Multus public network.</p> <pre><code>apiVersion: \"k8s.cni.cncf.io/v1\"\nkind: NetworkAttachmentDefinition\nmetadata:\n  name: public-net\n  # namespace: rook-ceph # (optional) operator namespace\nspec:\n  config: '{\n      \"cniVersion\": \"0.3.1\",\n      \"type\": \"macvlan\",\n      \"master\": \"eth0\",\n      \"mode\": \"bridge\",\n      \"ipam\": {\n        \"type\": \"whereabouts\",\n        \"range\": \"1192.168.0.0/18\",\n        \"routes\": [\n          {\"dst\": \"192.168.252.0/22\"}\n        ]\n      }\n    }'\n</code></pre>"},{"location":"CRDs/Cluster/network-providers/#macvlan-whereabouts-node-static-ips","title":"Macvlan, Whereabouts, Node Static IPs","text":"<p>The network plan for this cluster will be as follows:</p> <ul> <li>The underlying network supporting the public network will be attached to hosts at <code>eth0</code></li> <li>Macvlan will be used to attach pods to <code>eth0</code></li> <li>Pods and nodes will share the IP range 192.168.0.0/16</li> <li>Nodes will get the IP range 192.168.252.0/22 (this allows up to 1024 hosts)</li> <li>Pods will get the remainder of the ranges (192.168.0.1 to 192.168.251.255)</li> <li>Whereabouts will be used to assign IPs to the Multus public network</li> <li>Nodes will have IPs assigned statically via PXE configs     (PXE configuration and static IP management is outside the scope of this document)</li> </ul> <p>PXE configuration for the nodes must apply a configuration to nodes to allow nodes to route to pods on the Multus public network.</p> <p>Because pods will be connecting via Macvlan, and because Macvlan does not allow hosts and pods to route between each other, the host must also be connected via Macvlan.</p> <p>Because the host IP range is a subset of the whole range, a route must be added to include the whole range.</p> <p>Such a configuration should be equivalent to the following:</p> <pre><code>ip link add public-shim link eth0 type macvlan mode bridge\nip addr add 192.168.252.${STATIC_IP}/22 dev public-shim\nip link set public-shim up\nip route add 192.168.0.0/16 dev public-shim\n</code></pre> <p>The NetworkAttachmentDefinition for the public network would look like the following, using Whereabouts' <code>exclude</code> option to simplify the <code>range</code> request. The Whereabouts <code>routes[].dst</code> option ensures pods route to hosts via the Multus public network.</p> <pre><code>apiVersion: \"k8s.cni.cncf.io/v1\"\nkind: NetworkAttachmentDefinition\nmetadata:\n  name: public-net\nspec:\n  config: '{\n      \"cniVersion\": \"0.3.1\",\n      \"type\": \"macvlan\",\n      \"master\": \"eth0\",\n      \"mode\": \"bridge\",\n      \"ipam\": {\n        \"type\": \"whereabouts\",\n        \"range\": \"192.168.0.0/16\",\n        \"exclude\": [\n           \"192.168.252.0/22\"\n        ],\n        \"routes\": [\n          {\"dst\": \"192.168.252.0/22\"}\n        ]\n      }\n    }'\n</code></pre>"},{"location":"CRDs/Cluster/network-providers/#macvlan-dhcp","title":"Macvlan, DHCP","text":"<p>The network plan for this cluster will be as follows:</p> <ul> <li>The underlying network supporting the public network will be attached to hosts at <code>eth0</code></li> <li>Macvlan will be used to attach pods to <code>eth0</code></li> <li>Pods and nodes will share the IP range 192.168.0.0/16</li> <li>DHCP will be used to ensure nodes and pods get unique IP addresses</li> </ul> <p>Node configuration must allow nodes to route to pods on the Multus public network.</p> <p>Because pods will be connecting via Macvlan, and because Macvlan does not allow hosts and pods to route between each other, the host must also be connected via Macvlan.</p> <p>Such a configuration should be equivalent to the following:</p> <pre><code>ip link add public-shim link eth0 type macvlan mode bridge\nip link set public-shim up\ndhclient public-shim # gets IP in range 192.168.0.0/16\n</code></pre> <p>The NetworkAttachmentDefinition for the public network would look like the following.</p> <pre><code>apiVersion: \"k8s.cni.cncf.io/v1\"\nkind: NetworkAttachmentDefinition\nmetadata:\n  name: public-net\nspec:\n  config: '{\n      \"cniVersion\": \"0.3.1\",\n      \"type\": \"macvlan\",\n      \"master\": \"eth0\",\n      \"mode\": \"bridge\",\n      \"ipam\": {\n        \"type\": \"dhcp\",\n      }\n    }'\n</code></pre>"},{"location":"CRDs/Cluster/pvc-cluster/","title":"PVC Storage Cluster","text":"<p>In a \"PVC-based cluster\", the Ceph persistent data is stored on volumes requested from a storage class of your choice. This type of cluster is recommended in a cloud environment where volumes can be dynamically created and also in clusters where a local PV provisioner is available.</p>"},{"location":"CRDs/Cluster/pvc-cluster/#aws-storage-example","title":"AWS Storage Example","text":"<p>In this example, the mon and OSD volumes are provisioned from the AWS <code>gp2-csi</code> storage class. This storage class can be replaced by any storage class that provides <code>file</code> mode (for mons) and <code>block</code> mode (for OSDs).</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephCluster\nmetadata:\n  name: rook-ceph\n  namespace: rook-ceph\nspec:\n  cephVersion:\n    image: quay.io/ceph/ceph:v18.2.4\n  dataDirHostPath: /var/lib/rook\n  mon:\n    count: 3\n    allowMultiplePerNode: false\n    volumeClaimTemplate:\n      spec:\n        storageClassName: gp2-csi\n        resources:\n          requests:\n            storage: 10Gi\n  storage:\n    storageClassDeviceSets:\n    - name: set1\n      count: 3\n      portable: false\n      encrypted: false\n      volumeClaimTemplates:\n      - metadata:\n          name: data\n        spec:\n          resources:\n            requests:\n              storage: 10Gi\n          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2-csi)\n          storageClassName: gp2-csi\n          volumeMode: Block\n          accessModes:\n            - ReadWriteOnce\n    onlyApplyOSDPlacement: false\n</code></pre>"},{"location":"CRDs/Cluster/pvc-cluster/#local-storage-example","title":"Local Storage Example","text":"<p>In the CRD specification below, 3 OSDs (having specific placement and resource values) and 3 mons with each using a 10Gi PVC, are created by Rook using the <code>local-storage</code> storage class.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephCluster\nmetadata:\n  name: rook-ceph\n  namespace: rook-ceph\nspec:\n  dataDirHostPath: /var/lib/rook\n  mon:\n    count: 3\n    allowMultiplePerNode: false\n    volumeClaimTemplate:\n      spec:\n        storageClassName: local-storage\n        resources:\n          requests:\n            storage: 10Gi\n  cephVersion:\n    image: quay.io/ceph/ceph:v18.2.4\n    allowUnsupported: false\n  dashboard:\n    enabled: true\n  network:\n    hostNetwork: false\n  storage:\n    storageClassDeviceSets:\n    - name: set1\n      count: 3\n      portable: false\n      resources:\n        limits:\n          memory: \"4Gi\"\n        requests:\n          cpu: \"500m\"\n          memory: \"4Gi\"\n      placement:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n          - weight: 100\n            podAffinityTerm:\n              labelSelector:\n                matchExpressions:\n                - key: \"rook.io/cluster\"\n                  operator: In\n                  values:\n                    - cluster1\n              topologyKey: \"topology.kubernetes.io/zone\"\n      volumeClaimTemplates:\n      - metadata:\n          name: data\n        spec:\n          resources:\n            requests:\n              storage: 10Gi\n          storageClassName: local-storage\n          volumeMode: Block\n          accessModes:\n            - ReadWriteOnce\n</code></pre>"},{"location":"CRDs/Cluster/pvc-cluster/#pvc-storage-only-for-monitors","title":"PVC storage only for monitors","text":"<p>In the CRD specification below three monitors are created each using a 10Gi PVC created by Rook using the <code>local-storage</code> storage class. Even while the mons consume PVCs, the OSDs in this example will still consume raw devices on the host.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephCluster\nmetadata:\n  name: rook-ceph\n  namespace: rook-ceph\nspec:\n  cephVersion:\n    image: quay.io/ceph/ceph:v18.2.4\n  dataDirHostPath: /var/lib/rook\n  mon:\n    count: 3\n    allowMultiplePerNode: false\n    volumeClaimTemplate:\n      spec:\n        storageClassName: local-storage\n        resources:\n          requests:\n            storage: 10Gi\n  dashboard:\n    enabled: true\n  storage:\n    useAllNodes: true\n    useAllDevices: true\n</code></pre>"},{"location":"CRDs/Cluster/pvc-cluster/#dedicated-metadata-and-wal-device-for-osd-on-pvc","title":"Dedicated metadata and wal device for OSD on PVC","text":"<p>In the simplest case, Ceph OSD BlueStore consumes a single (primary) storage device. BlueStore is the engine used by the OSD to store data.</p> <p>The storage device is normally used as a whole, occupying the full device that is managed directly by BlueStore. It is also possible to deploy BlueStore across additional devices such as a DB device. This device can be used for storing BlueStore\u2019s internal metadata. BlueStore (or rather, the embedded RocksDB) will put as much metadata as it can on the DB device to improve performance. If the DB device fills up, metadata will spill back onto the primary device (where it would have been otherwise). Again, it is only helpful to provision a DB device if it is faster than the primary device.</p> <p>You can have multiple <code>volumeClaimTemplates</code> where each might either represent a device or a metadata device. An example of the <code>storage</code> section when specifying the metadata device is:</p> <pre><code>  storage:\n   storageClassDeviceSets:\n    - name: set1\n      count: 3\n      portable: false\n      volumeClaimTemplates:\n      - metadata:\n          name: data\n        spec:\n          resources:\n            requests:\n              storage: 10Gi\n          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)\n          storageClassName: gp2\n          volumeMode: Block\n          accessModes:\n            - ReadWriteOnce\n      - metadata:\n          name: metadata\n        spec:\n          resources:\n            requests:\n              # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing\n              storage: 5Gi\n          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)\n          storageClassName: io1\n          volumeMode: Block\n          accessModes:\n            - ReadWriteOnce\n</code></pre> <p>Note</p> <p>Note that Rook only supports three naming convention for a given template:</p> <ul> <li>\"data\": represents the main OSD block device, where your data is being stored.</li> <li>\"metadata\": represents the metadata (including block.db and block.wal) device used to store the Ceph Bluestore database for an OSD.</li> <li>\"wal\": represents the block.wal device used to store the Ceph Bluestore database for an OSD. If this device is set, \"metadata\" device will refer specifically to block.db device. It is recommended to use a faster storage class for the metadata or wal device, with a slower device for the data. Otherwise, having a separate metadata device will not improve the performance.</li> </ul> <p>The bluestore partition has the following reference combinations supported by the ceph-volume utility:</p> <ul> <li> <p>A single \"data\" device.</p> <pre><code>    storage:\n    storageClassDeviceSets:\n    - name: set1\n        count: 3\n        portable: false\n        volumeClaimTemplates:\n        - metadata:\n            name: data\n        spec:\n            resources:\n            requests:\n                storage: 10Gi\n            # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)\n            storageClassName: gp2\n            volumeMode: Block\n            accessModes:\n            - ReadWriteOnce\n</code></pre> </li> <li> <p>A \"data\" device and a \"metadata\" device.</p> <pre><code>    storage:\n    storageClassDeviceSets:\n    - name: set1\n        count: 3\n        portable: false\n        volumeClaimTemplates:\n        - metadata:\n            name: data\n        spec:\n            resources:\n            requests:\n                storage: 10Gi\n            # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)\n            storageClassName: gp2\n            volumeMode: Block\n            accessModes:\n            - ReadWriteOnce\n        - metadata:\n            name: metadata\n        spec:\n            resources:\n            requests:\n                # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing\n                storage: 5Gi\n            # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)\n            storageClassName: io1\n            volumeMode: Block\n            accessModes:\n            - ReadWriteOnce\n</code></pre> </li> <li> <p>A \"data\" device and a \"wal\" device. A WAL device can be used for BlueStore\u2019s internal journal or write-ahead log (block.wal), it is only useful to use a WAL device if the device is faster than the primary device (data device). There is no separate \"metadata\" device in this case, the data of main OSD block and block.db located in \"data\" device.</p> <pre><code>    storage:\n    storageClassDeviceSets:\n    - name: set1\n        count: 3\n        portable: false\n        volumeClaimTemplates:\n        - metadata:\n            name: data\n        spec:\n            resources:\n            requests:\n                storage: 10Gi\n            # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)\n            storageClassName: gp2\n            volumeMode: Block\n            accessModes:\n            - ReadWriteOnce\n        - metadata:\n            name: wal\n        spec:\n            resources:\n            requests:\n                # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing\n                storage: 5Gi\n            # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)\n            storageClassName: io1\n            volumeMode: Block\n            accessModes:\n            - ReadWriteOnce\n</code></pre> </li> <li> <p>A \"data\" device, a \"metadata\" device and a \"wal\" device.</p> <pre><code>    storage:\n    storageClassDeviceSets:\n    - name: set1\n        count: 3\n        portable: false\n        volumeClaimTemplates:\n        - metadata:\n            name: data\n        spec:\n            resources:\n            requests:\n                storage: 10Gi\n            # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)\n            storageClassName: gp2\n            volumeMode: Block\n            accessModes:\n            - ReadWriteOnce\n        - metadata:\n            name: metadata\n        spec:\n            resources:\n            requests:\n                # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing\n                storage: 5Gi\n            # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)\n            storageClassName: io1\n            volumeMode: Block\n            accessModes:\n            - ReadWriteOnce\n        - metadata:\n            name: wal\n        spec:\n            resources:\n            requests:\n                # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing\n                storage: 5Gi\n            # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)\n            storageClassName: io1\n            volumeMode: Block\n            accessModes:\n            - ReadWriteOnce\n</code></pre> </li> </ul> <p>To determine the size of the metadata block follow the official Ceph sizing guide.</p> <p>With the present configuration, each OSD will have its main block allocated a 10GB device as well a 5GB device to act as a bluestore database.</p>"},{"location":"CRDs/Cluster/stretch-cluster/","title":"Stretch Storage Cluster","text":"<p>For environments that only have two failure domains available where data can be replicated, consider the case where one failure domain is down and the data is still fully available in the remaining failure domain. To support this scenario, Ceph has integrated support for \"stretch\" clusters.</p> <p>Rook requires three zones. Two zones (A and B) will each run all types of Rook pods, which we call the \"data\" zones. Two mons run in each of the two data zones, while two replicas of the data are in each zone for a total of four data replicas. The third zone (arbiter) runs a single mon. No other Rook or Ceph daemons need to be run in the arbiter zone.</p> <p>For this example, we assume the desired failure domain is a zone. Another failure domain can also be specified with a known topology node label which is already being used for OSD failure domains.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephCluster\nmetadata:\n  name: rook-ceph\n  namespace: rook-ceph\nspec:\n  dataDirHostPath: /var/lib/rook\n  mon:\n    # Five mons must be created for stretch mode\n    count: 5\n    allowMultiplePerNode: false\n    stretchCluster:\n      failureDomainLabel: topology.kubernetes.io/zone\n      subFailureDomain: host\n      zones:\n      - name: a\n        arbiter: true\n      - name: b\n      - name: c\n  cephVersion:\n    image: quay.io/ceph/ceph:v18.2.4\n    allowUnsupported: true\n  # Either storageClassDeviceSets or the storage section can be specified for creating OSDs.\n  # This example uses all devices for simplicity.\n  storage:\n    useAllNodes: true\n    useAllDevices: true\n    deviceFilter: \"\"\n  # OSD placement is expected to include the non-arbiter zones\n  placement:\n    osd:\n      nodeAffinity:\n        requiredDuringSchedulingIgnoredDuringExecution:\n          nodeSelectorTerms:\n          - matchExpressions:\n            - key: topology.kubernetes.io/zone\n              operator: In\n              values:\n              - b\n              - c\n</code></pre> <p>For more details, see the Stretch Cluster design doc.</p>"},{"location":"CRDs/Cluster/external-cluster/advance-external/","title":"External Cluster Options","text":""},{"location":"CRDs/Cluster/external-cluster/advance-external/#nfs-storage","title":"NFS storage","text":"<p>Rook suggests a different mechanism for making use of an NFS service running on the external Ceph standalone cluster, if desired.</p>"},{"location":"CRDs/Cluster/external-cluster/advance-external/#exporting-rook-to-another-cluster","title":"Exporting Rook to another cluster","text":"<p>If you have multiple K8s clusters running, and want to use the local <code>rook-ceph</code> cluster as the central storage, you can export the settings from this cluster with the following steps.</p> <ol> <li> <p>Copy create-external-cluster-resources.py into the directory <code>/etc/ceph/</code> of the toolbox.</p> <pre><code>toolbox=$(kubectl get pod -l app=rook-ceph-tools -n rook-ceph -o jsonpath='{.items[*].metadata.name}')\nkubectl -n rook-ceph cp deploy/examples/external/create-external-cluster-resources.py $toolbox:/etc/ceph\n</code></pre> </li> <li> <p>Exec to the toolbox pod and execute create-external-cluster-resources.py with needed options to create required users and keys.</p> </li> </ol> <p>Important</p> <p>For other clusters to connect to storage in this cluster, Rook must be configured with a networking configuration that is accessible from other clusters. Most commonly this is done by enabling host networking in the CephCluster CR so the Ceph daemons will be addressable by their host IPs.</p>"},{"location":"CRDs/Cluster/external-cluster/advance-external/#admin-privileges","title":"Admin privileges","text":"<p>If in case the cluster needs the admin keyring to configure, update the admin key <code>rook-ceph-mon</code> secret with client.admin keyring</p> <p>Note</p> <p>Sharing the admin key with the external cluster is not generally recommended</p> <ol> <li> <p>Get the <code>client.admin</code> keyring from the ceph cluster</p> <pre><code>ceph auth get client.admin\n</code></pre> </li> <li> <p>Update two values in the <code>rook-ceph-mon</code> secret:</p> <ul> <li><code>ceph-username</code>: Set to <code>client.admin</code></li> <li><code>ceph-secret</code>: Set the client.admin keyring</li> </ul> </li> </ol> <p>After restarting the rook operator (and the toolbox if in use), rook will configure ceph with admin privileges.</p>"},{"location":"CRDs/Cluster/external-cluster/advance-external/#connect-to-an-external-object-store","title":"Connect to an External Object Store","text":"<p>Create the external object store CR to configure connection to external gateways.</p> <pre><code>cd deploy/examples/external\nkubectl create -f object-external.yaml\n</code></pre> <p>Consume the S3 Storage, in two different ways:</p> <ol> <li> <p>Create an Object store user for credentials to access the S3 endpoint.</p> <pre><code>cd deploy/examples\nkubectl create -f object-user.yaml\n</code></pre> </li> <li> <p>Create a bucket storage class where a client can request creating buckets and then create the Object Bucket Claim, which will create an individual bucket for reading and writing objects.</p> <pre><code>cd deploy/examples/external\nkubectl create -f storageclass-bucket-delete.yaml\nkubectl create -f object-bucket-claim-delete.yaml\n</code></pre> </li> </ol> <p>Hint</p> <p>For more details see the Object Store topic</p>"},{"location":"CRDs/Cluster/external-cluster/consumer-import/","title":"Import Ceph configuration to the Rook consumer cluster","text":""},{"location":"CRDs/Cluster/external-cluster/consumer-import/#installation-types","title":"Installation types","text":"<p>Install Rook in the the consumer cluster, either with Helm or the manifests.</p>"},{"location":"CRDs/Cluster/external-cluster/consumer-import/#helm-installation","title":"Helm Installation","text":"<p>To install with Helm, the rook cluster helm chart will configure the necessary resources for the external cluster with the example <code>values-external.yaml</code>.</p> <pre><code>clusterNamespace=rook-ceph\noperatorNamespace=rook-ceph\ncd deploy/examples/charts/rook-ceph-cluster\nhelm repo add rook-release https://charts.rook.io/release\nhelm install --create-namespace --namespace $clusterNamespace rook-ceph rook-release/rook-ceph -f values.yaml\nhelm install --create-namespace --namespace $clusterNamespace rook-ceph-cluster \\\n--set operatorNamespace=$operatorNamespace rook-release/rook-ceph-cluster -f values-external.yaml\n</code></pre>"},{"location":"CRDs/Cluster/external-cluster/consumer-import/#manifest-installation","title":"Manifest Installation","text":"<p>If not installing with Helm, here are the steps to install with manifests.</p> <ol> <li> <p>Deploy Rook, create common.yaml, crds.yaml and operator.yaml manifests.</p> </li> <li> <p>Create common-external.yaml and cluster-external.yaml</p> </li> </ol>"},{"location":"CRDs/Cluster/external-cluster/consumer-import/#import-the-provider-data","title":"Import the Provider Data","text":"<ol> <li> <p>Paste the above output from <code>create-external-cluster-resources.py</code> into your current shell to allow importing the provider data.</p> </li> <li> <p>The import script in the next step uses the current kubeconfig context by     default. If you want to specify the kubernetes cluster to use without     changing the current context, you can specify the cluster name by setting     the KUBECONTEXT environment variable.</p> <pre><code>export KUBECONTEXT=&lt;cluster-name&gt;\n</code></pre> </li> <li> <p>Here is the link for import script. The script has used the <code>rook-ceph</code> namespace and few parameters that also have referenced from namespace variable. If user's external cluster has a different namespace, change the namespace parameter in the script according to their external cluster. For example with <code>new-namespace</code> namespace, this change is needed on the namespace parameter in the script.</p> <pre><code>NAMESPACE=${NAMESPACE:=\"new-namespace\"}\n</code></pre> </li> <li> <p>Run the import script.</p> <p>Note</p> <p>If your Rook cluster nodes are running a kernel earlier than or equivalent to 5.4, remove <code>fast-diff, object-map, deep-flatten,exclusive-lock</code> from the <code>imageFeatures</code> line.</p> <pre><code>. import-external-cluster.sh\n</code></pre> </li> </ol>"},{"location":"CRDs/Cluster/external-cluster/consumer-import/#cluster-verification","title":"Cluster Verification","text":"<ol> <li> <p>Verify the consumer cluster is connected to the provider ceph cluster:</p> <pre><code>$ kubectl -n rook-ceph  get CephCluster\nNAME                 DATADIRHOSTPATH   MONCOUNT   AGE    STATE       HEALTH\nrook-ceph-external   /var/lib/rook                162m   Connected   HEALTH_OK\n</code></pre> </li> <li> <p>Verify the creation of the storage class depending on the rbd pools and filesystem provided.     <code>ceph-rbd</code> and <code>cephfs</code> would be the respective names for the RBD and CephFS storage classes.</p> <pre><code>kubectl -n rook-ceph get sc\n</code></pre> </li> <li> <p>Create a persistent volume based on these StorageClass.</p> </li> </ol>"},{"location":"CRDs/Cluster/external-cluster/external-cluster/","title":"External Storage Cluster","text":"<p>An external cluster is a Ceph configuration that is managed outside of the local K8s cluster. The external cluster could be managed by cephadm, or it could be another Rook cluster that is configured to allow the access (usually configured with host networking).</p> <p>In external mode, Rook will provide the configuration for the CSI driver and other basic resources that allows your applications to connect to Ceph in the external cluster.</p>"},{"location":"CRDs/Cluster/external-cluster/external-cluster/#external-configuration","title":"External configuration","text":"<ul> <li> <p>Provider cluster: The cluster providing the data, usually configured by cephadm</p> </li> <li> <p>Consumer cluster: The K8s cluster that will be consuming the external provider cluster</p> </li> </ul>"},{"location":"CRDs/Cluster/external-cluster/external-cluster/#prerequisites","title":"Prerequisites","text":"<p>Create the desired types of storage in the provider Ceph cluster:</p> <ul> <li>RBD pools</li> <li>CephFS filesystem</li> </ul>"},{"location":"CRDs/Cluster/external-cluster/external-cluster/#connect-the-external-ceph-provider-cluster-to-the-rook-consumer-cluster","title":"Connect the external Ceph Provider cluster to the Rook consumer cluster","text":"<p>1) Export config from the Provider Ceph cluster. Configuration must be exported by the Ceph admin, such as a Ceph keyring and mon endpoints, that allows connection to the Ceph cluster.</p> <p>2) Import config to the Rook consumer cluster. The configuration exported from the Ceph cluster is imported to Rook to provide the needed connection details.</p>"},{"location":"CRDs/Cluster/external-cluster/external-cluster/#advance-options","title":"Advance Options","text":"<ul> <li> <p>NFS storage</p> </li> <li> <p>Exporting Rook to another cluster</p> </li> <li> <p>Run consumer Rook cluster with Admin privileges</p> </li> <li> <p>Connect to an External Object Store</p> </li> </ul>"},{"location":"CRDs/Cluster/external-cluster/external-cluster/#upgrades","title":"Upgrades","text":"<ul> <li> <p>Upgrade external cluster</p> </li> <li> <p>Utilize new features in upgrade</p> </li> </ul>"},{"location":"CRDs/Cluster/external-cluster/provider-export/","title":"Export config from the Ceph provider cluster","text":"<p>In order to configure an external Ceph cluster with Rook, we need to extract some information in order to connect to that cluster.</p>"},{"location":"CRDs/Cluster/external-cluster/provider-export/#1-create-all-users-and-keys","title":"1. Create all users and keys","text":"<p>Run the python script create-external-cluster-resources.py in the provider Ceph cluster cephadm shell, to have access to create the necessary users and keys.</p> <pre><code>python3 create-external-cluster-resources.py --rbd-data-pool-name &lt;pool_name&gt; --cephfs-filesystem-name &lt;filesystem-name&gt; --rgw-endpoint  &lt;rgw-endpoint&gt; --namespace &lt;namespace&gt; --format bash\n</code></pre> <ul> <li><code>--namespace</code>: Namespace where CephCluster will run, for example <code>rook-ceph</code></li> <li><code>--format bash</code>: The format of the output</li> <li><code>--rbd-data-pool-name</code>: The name of the RBD data pool</li> <li><code>--alias-rbd-data-pool-name</code>: Provides an alias for the  RBD data pool name, necessary if a special character is present in the pool name such as a period or underscore</li> <li><code>--rgw-endpoint</code>: (optional) The RADOS Gateway endpoint in the format <code>&lt;IP&gt;:&lt;PORT&gt;</code> or <code>&lt;FQDN&gt;:&lt;PORT&gt;</code>.</li> <li><code>--rgw-pool-prefix</code>: (optional) The prefix of the RGW pools. If not specified, the default prefix is <code>default</code></li> <li><code>--rgw-tls-cert-path</code>: (optional) RADOS Gateway endpoint TLS certificate (or intermediate signing certificate) file path</li> <li><code>--rgw-skip-tls</code>: (optional) Ignore TLS certification validation when a self-signed certificate is provided (NOT RECOMMENDED)</li> <li><code>--rbd-metadata-ec-pool-name</code>: (optional) Provides the name of erasure coded RBD metadata pool, used for creating ECRBDStorageClass.</li> <li><code>--monitoring-endpoint</code>: (optional) Ceph Manager prometheus exporter endpoints (comma separated list of IP entries of active and standby mgrs)</li> <li><code>--monitoring-endpoint-port</code>: (optional) Ceph Manager prometheus exporter port</li> <li><code>--skip-monitoring-endpoint</code>: (optional) Skip prometheus exporter endpoints, even if they are available. Useful if the prometheus module is not enabled</li> <li><code>--ceph-conf</code>: (optional) Provide a Ceph conf file</li> <li><code>--keyring</code>: (optional) Path to Ceph keyring file, to be used with <code>--ceph-conf</code></li> <li><code>--k8s-cluster-name</code>: (optional) Kubernetes cluster name</li> <li><code>--output</code>: (optional) Output will be stored into the provided file</li> <li><code>--dry-run</code>: (optional) Prints the executed commands without running them</li> <li><code>--run-as-user</code>: (optional) Provides a user name to check the cluster's health status, must be prefixed by <code>client</code>.</li> <li><code>--cephfs-metadata-pool-name</code>: (optional) Provides the name of the cephfs metadata pool</li> <li><code>--cephfs-filesystem-name</code>: (optional) The name of the filesystem, used for creating CephFS StorageClass</li> <li><code>--cephfs-data-pool-name</code>: (optional) Provides the name of the CephFS data pool, used for creating CephFS StorageClass</li> <li><code>--rados-namespace</code>: (optional) Divides a pool into separate logical namespaces, used for creating RBD PVC in a CephBlockPoolRadosNamespace (should be lower case)</li> <li><code>--subvolume-group</code>: (optional) Provides the name of the subvolume group, used for creating CephFS PVC in a subvolumeGroup</li> <li><code>--rgw-realm-name</code>: (optional) Provides the name of the rgw-realm</li> <li><code>--rgw-zone-name</code>: (optional) Provides the name of the rgw-zone</li> <li><code>--rgw-zonegroup-name</code>: (optional) Provides the name of the rgw-zone-group</li> <li><code>--upgrade</code>: (optional) Upgrades the cephCSIKeyrings(For example: client.csi-cephfs-provisioner) and client.healthchecker ceph users with new permissions needed for the new cluster version and older permission will still be applied.</li> <li><code>--restricted-auth-permission</code>: (optional) Restrict cephCSIKeyrings auth permissions to specific pools, and cluster. Mandatory flags that need to be set are <code>--rbd-data-pool-name</code>, and <code>--k8s-cluster-name</code>. <code>--cephfs-filesystem-name</code> flag can also be passed in case of CephFS user restriction, so it can restrict users to particular CephFS filesystem.</li> <li><code>--v2-port-enable</code>: (optional) Enables the v2 mon port (3300) for mons.</li> <li><code>--topology-pools</code>: (optional) Comma-separated list of topology-constrained rbd pools</li> <li><code>--topology-failure-domain-label</code>: (optional) K8s cluster failure domain label (example: zone, rack, or host) for the topology-pools that match the ceph domain</li> <li><code>--topology-failure-domain-values</code>: (optional) Comma-separated list of the k8s cluster failure domain values corresponding to each of the pools in the <code>topology-pools</code> list</li> <li><code>--config-file</code>: Path to the configuration file, Priority: command-line-args &gt; config.ini values &gt; default values</li> </ul>"},{"location":"CRDs/Cluster/external-cluster/provider-export/#2-copy-the-bash-output","title":"2. Copy the bash output","text":"<p>Example Output:</p> <pre><code>export ROOK_EXTERNAL_FSID=797f411a-aafe-11ec-a254-fa163e1539f5\nexport ROOK_EXTERNAL_USERNAME=client.healthchecker\nexport ROOK_EXTERNAL_CEPH_MON_DATA=ceph-rados-upstream-w4pdvq-node1-installer=10.0.210.83:6789\nexport ROOK_EXTERNAL_USER_SECRET=AQAdm0FilZDSJxAAMucfuu/j0ZYYP4Bia8Us+w==\nexport ROOK_EXTERNAL_DASHBOARD_LINK=https://10.0.210.83:8443/\nexport CSI_RBD_NODE_SECRET=AQC1iDxip45JDRAAVahaBhKz1z0WW98+ACLqMQ==\nexport CSI_RBD_PROVISIONER_SECRET=AQC1iDxiMM+LLhAA0PucjNZI8sG9Eh+pcvnWhQ==\nexport MONITORING_ENDPOINT=10.0.210.83\nexport MONITORING_ENDPOINT_PORT=9283\nexport RBD_POOL_NAME=replicated_2g\nexport RGW_POOL_PREFIX=default\n</code></pre>"},{"location":"CRDs/Cluster/external-cluster/provider-export/#examples-on-utilizing-advance-flags","title":"Examples on utilizing Advance flags","text":""},{"location":"CRDs/Cluster/external-cluster/provider-export/#config-file","title":"Config-file","text":"<p>Use the config file to set the user configuration file, add the flag <code>--config-file</code> to set the file path.</p> <p>Example:</p> <p><code>/config.ini</code></p> <pre><code>[Configurations]\nformat = bash\ncephfs-filesystem-name = &lt;filesystem-name&gt;\nrbd-data-pool-name = &lt;pool_name&gt;\n...\n</code></pre> <pre><code>python3 create-external-cluster-resources.py --config-file /config.ini\n</code></pre> <p>Note</p> <p>You can use both config file and other arguments at the same time Priority: command-line-args has more priority than config.ini file values, and config.ini file values have more priority than default values.</p>"},{"location":"CRDs/Cluster/external-cluster/provider-export/#multi-tenancy","title":"Multi-tenancy","text":"<p>To enable multi-tenancy, run the script with the <code>--restricted-auth-permission</code> flag and pass the mandatory flags with it, It will generate the secrets which you can use for creating new <code>Consumer cluster</code> deployment using the same <code>Provider cluster</code>(ceph cluster). So you would be running different isolated consumer clusters on top of single <code>Provider cluster</code>.</p> <p>Note</p> <p>Restricting the csi-users per pool, and per cluster will require creating new csi-users and new secrets for that csi-users. So apply these secrets only to new <code>Consumer cluster</code> deployment while using the same <code>Provider cluster</code>.</p> <pre><code>python3 create-external-cluster-resources.py --cephfs-filesystem-name &lt;filesystem-name&gt; --rbd-data-pool-name &lt;pool_name&gt; --k8s-cluster-name &lt;k8s-cluster-name&gt; --restricted-auth-permission true --format &lt;bash&gt; --rgw-endpoint &lt;rgw_endpoint&gt; --namespace &lt;rook-ceph&gt;\n</code></pre>"},{"location":"CRDs/Cluster/external-cluster/provider-export/#rgw-multisite","title":"RGW Multisite","text":"<p>Pass the <code>--rgw-realm-name</code>, <code>--rgw-zonegroup-name</code> and <code>--rgw-zone-name</code> flags to create the admin ops user in a master zone, zonegroup and realm. See the Multisite doc for creating a zone, zonegroup and realm.</p> <pre><code>python3 create-external-cluster-resources.py --rbd-data-pool-name &lt;pool_name&gt; --format bash --rgw-endpoint &lt;rgw_endpoint&gt; --rgw-realm-name &lt;rgw_realm_name&gt;&gt; --rgw-zonegroup-name &lt;rgw_zonegroup_name&gt; --rgw-zone-name &lt;rgw_zone_name&gt;&gt;\n</code></pre>"},{"location":"CRDs/Cluster/external-cluster/provider-export/#topology-based-provisioning","title":"Topology Based Provisioning","text":"<p>Enable Topology Based Provisioning for RBD pools by passing <code>--topology-pools</code>, <code>--topology-failure-domain-label</code> and <code>--topology-failure-domain-values</code> flags. A new storageclass named <code>ceph-rbd-topology</code> will be created by the import script with <code>volumeBindingMode: WaitForFirstConsumer</code>. The storageclass is used to create a volume in the pool matching the topology where a pod is scheduled.</p> <p>For more details, see the Topology-Based Provisioning</p>"},{"location":"CRDs/Cluster/external-cluster/provider-export/#connect-to-v2-mon-port","title":"Connect to v2 mon port","text":"<p>If encryption or compression on the wire is needed, specify the <code>--v2-port-enable</code> flag. If the v2 address type is present in the <code>ceph quorum_status</code>, then the output of 'ceph mon data' i.e, <code>ROOK_EXTERNAL_CEPH_MON_DATA</code> will use the v2 port(<code>3300</code>).</p>"},{"location":"CRDs/Cluster/external-cluster/topology-for-external-mode/","title":"Topology-Based Provisioning","text":""},{"location":"CRDs/Cluster/external-cluster/topology-for-external-mode/#scenario","title":"Scenario","text":"<p>Applications like Kafka will have a deployment with multiple running instances. Each service instance will create a new claim and is expected to be located in a different zone. Since the application has its own redundant instances, there is no requirement for redundancy at the data layer. A storage class is created that will provision storage from replica 1 Ceph pools that are located in each of the separate zones.</p>"},{"location":"CRDs/Cluster/external-cluster/topology-for-external-mode/#configuration-flags","title":"Configuration Flags","text":"<p>Add the required flags to the script: <code>create-external-cluster-resources.py</code>:</p> <ul> <li> <p><code>--topology-pools</code>: (optional) Comma-separated list of topology-constrained rbd pools</p> </li> <li> <p><code>--topology-failure-domain-label</code>: (optional) K8s cluster failure domain label (example: zone, rack, or host) for the topology-pools that match the ceph domain</p> </li> <li> <p><code>--topology-failure-domain-values</code>: (optional) Comma-separated list of the k8s cluster failure domain values corresponding to each of the pools in the <code>topology-pools</code> list</p> </li> </ul> <p>The import script will then create a new storage class named <code>ceph-rbd-topology</code>.</p>"},{"location":"CRDs/Cluster/external-cluster/topology-for-external-mode/#example-configuration","title":"Example Configuration","text":""},{"location":"CRDs/Cluster/external-cluster/topology-for-external-mode/#ceph-cluster","title":"Ceph cluster","text":"<p>Determine the names of the zones (or other failure domains) in the Ceph CRUSH map where each of the pools will have corresponding CRUSH rules.</p> <p>Create a zone-specific CRUSH rule for each of the pools. For example, this is a CRUSH rule for <code>zone-a</code>:</p> <pre><code>$ ceph osd crush rule create-replicated &lt;rule-name&gt; &lt;root&gt; &lt;failure-domain&gt; &lt;class&gt;\n {\n            \"rule_id\": 5,\n            \"rule_name\": \"rule_host-zone-a-hdd\",\n            \"type\": 1,\n            \"steps\": [\n                {\n                    \"op\": \"take\",\n                    \"item\": -10,\n                    \"item_name\": \"zone-a~hdd\"\n                },\n                {\n                    \"op\": \"choose_firstn\",\n                    \"num\": 0,\n                    \"type\": \"osd\"\n                },\n                {\n                    \"op\": \"emit\"\n                }\n            ]\n}\n</code></pre> <p>Create replica-1 pools based on each of the CRUSH rules from the previous step. Each pool must be created with a CRUSH rule to limit the pool to OSDs in a specific zone.</p> <p>Note</p> <p>Disable the ceph warning for replica-1 pools: <code>ceph config set global mon_allow_pool_size_one true</code></p> <p>Determine the zones in the K8s cluster that correspond to each of the pools in the Ceph pool. The K8s nodes require labels as defined with the OSD Topology labels. Some environments already have nodes labeled in zones. Set the topology labels on the nodes if not already present.</p> <p>Set the flags of the external cluster configuration script based on the pools and failure domains.</p> <p>--topology-pools=pool-a,pool-b,pool-c</p> <p>--topology-failure-domain-label=zone</p> <p>--topology-failure-domain-values=zone-a,zone-b,zone-c</p> <p>Then run the python script to generate the settings which will be imported to the Rook cluster:</p> <pre><code> python3 create-external-cluster-resources.py --rbd-data-pool-name replicapool --topology-pools pool-a,pool-b,pool-c --topology-failure-domain-label zone --topology-failure-domain-values zone-a,zone-b,zone-c\n</code></pre> <p>Output:</p> <pre><code>export ROOK_EXTERNAL_FSID=8f01d842-d4b2-11ee-b43c-0050568fb522\n....\n....\n....\nexport TOPOLOGY_POOLS=pool-a,pool-b,pool-c\nexport TOPOLOGY_FAILURE_DOMAIN_LABEL=zone\nexport TOPOLOGY_FAILURE_DOMAIN_VALUES=zone-a,zone-b,zone-c\n</code></pre>"},{"location":"CRDs/Cluster/external-cluster/topology-for-external-mode/#kubernetes-cluster","title":"Kubernetes Cluster","text":"<p>Check the external cluster is created and connected as per the installation steps. Review the new storage class:</p> <pre><code>$ kubectl get sc ceph-rbd-topology -o yaml\nallowVolumeExpansion: true\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  creationTimestamp: \"2024-03-07T12:10:19Z\"\n  name: ceph-rbd-topology\n  resourceVersion: \"82502\"\n  uid: 68448a14-3a78-42c5-ac29-261b6c3404af\nparameters:\n  ...\n  ...\n  topologyConstrainedPools: |\n    [\n     {\"poolName\":\"pool-a\",\n      \"domainSegments\":[\n        {\"domainLabel\":\"zone\",\"value\":\"zone-a\"}]},\n     {\"poolName\":\"pool-b\",\n      \"domainSegments\":[\n        {\"domainLabel\":\"zone\",\"value\":\"zone-b\"}]},\n     {\"poolName\":\"pool-c\",\n      \"domainSegments\":[\n        {\"domainLabel\":\"zone\",\"value\":\"zone-c\"}]},\n    ]\nprovisioner: rook-ceph.rbd.csi.ceph.com\nreclaimPolicy: Delete\nvolumeBindingMode: WaitForFirstConsumer\n</code></pre> <p>Set two values in the rook-ceph-operator-config configmap:</p> <ul> <li><code>CSI_ENABLE_TOPOLOGY: \"true\"</code>: Enable the feature</li> <li><code>CSI_TOPOLOGY_DOMAIN_LABELS: \"topology.kubernetes.io/zone\"</code>: Set the topology domain labels that the CSI driver will analyze on the nodes during scheduling.</li> </ul>"},{"location":"CRDs/Cluster/external-cluster/topology-for-external-mode/#create-a-topology-based-pvc","title":"Create a Topology-Based PVC","text":"<p>The topology-based storage class is ready to be consumed! Create a PVC from the <code>ceph-rbd-topology</code> storage class above, and watch the OSD usage to see how the data is spread only among the topology-based CRUSH buckets.</p>"},{"location":"CRDs/Cluster/external-cluster/upgrade-external/","title":"External Cluster Upgrades","text":"<p>When upgrading an external cluster, Ceph and Rook versions will be updated independently. During the Rook update, the external provider cluster connection also needs to be updated with any settings and permissions for new features.</p>"},{"location":"CRDs/Cluster/external-cluster/upgrade-external/#upgrade-the-cluster-to-consume-latest-ceph-user-caps-mandatory","title":"Upgrade the cluster to consume latest ceph user caps (mandatory)","text":"<p>Upgrading the cluster would be different for restricted caps and non-restricted caps,</p> <ol> <li> <p>If consumer cluster doesn't have restricted caps, this will upgrade all the default CSI users (non-restricted)</p> <pre><code>python3 create-external-cluster-resources.py --upgrade\n</code></pre> </li> <li> <p>If the consumer cluster has restricted caps</p> <p>Restricted users created using <code>--restricted-auth-permission</code> flag need to pass mandatory flags: '<code>--rbd-data-pool-name</code>(if it is a rbd user), <code>--k8s-cluster-name</code> and <code>--run-as-user</code>' flags while upgrading, in case of cephfs users if you have passed <code>--cephfs-filesystem-name</code> flag while creating CSI users then while upgrading it will be mandatory too. In this example the user would be <code>client.csi-rbd-node-rookstorage-replicapool</code> (following the pattern <code>csi-user-clusterName-poolName</code>)</p> <pre><code>python3 create-external-cluster-resources.py --upgrade --rbd-data-pool-name replicapool --k8s-cluster-name rookstorage --run-as-user client.csi-rbd-node-rookstorage-replicapool\n</code></pre> <p>Note</p> <p>1) An existing non-restricted user cannot be converted to a restricted user by upgrading. 2) The upgrade flag should only be used to append new permissions to users. It shouldn't be used for changing a CSI user already applied permissions. For example, be careful not to change pools(s) that a user has access to.</p> </li> </ol>"},{"location":"CRDs/Cluster/external-cluster/upgrade-external/#upgrade-cluster-to-utilize-a-new-feature-optional","title":"Upgrade cluster to utilize a new feature (optional)","text":"<p>Some Rook upgrades may require re-running the import steps, or may introduce new external cluster features that can be most easily enabled by re-running the import steps.</p> <p>To re-run the import steps with new options, the python script should be re-run using the same configuration options that were used for past invocations, plus the configurations that are being added or modified.</p> <p>Starting with Rook v1.15, the script stores the configuration in the external-cluster-user-command configmap for easy future reference.</p> <ul> <li>arg: Exact arguments that were used for for processing the script. Argument that are decided using the Priority: command-line-args has more priority than config.ini file values, and config.ini file values have more priority than default values.</li> </ul>"},{"location":"CRDs/Cluster/external-cluster/upgrade-external/#example-external-cluster-user-command-configmap","title":"Example <code>external-cluster-user-command</code> ConfigMap:","text":"<ol> <li> <p>Get the last-applied config, if its available</p> <pre><code>$ kubectl get configmap -namespace rook-ceph external-cluster-user-command --output jsonpath='{.data.args}'\n</code></pre> </li> <li> <p>Copy the output to config.ini</p> </li> <li> <p>Make any desired modifications and additions to `config.ini``</p> </li> <li> <p>Run the python script again using the config file</p> </li> <li> <p>Copy the bash output</p> </li> <li> <p>Import-the-provider-data</p> </li> </ol> <p>Warning</p> <p>If the last-applied config is unavailable, run the current version of the script again using previously-applied config and CLI flags. Failure to reuse the same configuration options when re-invoking the python script can result in unexpected changes when re-running the import script.</p>"},{"location":"CRDs/Object-Storage/ceph-object-realm-crd/","title":"CephObjectRealm CRD","text":"<p>Rook allows creation of a realm in a Ceph Object Multisite configuration through a CRD. The following settings are available for Ceph object store realms.</p>"},{"location":"CRDs/Object-Storage/ceph-object-realm-crd/#example","title":"Example","text":"<pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectRealm\nmetadata:\n  name: realm-a\n  namespace: rook-ceph\n# This endpoint in this section needs is an endpoint from the master zone  in the master zone group of realm-a. See object-multisite.md for more details.\nspec:\n  pull:\n    endpoint: http://10.2.105.133:80\n</code></pre>"},{"location":"CRDs/Object-Storage/ceph-object-realm-crd/#settings","title":"Settings","text":""},{"location":"CRDs/Object-Storage/ceph-object-realm-crd/#metadata","title":"Metadata","text":"<ul> <li><code>name</code>: The name of the object realm to create</li> <li><code>namespace</code>: The namespace of the Rook cluster where the object realm is created.</li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-realm-crd/#spec","title":"Spec","text":"<ul> <li><code>pull</code>: This optional section is for the pulling the realm for another ceph cluster.<ul> <li><code>endpoint</code>: The endpoint in the realm from another ceph cluster you want to pull from. This endpoint must be in the master zone of the master zone group of the realm.</li> </ul> </li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/","title":"CephObjectStore CRD","text":"<p>Rook allows creation and customization of object stores through the custom resource definitions (CRDs). The following settings are available for Ceph object stores.</p>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#example","title":"Example","text":""},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#erasure-coded","title":"Erasure Coded","text":"<p>Erasure coded pools can only be used with <code>dataPools</code>. The <code>metadataPool</code> must use a replicated pool.</p> <p>Note</p> <p>This sample requires at least 3 bluestore OSDs, with each OSD located on a different node.</p> <p>The OSDs must be located on different nodes, because the <code>failureDomain</code> is set to <code>host</code> and the <code>erasureCoded</code> chunk settings require at least 3 different OSDs (2 <code>dataChunks</code> + 1 <code>codingChunks</code>).</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectStore\nmetadata:\n  name: my-store\n  namespace: rook-ceph\nspec:\n  metadataPool:\n    failureDomain: host\n    replicated:\n      size: 3\n  dataPool:\n    failureDomain: host\n    erasureCoded:\n      dataChunks: 2\n      codingChunks: 1\n  preservePoolsOnDelete: true\n  gateway:\n    # sslCertificateRef:\n    # caBundleRef:\n    port: 80\n    # securePort: 443\n    instances: 1\n    # A key/value list of annotations\n    annotations:\n    #  key: value\n    placement:\n    #  nodeAffinity:\n    #    requiredDuringSchedulingIgnoredDuringExecution:\n    #      nodeSelectorTerms:\n    #      - matchExpressions:\n    #        - key: role\n    #          operator: In\n    #          values:\n    #          - rgw-node\n    #  tolerations:\n    #  - key: rgw-node\n    #    operator: Exists\n    #  podAffinity:\n    #  podAntiAffinity:\n    #  topologySpreadConstraints:\n    resources:\n    #  limits:\n    #    memory: \"1024Mi\"\n    #  requests:\n    #    cpu: \"500m\"\n    #    memory: \"1024Mi\"\n  #zone:\n    #name: zone-a\n  #hosting:\n  #  advertiseEndpoint:\n  #    dnsName: \"mystore.example.com\"\n  #    port: 80\n  #    useTls: false\n  #  dnsNames:\n  #    - \"mystore.example.org\"\n</code></pre>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#object-store-settings","title":"Object Store Settings","text":""},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#metadata","title":"Metadata","text":"<ul> <li><code>name</code>: The name of the object store to create, which will be reflected in the pool and other resource names.</li> <li><code>namespace</code>: The namespace of the Rook cluster where the object store is created.</li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#pools","title":"Pools","text":"<p>The pools allow all of the settings defined in the Block Pool CRD spec. For more details, see the Block Pool CRD settings. In the example above, there must be at least three hosts (size 3) and at least three devices (2 data + 1 coding chunks) in the cluster.</p> <p>When the <code>zone</code> section is set pools with the object stores name will not be created since the object-store will the using the pools created by the ceph-object-zone.</p> <ul> <li><code>metadataPool</code>: The settings used to create all of the object store metadata pools. Must use replication.</li> <li><code>dataPool</code>: The settings to create the object store data pool. Can use replication or erasure coding.</li> <li><code>preservePoolsOnDelete</code>: If it is set to 'true' the pools used to support the object store will remain when the object store     will be deleted. This is a security measure to avoid accidental loss of data. It is set to 'false' by default. If not specified     is also deemed as 'false'.</li> <li><code>allowUsersInNamespaces</code>: If a CephObjectStoreUser is created in a namespace other than the Rook cluster namespace,     the namespace must be added to this list of allowed namespaces, or specify \"*\" to allow all namespaces.     This is useful for applications that need object store credentials to be created in their own namespace,     where neither OBCs nor COSI is being used to create buckets. The default is empty.</li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#auth-settings","title":"Auth Settings","text":"<p>The <code>auth</code>-section allows the configuration of authentication providers in addition to the regular authentication mechanism.</p> <p>Currently only OpenStack Keystone is supported.</p>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#keystone-settings","title":"Keystone Settings","text":"<p>The keystone authentication can be configured in the <code>spec.auth.keystone</code> section of the CRD:</p> <pre><code>spec:\n  [...]\n  auth:\n    keystone:\n      acceptedRoles:\n        - admin\n        - member\n        - service\n      implicitTenants: \"swift\"\n      revocationInterval: 1200\n      serviceUserSecretName: usersecret\n      tokenCacheSize: 1000\n      url: https://keystone.example-namespace.svc/\n  protocols:\n    swift:\n      accountInUrl: true\n      urlPrefix: /swift\n  [...]\n</code></pre> <p>Note: With this example configuration S3 is implicitly enabled even though it is not enabled in the <code>protocols</code> section.</p> <p>The following options can be configured in the <code>keystone</code>-section:</p> <ul> <li><code>acceptedRoles</code>: The OpenStack Keystone roles accepted by RGW when authenticating against Keystone.</li> <li><code>implicitTenants</code>: Indicates whether to use implicit tenants. This can be <code>true</code>, <code>false</code>, <code>swift</code> and <code>s3</code>. For more details see the Ceph RadosGW documentation on multitenancy.</li> <li><code>revocationInterval</code>: The number of seconds between token revocation checks.</li> <li><code>serviceUserSecretName</code>: the name of the user secret containing the credentials for the admin user to use by rgw when communicating with Keystone. See Object Store with Keystone and Swift for more details on what the secret must contain.</li> <li><code>tokenCacheSize</code>: specifies the maximum number of entries in each Keystone token cache.</li> <li><code>url</code>: The url of the Keystone API endpoint to use.</li> </ul> <p>The protocols section is divided into two parts:</p> <ul> <li>a section to configure S3</li> <li>a section to configure swift</li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#protocolss3-settings","title":"protocols/S3 settings","text":"<p>In the <code>s3</code> section of the <code>protocols</code> section the following options can be configured:</p> <ul> <li><code>authKeystone</code>: Whether S3 should also authenticated using Keystone (<code>true</code>) or not (<code>false</code>). If set to <code>false</code> the default S3 auth will be used.</li> <li><code>enabled</code>: Whether to enable S3 (<code>true</code>) or not (<code>false</code>). The default is <code>true</code> even if the section is not listed at all! Please note that S3 should not be disabled in a Ceph Multi Site configuration.</li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#protocolsswift-settings","title":"protocols/swift settings","text":"<p>In the <code>swift</code> section of the <code>protocols</code> section the following options can be configured:</p> <ul> <li><code>accountInUrl</code>: Whether or not the Swift account name should be included in the Swift API URL. If set to <code>false</code> (the default), the Swift API will listen on a URL formed like <code>http://host:port/&lt;rgw_swift_url_prefix&gt;/v1</code>. If set to <code>true</code>, the Swift API URL will be <code>http://host:port/&lt;rgw_swift_url_prefix&gt;/v1/AUTH_&lt;account_name&gt;</code>. This option must be set to <code>true</code> if radosgw should support publicly-readable containers and temporary URLs.</li> <li><code>urlPrefix</code>: The URL prefix for the Swift API, to distinguish it from the S3 API endpoint. The default is <code>swift</code>, which makes the Swift API available at the URL <code>http://host:port/swift/v1</code> (or <code>http://host:port/swift/v1/AUTH_%(tenant_id)s</code> if rgw swift account in url is enabled). \"Warning: If you set this option to <code>/</code>, the S3 API is automatically disabled. It is not possible to operate radosgw with an urlPrefix of <code>/</code> and simultaneously support both the S3 and Swift APIs. [...]\" (see Ceph documentation on swift settings).</li> <li><code>versioningEnabled</code>: If set to <code>true</code>, enables the Object Versioning of OpenStack Object Storage API. This allows clients to put the X-Versions-Location attribute on containers that should be versioned.</li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#gateway-settings","title":"Gateway Settings","text":"<p>The gateway settings correspond to the RGW daemon settings.</p> <ul> <li><code>type</code>: <code>S3</code> is supported</li> <li><code>sslCertificateRef</code>: If specified, this is the name of the Kubernetes secret(<code>opaque</code> or <code>tls</code>     type) that contains the TLS certificate to be used for secure connections to the object store.     If it is an opaque Kubernetes Secret, Rook will look in the secret provided at the <code>cert</code> key name. The value of the <code>cert</code> key must be     in the format expected by the RGW service:     \"The server key, server certificate, and any other CA or intermediate certificates be supplied in     one file. Each of these items must be in PEM form.\" They are scenarios where the certificate DNS is set for a particular domain     that does not include the local Kubernetes DNS, namely the object store DNS service endpoint. If     adding the service DNS name to the certificate is not empty another key can be specified in the     secret's data: <code>insecureSkipVerify: true</code> to skip the certificate verification. It is not     recommended to enable this option since TLS is susceptible to machine-in-the-middle attacks unless     custom verification is used.</li> <li><code>caBundleRef</code>: If specified, this is the name of the Kubernetes secret (type <code>opaque</code>) that     contains additional custom ca-bundle to use. The secret must be in the same namespace as the Rook     cluster. Rook will look in the secret provided at the <code>cabundle</code> key name.</li> <li><code>hostNetwork</code>: Whether host networking is enabled for the rgw daemon. If not set, the network settings from the cluster CR will be applied.</li> <li><code>port</code>: The port on which the Object service will be reachable. If host networking is enabled, the RGW daemons will also listen on that port. If running on SDN, the RGW daemon listening port will be 8080 internally.</li> <li><code>securePort</code>: The secure port on which RGW pods will be listening. A TLS certificate must be     specified either via <code>sslCerticateRef</code> or <code>service.annotations</code>. Refer to     enabling TLS     documentation for more details.</li> <li><code>instances</code>: The number of pods that will be started to load balance this object store.</li> <li> <p><code>externalRgwEndpoints</code>: A list of IP addresses to connect to external existing Rados Gateways     (works with external mode). This setting will be ignored if the <code>CephCluster</code> does not have     <code>external</code> spec enabled. Refer to the external cluster section     for more details. Multiple endpoints can be given, but for stability of ObjectBucketClaims, we     highly recommend that users give only a single external RGW endpoint that is a load balancer that     sends requests to the multiple RGWs.</p> <p>Example of external rgw endpoints to connect to:</p> <pre><code>gateway:\nport: 80\nexternalRgwEndpoints:\n  - ip: 192.168.39.182\n    # hostname: example.com\n</code></pre> </li> <li> <p><code>annotations</code>: Key value pair list of annotations to add.</p> </li> <li><code>labels</code>: Key value pair list of labels to add.</li> <li><code>placement</code>: The Kubernetes placement settings to determine where the RGW pods should be started in the cluster.</li> <li><code>resources</code>: Set resource requests/limits for the Gateway Pod(s), see Resource Requirements/Limits.</li> <li><code>priorityClassName</code>: Set priority class name for the Gateway Pod(s)</li> <li><code>additionalVolumeMounts</code>: additional volumes to be mounted to the RGW pod. The root directory for     each additional volume mount is <code>/var/rgw</code>. Each volume mount has a <code>subPath</code> that defines the     subdirectory where that volumes files will be mounted. Rook supports several standard Kubernetes     volume types. Example: for an additional mount at subPath <code>ldap</code>, mounted from a secret that has     key <code>bindpass.secret</code>, the file would reside at <code>/var/rgw/ldap/bindpass.secret</code>.</li> <li> <p><code>service</code>: The annotations to set on to the Kubernetes Service of RGW. The service serving cert feature supported in Openshift is enabled by the following example:</p> <pre><code>gateway:\nservice:\n  annotations:\n  service.beta.openshift.io/serving-cert-secret-name: &lt;name of TLS secret for automatic generation&gt;\n</code></pre> </li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#zone-settings","title":"Zone Settings","text":"<p>The zone settings allow the object store to join custom created ceph-object-zone.</p> <ul> <li><code>name</code>: the name of the ceph-object-zone the object store will be in.</li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#hosting-settings","title":"Hosting Settings","text":"<p><code>hosting</code> settings allow specifying object store endpoint configurations. These settings are only supported for Ceph v18 and higher.</p> <p>A common use case that requires configuring hosting is allowing virtual host-style bucket access. This use case is discussed in more detail in Rook object storage docs.</p> <ul> <li><code>advertiseEndpoint</code>: By default, Rook advertises the most direct connection to RGWs to dependent     resources like CephObjectStoreUsers and ObjectBucketClaims. To advertise a different address     (e.g., a wildcard-enabled ingress), define the preferred endpoint here. Default behavior is     documented in more detail here<ul> <li><code>dnsName</code>: The valid RFC-1123 (sub)domain name of the endpoint.</li> <li><code>port</code>: The nonzero port of the endpoint.</li> <li><code>useTls</code>: Set to true if the endpoint is HTTPS. False if HTTP.</li> </ul> </li> <li><code>dnsNames</code>: When this or <code>advertiseEndpoint</code> is set, Ceph RGW will reject S3 client connections     who attempt to reach the object store via any unspecified DNS name. Add all DNS names that the     object store should accept here. These must be valid RFC-1123 (sub)domain names.     Rook automatically adds the known CephObjectStore service DNS name to this list, as well as     corresponding CephObjectZone <code>customEndpoints</code> (if applicable).</li> </ul> <p>Note</p> <p>For DNS names that support wildcards, do not include wildcards. E.g., use <code>mystore.example.com</code> instead of <code>*.mystore.example.com</code>.</p>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#runtime-settings","title":"Runtime settings","text":""},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#mime-types","title":"MIME types","text":"<p>Rook provides a default <code>mime.types</code> file for each Ceph object store. This file is stored in a Kubernetes ConfigMap with the name <code>rook-ceph-rgw-&lt;STORE-NAME&gt;-mime-types</code>. For most users, the default file should suffice, however, the option is available to users to edit the <code>mime.types</code> file in the ConfigMap as they desire. Users may have their own special file types, and particularly security conscious users may wish to pare down the file to reduce the possibility of a file type execution attack.</p> <p>Rook will not overwrite an existing <code>mime.types</code> ConfigMap so that user modifications will not be destroyed. If the object store is destroyed and recreated, the ConfigMap will also be destroyed and created anew.</p>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#health-settings","title":"Health settings","text":"<p>Rook will be default monitor the state of the object store endpoints. The following CRD settings are available:</p> <ul> <li><code>healthCheck</code>: main object store health monitoring section<ul> <li><code>startupProbe</code>: Disable, or override timing and threshold values of the object gateway startup probe.</li> <li><code>readinessProbe</code>: Disable, or override timing and threshold values of the object gateway readiness probe.</li> </ul> </li> </ul> <p>Here is a complete example:</p> <pre><code>healthCheck:\n  startupProbe:\n    disabled: false\n  readinessProbe:\n    disabled: false\n    periodSeconds: 5\n    failureThreshold: 2\n</code></pre> <p>You can monitor the health of a CephObjectStore by monitoring the gateway deployments it creates. The primary deployment created is named <code>rook-ceph-rgw-&lt;store-name&gt;-a</code> where <code>store-name</code> is the name of the CephObjectStore (don't forget the <code>-a</code> at the end).</p>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#security-settings","title":"Security settings","text":"<p>Ceph RGW supports Server Side Encryption as defined in AWS S3 protocol with three different modes: AWS-SSE:C, AWS-SSE:KMS and AWS-SSE:S3. The last two modes require a Key Management System (KMS) like HashiCorp Vault. Currently, Vault is the only supported KMS backend for CephObjectStore.</p> <p>Refer to the Vault KMS section for details about Vault. If these settings are defined, then RGW will establish a connection between Vault and whenever S3 client sends request with Server Side Encryption. Ceph's Vault documentation has more details.</p> <p>The <code>security</code> section contains settings related to KMS encryption of the RGW.</p> <pre><code>security:\n  kms:\n    connectionDetails:\n      KMS_PROVIDER: vault\n      VAULT_ADDR: http://vault.default.svc.cluster.local:8200\n      VAULT_BACKEND_PATH: rgw\n      VAULT_SECRET_ENGINE: kv\n      VAULT_BACKEND: v2\n    # name of the k8s secret containing the kms authentication token\n    tokenSecretName: rgw-vault-kms-token\n  s3:\n    connectionDetails:\n      KMS_PROVIDER: vault\n      VAULT_ADDR: http://vault.default.svc.cluster.local:8200\n      VAULT_BACKEND_PATH: rgw\n      VAULT_SECRET_ENGINE: transit\n    # name of the k8s secret containing the kms authentication token\n    tokenSecretName: rgw-vault-s3-token\n</code></pre> <p>For RGW, please note the following:</p> <ul> <li><code>VAULT_SECRET_ENGINE</code>: the secret engine which Vault should use. Currently supports kv and transit. AWS-SSE:KMS supports <code>transit</code> engine and <code>kv</code> engine version 2. AWS-SSE:S3 only supports <code>transit</code> engine.</li> <li>The Storage administrator needs to create a secret in the Vault server so that S3 clients use that key for encryption for AWS-SSE:KMS</li> </ul> <pre><code>vault kv put rook/&lt;mybucketkey&gt; key=$(openssl rand -base64 32) # kv engine\nvault write -f transit/keys/&lt;mybucketkey&gt; exportable=true # transit engine\n</code></pre> <ul> <li><code>tokenSecretName</code> can be (and often will be) the same for both kms and s3 configurations.</li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-store-crd/#deleting-a-cephobjectstore","title":"Deleting a CephObjectStore","text":"<p>During deletion of a CephObjectStore resource, Rook protects against accidental or premature destruction of user data by blocking deletion if there are any object buckets in the object store being deleted. Buckets may have been created by users or by ObjectBucketClaims.</p> <p>For deletion to be successful, all buckets in the object store must be removed. This may require manual deletion or removal of all ObjectBucketClaims. Alternately, the <code>cephobjectstore.ceph.rook.io</code> finalizer on the CephObjectStore can be removed to remove the Kubernetes Custom Resource, but the Ceph pools which store the data will not be removed in this case.</p> <p>Rook will warn about which buckets are blocking deletion in three ways:</p> <ol> <li>An event will be registered on the CephObjectStore resource</li> <li>A status condition will be added to the CephObjectStore resource</li> <li>An error will be added to the Rook Ceph Operator log</li> </ol> <p>If the CephObjectStore is configured in a multisite setup the above conditions are applicable only to stores that belong to a single master zone. Otherwise the conditions are ignored. Even if the store is removed the user can access the data from a peer object store.</p>"},{"location":"CRDs/Object-Storage/ceph-object-store-user-crd/","title":"CephObjectStoreUser CRD","text":"<p>Rook allows creation and customization of object store users through the custom resource definitions (CRDs). The following settings are available for Ceph object store users.</p>"},{"location":"CRDs/Object-Storage/ceph-object-store-user-crd/#example","title":"Example","text":"<pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectStoreUser\nmetadata:\n  name: my-user\n  namespace: rook-ceph\nspec:\n  store: my-store\n  displayName: my-display-name\n  quotas:\n    maxBuckets: 100\n    maxSize: 10G\n    maxObjects: 10000\n  capabilities:\n    user: \"*\"\n    bucket: \"*\"\n</code></pre>"},{"location":"CRDs/Object-Storage/ceph-object-store-user-crd/#object-store-user-settings","title":"Object Store User Settings","text":""},{"location":"CRDs/Object-Storage/ceph-object-store-user-crd/#metadata","title":"Metadata","text":"<ul> <li><code>name</code>: The name of the object store user to create, which will be reflected in the secret and other resource names.</li> <li><code>namespace</code>: The namespace of the Rook cluster where the object store user is created.</li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-store-user-crd/#spec","title":"Spec","text":"<ul> <li><code>store</code>: The object store in which the user will be created. This matches the name of the objectstore CRD.</li> <li><code>displayName</code>: The display name which will be passed to the <code>radosgw-admin user create</code> command.</li> <li><code>clusterNamespace</code>: The namespace where the parent CephCluster and CephObjectStore are found. If not specified,     the user must be in the same namespace as the cluster and object store.     To enable this feature, the CephObjectStore allowUsersInNamespaces must include the namespace of this user.</li> <li><code>quotas</code>: This represents quota limitation can be set on the user. Please refer here for details.<ul> <li><code>maxBuckets</code>: The maximum bucket limit for the user.</li> <li><code>maxSize</code>: Maximum size limit of all objects across all the user's buckets.</li> <li><code>maxObjects</code>: Maximum number of objects across all the user's buckets.</li> </ul> </li> <li><code>capabilities</code>: Ceph allows users to be given additional permissions. Due to missing APIs in go-ceph for updating the user capabilities, this setting can currently only be used during the creation of the object store user. If a user's capabilities need modified, the user must be deleted and re-created.     See the Ceph docs for more info.     Rook supports adding <code>read</code>, <code>write</code>, <code>read, write</code>, or <code>*</code> permissions for the following resources:<ul> <li><code>user</code></li> <li><code>buckets</code></li> <li><code>usage</code></li> <li><code>metadata</code></li> <li><code>zone</code></li> <li><code>roles</code></li> <li><code>info</code></li> <li><code>amz-cache</code></li> <li><code>bilog</code></li> <li><code>mdlog</code></li> <li><code>datalog</code></li> <li><code>user-policy</code></li> <li><code>odic-provider</code></li> <li><code>ratelimit</code></li> </ul> </li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-zone-crd/","title":"CephObjectZone CRD","text":"<p>Rook allows creation of zones in a ceph cluster for a Ceph Object Multisite configuration through a CRD. The following settings are available for Ceph object store zones.</p>"},{"location":"CRDs/Object-Storage/ceph-object-zone-crd/#example","title":"Example","text":"<pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectZone\nmetadata:\n  name: zone-a\n  namespace: rook-ceph\nspec:\n  zoneGroup: zonegroup-a\n  metadataPool:\n    failureDomain: host\n    replicated:\n      size: 3\n  dataPool:\n    failureDomain: osd\n    erasureCoded:\n      dataChunks: 2\n      codingChunks: 1\n  customEndpoints:\n    - \"http://rgw-a.fqdn\"\n  preservePoolsOnDelete: true\n</code></pre>"},{"location":"CRDs/Object-Storage/ceph-object-zone-crd/#settings","title":"Settings","text":""},{"location":"CRDs/Object-Storage/ceph-object-zone-crd/#metadata","title":"Metadata","text":"<ul> <li><code>name</code>: The name of the object zone to create</li> <li><code>namespace</code>: The namespace of the Rook cluster where the object zone is created.</li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-zone-crd/#pools","title":"Pools","text":"<p>The pools allow all of the settings defined in the Pool CRD spec. For more details, see the Pool CRD settings. In the example above, there must be at least three hosts (size 3) and at least three devices (2 data + 1 coding chunks) in the cluster.</p>"},{"location":"CRDs/Object-Storage/ceph-object-zone-crd/#spec","title":"Spec","text":"<ul> <li><code>zonegroup</code>: The object zonegroup in which the zone will be created. This matches the name of the object zone group CRD.</li> <li><code>metadataPool</code>: The settings used to create all of the object store metadata pools. Must use replication.</li> <li><code>dataPool</code>: The settings to create the object store data pool. Can use replication or erasure coding.</li> <li> <p><code>customEndpoints</code>:  Specify the endpoint(s) that will accept multisite replication traffic for this zone. You may include the port in the definition if necessary. For example: \"https://my-object-store.my-domain.net:443\". By default, Rook will set this to the DNS name of the ClusterIP Service created for the CephObjectStore that corresponds to this zone.</p> <p>Most multisite configurations will not exist within the same Kubernetes cluster, meaning the default value will not be useful. In these cases, you will be required to create your own custom ingress resource for the CephObjectStore in order to make the zone available for replication. You must add the endpoint for your custom ingress resource to this list to allow the store to accept replication traffic.</p> <p>In the case of multiple stores (or multiple endpoints for a single store), you are not required to put all endpoints in this list. Only specify the endpoints that should be used for replication traffic.</p> <p>If you update <code>customEndpoints</code> to return to an empty list, you must the Rook operator to automatically add the CephObjectStore service endpoint to Ceph's internal configuration.</p> </li> <li> <p><code>preservePoolsOnDelete</code>: If it is set to 'true' the pools used to support the CephObjectZone will remain when it is deleted. This is a security measure to avoid accidental loss of data. It is set to 'true' by default.</p> <p>It is better to check whether data synced with other peer zones before triggering the deletion to avoid accidental loss of data via steps mentioned here</p> <p>When deleting a CephObjectZone, deletion will be blocked until all <code>CephObjectStores</code> belonging to the zone are removed.</p> </li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-zonegroup-crd/","title":"CephObjectZoneGroup CRD","text":"<p>Rook allows creation of zone groups in a Ceph Object Multisite configuration through a CRD. The following settings are available for Ceph object store zone groups.</p>"},{"location":"CRDs/Object-Storage/ceph-object-zonegroup-crd/#example","title":"Example","text":"<pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectZoneGroup\nmetadata:\n  name: zonegroup-a\n  namespace: rook-ceph\nspec:\n  realm: realm-a\n</code></pre>"},{"location":"CRDs/Object-Storage/ceph-object-zonegroup-crd/#settings","title":"Settings","text":""},{"location":"CRDs/Object-Storage/ceph-object-zonegroup-crd/#metadata","title":"Metadata","text":"<ul> <li><code>name</code>: The name of the object zone group to create</li> <li><code>namespace</code>: The namespace of the Rook cluster where the object zone group is created.</li> </ul>"},{"location":"CRDs/Object-Storage/ceph-object-zonegroup-crd/#spec","title":"Spec","text":"<ul> <li><code>realm</code>: The object realm in which the zone group will be created. This matches the name of the object realm CRD.</li> </ul>"},{"location":"CRDs/Shared-Filesystem/ceph-filesystem-crd/","title":"CephFilesystem CRD","text":"<p>Rook allows creation and customization of shared filesystems through the custom resource definitions (CRDs). The following settings are available for Ceph filesystems.</p>"},{"location":"CRDs/Shared-Filesystem/ceph-filesystem-crd/#examples","title":"Examples","text":""},{"location":"CRDs/Shared-Filesystem/ceph-filesystem-crd/#replicated","title":"Replicated","text":"<p>Note</p> <p>This sample requires at least 1 OSD per node, with each OSD located on 3 different nodes.</p> <p>Each OSD must be located on a different node, because both of the defined pools set the <code>failureDomain</code> to <code>host</code> and the <code>replicated.size</code> to <code>3</code>.</p> <p>The <code>failureDomain</code> can also be set to another location type (e.g. <code>rack</code>), if it has been added as a <code>location</code> in the Storage Selection Settings.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephFilesystem\nmetadata:\n  name: myfs\n  namespace: rook-ceph\nspec:\n  metadataPool:\n    failureDomain: host\n    replicated:\n      size: 3\n  dataPools:\n    - name: replicated\n      failureDomain: host\n      replicated:\n        size: 3\n  preserveFilesystemOnDelete: true\n  metadataServer:\n    activeCount: 1\n    activeStandby: true\n    # A key/value list of annotations\n    annotations:\n    #  key: value\n    placement:\n    #  nodeAffinity:\n    #    requiredDuringSchedulingIgnoredDuringExecution:\n    #      nodeSelectorTerms:\n    #      - matchExpressions:\n    #        - key: role\n    #          operator: In\n    #          values:\n    #          - mds-node\n    #  tolerations:\n    #  - key: mds-node\n    #    operator: Exists\n    #  podAffinity:\n    #  podAntiAffinity:\n    #  topologySpreadConstraints:\n    resources:\n    #  limits:\n    #    memory: \"1024Mi\"\n    #  requests:\n    #    cpu: \"500m\"\n    #    memory: \"1024Mi\"\n</code></pre> <p>(These definitions can also be found in the <code>filesystem.yaml</code> file)</p>"},{"location":"CRDs/Shared-Filesystem/ceph-filesystem-crd/#erasure-coded","title":"Erasure Coded","text":"<p>Erasure coded pools require the OSDs to use <code>bluestore</code> for the configured <code>storeType</code>. Additionally, erasure coded pools can only be used with <code>dataPools</code>. The <code>metadataPool</code> must use a replicated pool.</p> <p>Note</p> <p>This sample requires at least 3 bluestore OSDs, with each OSD located on a different node.</p> <p>The OSDs must be located on different nodes, because the <code>failureDomain</code> will be set to <code>host</code> by default, and the <code>erasureCoded</code> chunk settings require at least 3 different OSDs (2 <code>dataChunks</code> + 1 <code>codingChunks</code>).</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephFilesystem\nmetadata:\n  name: myfs-ec\n  namespace: rook-ceph\nspec:\n  metadataPool:\n    replicated:\n      size: 3\n  dataPools:\n    - name: default\n      replicated:\n        size: 3\n    - name: erasurecoded\n      erasureCoded:\n        dataChunks: 2\n        codingChunks: 1\n  metadataServer:\n    activeCount: 1\n    activeStandby: true\n</code></pre> <p>IMPORTANT: For erasure coded pools, we have to create a replicated pool as the default data pool and an erasure-coded pool as a secondary pool.</p> <p>(These definitions can also be found in the <code>filesystem-ec.yaml</code> file. Also see an example in the <code>storageclass-ec.yaml</code> for how to configure the volume.)</p>"},{"location":"CRDs/Shared-Filesystem/ceph-filesystem-crd/#filesystem-settings","title":"Filesystem Settings","text":""},{"location":"CRDs/Shared-Filesystem/ceph-filesystem-crd/#metadata","title":"Metadata","text":"<ul> <li><code>name</code>: The name of the filesystem to create, which will be reflected in the pool and other resource names.</li> <li><code>namespace</code>: The namespace of the Rook cluster where the filesystem is created.</li> </ul>"},{"location":"CRDs/Shared-Filesystem/ceph-filesystem-crd/#pools","title":"Pools","text":"<p>The pools allow all of the settings defined in the Pool CRD spec. For more details, see the Pool CRD settings. In the example above, there must be at least three hosts (size 3) and at least eight devices (6 data + 2 coding chunks) in the cluster.</p> <ul> <li><code>metadataPool</code>: The settings used to create the filesystem metadata pool. Must use replication.<ul> <li><code>name</code>: (optional) Override the default generated name of the metadata pool.</li> </ul> </li> <li><code>dataPools</code>: The settings to create the filesystem data pools. Optionally (and we highly recommend), a pool name can be specified with the <code>name</code> field to override the default generated name; see more below. If multiple pools are specified, Rook will add the pools to the filesystem. Assigning users or files to a pool is left as an exercise for the reader with the CephFS documentation. The data pools can use replication or erasure coding. If erasure coding pools are specified, the cluster must be running with bluestore enabled on the OSDs.<ul> <li><code>name</code>: (optional, and highly recommended) Override the default generated name of the pool. We highly recommend to specify <code>name</code> to prevent issues that can arise from modifying the spec in a way that causes Rook to lose the original pool ordering.</li> </ul> </li> <li><code>preservePoolNames</code>: Preserve pool names as specified.</li> <li><code>preserveFilesystemOnDelete</code>: If it is set to 'true' the filesystem will remain when the     CephFilesystem resource is deleted. This is a security measure to avoid loss of data if the     CephFilesystem resource is deleted accidentally. The default value is 'false'. This option     replaces <code>preservePoolsOnDelete</code> which should no longer be set.</li> <li>(deprecated) <code>preservePoolsOnDelete</code>: This option is replaced by the above     <code>preserveFilesystemOnDelete</code>. For backwards compatibility and upgradeability, if this is set to     'true', Rook will treat <code>preserveFilesystemOnDelete</code> as being set to 'true'.</li> </ul>"},{"location":"CRDs/Shared-Filesystem/ceph-filesystem-crd/#generated-pool-names","title":"Generated Pool Names","text":"<p>Both <code>metadataPool</code> and <code>dataPools</code> support defining names as required. The final pool name will consist of the filesystem name and pool name, e.g., <code>&lt;fsName&gt;-&lt;poolName&gt;</code> or <code>&lt;fsName&gt;-metadata</code> for <code>metadataPool</code>. For more granular configuration you may want to set <code>preservePoolNames</code> to <code>true</code> in <code>pools</code> to disable generation of names. In that case all pool names defined are used as given.</p>"},{"location":"CRDs/Shared-Filesystem/ceph-filesystem-crd/#metadata-server-settings","title":"Metadata Server Settings","text":"<p>The metadata server settings correspond to the MDS daemon settings.</p> <ul> <li><code>activeCount</code>: The number of active MDS instances. As load increases, CephFS will automatically partition the filesystem across the MDS instances. Rook will create double the number of MDS instances as requested by the active count. The extra instances will be in standby mode for failover.</li> <li><code>activeStandby</code>: If true, the extra MDS instances will be in active standby mode and will keep a warm cache of the filesystem metadata for faster failover. The instances will be assigned by CephFS in failover pairs. If false, the extra MDS instances will all be on passive standby mode and will not maintain a warm cache of the metadata.</li> <li><code>mirroring</code>: Sets up mirroring of the filesystem<ul> <li><code>enabled</code>: whether mirroring is enabled on that filesystem (default: false)</li> <li><code>peers</code>: to configure mirroring peers<ul> <li><code>secretNames</code>:  a list of peers to connect to. Currently (Ceph Pacific release) only a single peer is supported where a peer represents a Ceph cluster.</li> </ul> </li> <li><code>snapshotSchedules</code>: schedule(s) snapshot.One or more schedules are supported.<ul> <li><code>path</code>: filesystem source path to take the snapshot on</li> <li><code>interval</code>: frequency of the snapshots. The interval can be specified in days, hours, or minutes using d, h, m suffix respectively.</li> <li><code>startTime</code>: optional, determines at what time the snapshot process starts, specified using the ISO 8601 time format.</li> </ul> </li> <li><code>snapshotRetention</code>: allow to manage retention policies:<ul> <li><code>path</code>: filesystem source path to apply the retention on</li> <li><code>duration</code>:</li> </ul> </li> </ul> </li> <li><code>annotations</code>: Key value pair list of annotations to add.</li> <li><code>labels</code>: Key value pair list of labels to add.</li> <li><code>placement</code>: The mds pods can be given standard Kubernetes placement restrictions with <code>nodeAffinity</code>, <code>tolerations</code>, <code>podAffinity</code>, and <code>podAntiAffinity</code> similar to placement defined for daemons configured by the cluster CRD.</li> <li><code>resources</code>: Set resource requests/limits for the Filesystem MDS Pod(s), see MDS Resources Configuration Settings</li> <li><code>priorityClassName</code>: Set priority class name for the Filesystem MDS Pod(s)</li> <li><code>startupProbe</code> : Disable, or override timing and threshold values of the Filesystem MDS startup probe</li> <li><code>livenessProbe</code> : Disable, or override timing and threshold values of the Filesystem MDS livenessProbe.</li> </ul>"},{"location":"CRDs/Shared-Filesystem/ceph-filesystem-crd/#mds-resources-configuration-settings","title":"MDS Resources Configuration Settings","text":"<p>The format of the resource requests/limits structure is the same as described in the Ceph Cluster CRD documentation.</p> <p>If the memory resource limit is declared Rook will automatically set the MDS configuration <code>mds_cache_memory_limit</code>. The configuration value is calculated with the aim that the actual MDS memory consumption remains consistent with the MDS pods' resource declaration.</p> <p>In order to provide the best possible experience running Ceph in containers, Rook internally recommends the memory for MDS daemons to be at least 4096MB. If a user configures a limit or request value that is too low, Rook will still run the pod(s) and print a warning to the operator log.</p>"},{"location":"CRDs/Shared-Filesystem/ceph-fs-mirror-crd/","title":"CephFilesystemMirror CRD","text":"<p>This guide assumes you have created a Rook cluster as explained in the main Quickstart guide</p> <p>Rook allows creation and updating the fs-mirror daemon through the custom resource definitions (CRDs). CephFS will support asynchronous replication of snapshots to a remote (different Ceph cluster) CephFS file system via cephfs-mirror tool. Snapshots are synchronized by mirroring snapshot data followed by creating a snapshot with the same name (for a given directory on the remote file system) as the snapshot being synchronized. For more information about user management and capabilities see the Ceph docs.</p>"},{"location":"CRDs/Shared-Filesystem/ceph-fs-mirror-crd/#creating-daemon","title":"Creating daemon","text":"<p>To get you started, here is a simple example of a CRD to deploy an cephfs-mirror daemon.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephFilesystemMirror\nmetadata:\n  name: my-fs-mirror\n  namespace: rook-ceph\nspec: {}\n</code></pre>"},{"location":"CRDs/Shared-Filesystem/ceph-fs-mirror-crd/#settings","title":"Settings","text":"<p>If any setting is unspecified, a suitable default will be used automatically.</p>"},{"location":"CRDs/Shared-Filesystem/ceph-fs-mirror-crd/#filesystemmirror-metadata","title":"FilesystemMirror metadata","text":"<ul> <li><code>name</code>: The name that will be used for the Ceph cephfs-mirror daemon.</li> <li><code>namespace</code>: The Kubernetes namespace that will be created for the Rook cluster. The services, pods, and other resources created by the operator will be added to this namespace.</li> </ul>"},{"location":"CRDs/Shared-Filesystem/ceph-fs-mirror-crd/#filesystemmirror-settings","title":"FilesystemMirror Settings","text":"<ul> <li><code>placement</code>: The cephfs-mirror pods can be given standard Kubernetes placement restrictions with <code>nodeAffinity</code>, <code>tolerations</code>, <code>podAffinity</code>, and <code>podAntiAffinity</code> similar to placement defined for daemons configured by the cluster CRD.</li> <li><code>annotations</code>: Key value pair list of annotations to add.</li> <li><code>labels</code>: Key value pair list of labels to add.</li> <li><code>resources</code>: The resource requirements for the cephfs-mirror pods.</li> <li><code>priorityClassName</code>: The priority class to set on the cephfs-mirror pods.</li> </ul>"},{"location":"CRDs/Shared-Filesystem/ceph-fs-mirror-crd/#configuring-mirroring-peers","title":"Configuring mirroring peers","text":"<p>In order to configure mirroring peers, please refer to the CephFilesystem documentation.</p>"},{"location":"CRDs/Shared-Filesystem/ceph-fs-subvolumegroup-crd/","title":"FilesystemSubVolumeGroup CRD","text":"<p>Info</p> <p>This guide assumes you have created a Rook cluster as explained in the main Quickstart guide</p> <p>Rook allows creation of Ceph Filesystem SubVolumeGroups through the custom resource definitions (CRDs). Filesystem subvolume groups are an abstraction for a directory level higher than Filesystem subvolumes to effect policies (e.g., File layouts) across a set of subvolumes. For more information about CephFS volume, subvolumegroup and subvolume refer to the Ceph docs.</p>"},{"location":"CRDs/Shared-Filesystem/ceph-fs-subvolumegroup-crd/#creating-daemon","title":"Creating daemon","text":"<p>To get you started, here is a simple example of a CRD to create a subvolumegroup on the CephFilesystem \"myfs\".</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephFilesystemSubVolumeGroup\nmetadata:\n  name: group-a\n  namespace: rook-ceph # namespace:cluster\nspec:\n  # The name of the subvolume group. If not set, the default is the name of the subvolumeGroup CR.\n  name: csi\n  # filesystemName is the metadata name of the CephFilesystem CR where the subvolume group will be created\n  filesystemName: myfs\n  # reference https://docs.ceph.com/en/latest/cephfs/fs-volumes/#pinning-subvolumes-and-subvolume-groups\n  # only one out of (export, distributed, random) can be set at a time\n  # by default pinning is set with value: distributed=1\n  # for disabling default values set (distributed=0)\n  pinning:\n    distributed: 1            # distributed=&lt;0, 1&gt; (disabled=0)\n    # export:                 # export=&lt;0-256&gt; (disabled=-1)\n    # random:                 # random=[0.0, 1.0](disabled=0.0)\n  # Quota size of the subvolume group.\n  #quota: 10G\n  # data pool name for the subvolume group layout instead of the default data pool.\n  #dataPoolName: myfs-replicated\n</code></pre>"},{"location":"CRDs/Shared-Filesystem/ceph-fs-subvolumegroup-crd/#settings","title":"Settings","text":"<p>If any setting is unspecified, a suitable default will be used automatically.</p>"},{"location":"CRDs/Shared-Filesystem/ceph-fs-subvolumegroup-crd/#cephfilesystemsubvolumegroup-metadata","title":"CephFilesystemSubVolumeGroup metadata","text":"<ul> <li><code>name</code>: The name that will be used for the Ceph Filesystem subvolume group.</li> </ul>"},{"location":"CRDs/Shared-Filesystem/ceph-fs-subvolumegroup-crd/#cephfilesystemsubvolumegroup-spec","title":"CephFilesystemSubVolumeGroup spec","text":"<ul> <li> <p><code>name</code>: The spec name that will be used for the Ceph Filesystem subvolume group if not set metadata name will be used.</p> </li> <li> <p><code>filesystemName</code>: The metadata name of the CephFilesystem CR where the subvolume group will be created.</p> </li> <li> <p><code>quota</code>: Quota size of the Ceph Filesystem subvolume group.</p> </li> <li> <p><code>dataPoolName</code>: The data pool name for the subvolume group layout instead of the default data pool.</p> </li> <li> <p><code>pinning</code>: To distribute load across MDS ranks in predictable and stable ways. See the Ceph doc for Pinning subvolume groups.</p> <ul> <li><code>distributed</code>: Range: &lt;0, 1&gt;, for disabling it set to 0</li> <li><code>export</code>: Range: &lt;0-256&gt;, for disabling it set to -1</li> <li><code>random</code>: Range: [0.0, 1.0], for disabling it set to 0.0</li> </ul> </li> </ul> <p>Note</p> <p>Only one out of (export, distributed, random) can be set at a time. By default pinning is set with value: <code>distributed=1</code>.</p>"},{"location":"Contributing/ci-configuration/","title":"CI Configuration","text":"<p>This page contains information regarding the CI configuration used for the Rook project to test, build and release the project.</p>"},{"location":"Contributing/ci-configuration/#secrets","title":"Secrets","text":"<ul> <li>Snyk (Security Scan):<ul> <li><code>SNYK_TOKEN</code> - API Token for the snyk security scanner (workflow file: <code>snyk.yaml</code>).</li> </ul> </li> <li>Testing:<ul> <li><code>IBM_INSTANCE_ID</code>: Used for KMS (Key Management System) IBM Key Protect access (see <code>.github/workflows/encryption-pvc-kms-ibm-kp/action.yml</code>).</li> <li><code>IBM_SERVICE_API_KEY</code>: Used for KMS (Key Management System) IBM Key Protect access (see <code>.github/workflows/encryption-pvc-kms-ibm-kp/action.yml</code>).</li> </ul> </li> <li>Publishing:<ul> <li><code>DOCKER_USERNAME</code> + <code>DOCKER_PASSWORD</code>: Username and password of registry.</li> <li><code>DOCKER_REGISTRY</code>: Target registry namespace (e.g., <code>rook</code>)</li> <li><code>AWS_USR</code> + <code>AWS_PSW</code>: AWS credentials with access to S3 for Helm chart publishing.</li> <li><code>GIT_API_TOKEN</code>: GitHub access token, used to push docs changes to the docs repositories <code>gh-pages</code> branch.</li> </ul> </li> </ul>"},{"location":"Contributing/development-environment/","title":"Developer Environment","text":""},{"location":"Contributing/development-environment/#install-kubernetes","title":"Install Kubernetes","text":"<p>You can choose any Kubernetes install of your choice. The test framework only depends on <code>kubectl</code> being configured. To install <code>kubectl</code>, please see the official guide.</p>"},{"location":"Contributing/development-environment/#minikube","title":"Minikube","text":"<p>The developers of Rook are working on Minikube and thus it is the recommended way to quickly get Rook up and running. Minikube should not be used for production but the Rook authors consider it great for development. While other tools such as k3d/kind are great, users have faced issues deploying Rook.</p> <p>Always use a virtual machine when testing Rook. Never use your host system where local devices may mistakenly be consumed.</p> <p>To install Minikube follow the official guide. It is recommended to use the kvm2 driver when running on a Linux machine and the hyperkit driver when running on a MacOS. Both allow to create and attach additional disks to the virtual machine. This is required for the Ceph OSD to consume one drive.  We don't recommend any other drivers for Rook. You will need a Minikube version 1.23 or higher.</p> <p>Starting the cluster on Minikube is as simple as running:</p> <pre><code># On Linux\nminikube start --disk-size=40g --extra-disks=1 --driver kvm2\n\n# On MacOS with Intel processor\nminikube start --disk-size=40g --extra-disks=1 --driver hyperkit\n\n# On MacOS with Apple silicon\nminikube start --disk-size=40g --extra-disks 1 --driver qemu\n</code></pre> <p>It is recommended to install a Docker client on your host system too. Depending on your operating system follow the official guide.</p> <p>Stopping the cluster and destroying the Minikube virtual machine can be done with:</p> <pre><code>minikube delete\n</code></pre>"},{"location":"Contributing/development-environment/#install-helm","title":"Install Helm","text":"<p>Use helm.sh to install Helm and set up Rook charts defined under <code>_output/charts</code> (generated by build):</p> <ul> <li>To install and set up Helm charts for Rook run <code>tests/scripts/helm.sh up</code>.</li> <li>To clean up <code>tests/scripts/helm.sh clean</code>.</li> </ul> <p>Note</p> <p>These helper scripts depend on some artifacts under the <code>_output/</code> directory generated during build time. These scripts should be run from the project root.</p> <p>Note</p> <p>If Helm is not available in your <code>PATH</code>, Helm will be downloaded to a temporary directory (<code>/tmp/rook-tests-scripts-helm</code>) and used from that directory.</p>"},{"location":"Contributing/development-environment/#using-local-rook-image-on-minikube-cluster","title":"Using local Rook image on minikube cluster","text":"<p>Developers can test quickly their changes by building and using the local Rook image on their minikube cluster.</p> <p>1) Set the local Docker environment to use minikube:</p> <pre><code>```console\neval $(minikube docker-env -p minikube)\n```\n</code></pre> <p>2) Build your local Rook image. The following command will generate a Rook image labeled in the format <code>local/ceph-&lt;arch&gt;</code>.</p> <pre><code>```console\ncd &lt;your_rook_src_directory&gt;\nmake BUILD_REGISTRY=local\n```\n</code></pre> <p>3) Tag the generated image as <code>rook/ceph:master</code> so operator will pick it.</p> <pre><code>```console\ndocker tag \"local/ceph-$(go env GOARCH)\" 'rook/ceph:master'\n```\n</code></pre> <p>4) Create a Rook cluster in minikube, or if the Rook cluster is already configured, apply the new operator image by restarting the operator.</p>"},{"location":"Contributing/development-environment/#creating-a-dev-cluster","title":"Creating a dev cluster","text":"<p>To accelerate the development process, users have the option to employ the script located at <code>tests/scripts/create-dev-cluster.sh</code>. This script is designed to rapidly set up a new minikube environment, apply the CRDs and the common file, and then utilize the <code>cluster-test.yaml</code> script to create the Rook cluster. Once setup, users can use the different <code>*-test.yaml</code> files from the <code>deploy/examples/</code> directory to configure their clusters. This script supports the possibility of creating multiple rook clusters running on the same machine by using the option <code>-p &lt;profile-name&gt;</code>.</p>"},{"location":"Contributing/development-flow/","title":"Development Flow","text":"<p>Thank you for your time and effort to help us improve Rook! Here are a few steps to get started. If you have any questions, don't hesitate to reach out to us on our Slack dev channel. Sign up for the Rook Slack here.</p>"},{"location":"Contributing/development-flow/#prerequisites","title":"Prerequisites","text":"<ol> <li>GO 1.22 or greater installed</li> <li>Git client installed</li> <li>GitHub account</li> </ol>"},{"location":"Contributing/development-flow/#initial-setup","title":"Initial Setup","text":""},{"location":"Contributing/development-flow/#create-a-fork","title":"Create a Fork","text":"<p>Navigate to http://github.com/rook/rook and click the \"Fork\" button.</p>"},{"location":"Contributing/development-flow/#clone-your-fork","title":"Clone Your Fork","text":"<p>In a console window:</p> <pre><code># Create the rook repo path\nmkdir -p $GOPATH/src/github.com/rook\n\n# Navigate to the local repo path\ncd $GOPATH/src/github.com/rook\n\n# Clone your fork, where &lt;user&gt; is your GitHub account name\ngit clone https://github.com/&lt;user&gt;/rook.git\n</code></pre>"},{"location":"Contributing/development-flow/#add-upstream-remote","title":"Add Upstream Remote","text":"<p>Add the upstream remote to your local git:</p> <pre><code># Add 'upstream' to the list of remotes\ncd rook\ngit remote add upstream https://github.com/rook/rook.git\n\n# Verify the remote was added\ngit remote -v\n</code></pre> <p>Two remotes should be available: <code>origin</code> and <code>upstream</code>.</p>"},{"location":"Contributing/development-flow/#build","title":"Build","text":"<p>Before building the project, fetch the remotes to synchronize tags.</p> <pre><code># Fetch all remotes\ngit fetch -a\nmake build\n</code></pre> <p>Tip</p> <p>If in a Linux environment and <code>make build</code> command throws an error like <code>unknown revision</code> for some imports, add <code>export GOPROXY=https://proxy.golang.org,direct</code> to <code>~/.bashrc</code>. Reload your environment and confirm with <code>go env</code> that <code>GOPROXY</code> is set.</p> <p>Hint</p> <p>Make will automatically pick up <code>podman</code> if <code>docker</code> packages are not available on your machine.</p>"},{"location":"Contributing/development-flow/#development-settings","title":"Development Settings","text":"<p>For consistent whitespace and other formatting in <code>.go</code> and other source files, apply the following settings in your IDE:</p> <ul> <li>Format with the <code>goreturns</code> tool</li> <li>Trim trailing whitespace</li> <li>Markdown Table of Contents is correctly updated automatically</li> </ul>"},{"location":"Contributing/development-flow/#vs-code","title":"VS Code","text":"<p>Tip</p> <p>VS Code will prompt you automatically with some recommended extensions to install, such as Markdown, Go, YAML validator, and ShellCheck.</p> <p>VS Code will automatically use the recommended settings in the <code>.vscode/settings.json</code> file.</p>"},{"location":"Contributing/development-flow/#self-assign-issue","title":"Self assign Issue","text":"<p>To self-assign an issue that is not yet assigned to anyone else, add a comment in the issue with <code>/assign</code> in the body.</p>"},{"location":"Contributing/development-flow/#layout","title":"Layout","text":"<p>The overall source code layout is summarized:</p> <pre><code>rook\n\u251c\u2500\u2500 build                         # build makefiles and logic to build, publish and release all Rook artifacts\n\u251c\u2500\u2500 deploy\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 charts                    # Helm charts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 rook-ceph\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 rook-ceph-cluster\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 examples                  # Sample manifests to configure the cluster\n\u2502\n\u251c\u2500\u2500 cmd\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 rook                      # Main command entry points for operators and daemons\n\u2502\n\u251c\u2500\u2500 design                        # Design documents\n\u251c\u2500\u2500 Documentation                 # Documentation that is published to rook.io\n\u251c\u2500\u2500 images                        # Rook docker image sources\n\u2502\n\u251c\u2500\u2500 pkg\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 apis\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ceph.rook.io          # ceph specs used in the CRDs\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 client                    # auto-generated strongly typed client code to access Rook APIs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 clusterd\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 daemon                    # daemons for configuring ceph\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ceph\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 discover\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 multus\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 util\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 operator                  # all reconcile logic and custom controllers\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ceph\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 discover\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 k8sutil\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 test\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 util\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 version\n\u2514\u2500\u2500 tests\n \u00a0\u00a0 \u251c\u2500\u2500 framework                 # integration test framework\n\u00a0 \u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 clients\n \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 installer\n \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils\n \u00a0\u00a0 \u251c\u2500\u2500 integration               # integration test cases that will be invoked during golang testing\n \u00a0\u00a0 \u2514\u2500\u2500 scripts                   # scripts for setting up integration and manual testing environments\n</code></pre>"},{"location":"Contributing/development-flow/#development","title":"Development","text":"<p>To submit a change, create a branch in your fork and then submit a pull request (PR) from the branch.</p>"},{"location":"Contributing/development-flow/#design-document","title":"Design Document","text":"<p>For new features of significant scope and complexity, a design document is recommended before work begins on the implementation. Create a design document if:</p> <ul> <li>Adding a new CRD</li> <li>Adding a significant feature.</li> </ul> <p>For smaller, straightforward features and bug fixes, there is no need for a design document. Authoring a design document has many advantages:</p> <ul> <li>Forces the author to think critically about the feature and identify potential issues early in the design</li> <li>Obtain agreement amongst the community before code is written to avoid wasted effort in the wrong direction</li> <li>Newcomers may more quickly understand the feature</li> </ul> <p>Note</p> <p>Writing code to prototype the feature while working on the design may be very useful to help flesh out the approach.</p> <p>A design document should be written as a markdown file in the design folder. Follow the process outlined in the design template. There are many examples of previous design documents in that folder. Submit a pull request for the design to be discussed and approved by the community, just like any other change to the repository.</p>"},{"location":"Contributing/development-flow/#create-a-branch","title":"Create a Branch","text":"<p>From a console, create a new branch based on your fork where changes will be developed:</p> <pre><code># Update the remotes\ngit fetch --all\n\n# Create a new branch that is based off upstream master.  Give it a simple, but descriptive name.\n# Generally it will be two to three words separated by dashes and without numbers.\ngit checkout -b feature-name upstream/master\n</code></pre>"},{"location":"Contributing/development-flow/#updating-your-fork","title":"Updating Your Fork","text":"<p>During the development lifecycle, keep your branch(es) updated with the latest upstream master. As others on the team push changes, rebase your commits on top of the latest. This avoids unnecessary merge commits and keeps the commit history clean.</p> <p>Whenever an update is needed to the local repository, never perform a merge, always rebase. This will avoid merge commits in the git history. If there are any modified files, first stash them with <code>git stash</code>.</p> <pre><code>git fetch --all\ngit rebase upstream/master\n</code></pre> <p>Rebasing is a very powerful feature of Git. You need to understand how it works to avoid risking losing your work. Read about it in the Git documentation. Briefly, rebasing does the following:</p> <ul> <li>\"Unwinds\" the local commits. The local commits are removed temporarily from the history.</li> <li>The latest changes from upstream are added to the history</li> <li>The local commits are re-applied one by one</li> <li>If there are merge conflicts, there will be a prompt to fix them before continuing. Read the output closely. It will instruct how to complete the rebase.</li> <li>When rebasing is completed, all of the commits are restored in the history.</li> </ul>"},{"location":"Contributing/development-flow/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<p>After a feature or bug fix is completed in your branch, open a Pull Request (PR) to the upstream Rook repository.</p> <p>Before opening the PR:</p> <ul> <li>If there are code changes, add unit tests and verify that all unit tests are passing. See Unit Tests below on running unit tests.</li> <li>Rebase on the latest upstream changes</li> </ul>"},{"location":"Contributing/development-flow/#regression-testing","title":"Regression Testing","text":"<p>All pull requests must pass all continuous integration (CI) tests before they can be merged. These tests automatically run against every pull request. The results of these tests along with code review feedback determine whether your request will be merged.</p>"},{"location":"Contributing/development-flow/#unit-tests","title":"Unit Tests","text":"<p>From the root of your local Rook repo execute the following to run all of the unit tests:</p> <pre><code>make test\n</code></pre> <p>Unit tests for individual packages can be run with the standard <code>go test</code> command.</p> <p>To see code coverage on the packages that you changed, view the <code>coverage.html</code> in a browser to inspect your new code.</p> <pre><code>go test -coverprofile=coverage.out\ngo tool cover -html=coverage.out -o coverage.html\n</code></pre>"},{"location":"Contributing/development-flow/#writing-unit-tests","title":"Writing unit tests","text":"<p>Good unit tests start with easily testable code. Small chunks (\"units\") of code can be easily tested for every possible input. Higher-level code units that are built from smaller, already-tested units can more easily verify that the units are combined together correctly.</p> <p>Common cases that may need tests:</p> <ul> <li>the feature is enabled</li> <li>the feature is disabled</li> <li>the feature is only partially enabled, for every possible way it can be partially enabled</li> <li>every error that can be encountered during execution of the feature</li> <li>the feature can be disabled (including partially) after it was enabled</li> <li>the feature can be modified (including partially) after it was enabled</li> <li>if there is a slice/array involved, test length = 0, length = 1, length = 3, length == max, length &gt; max</li> <li>an input is not specified, for each input</li> <li>an input is specified incorrectly, for each input</li> <li>a resource the code relies on doesn't exist, for each dependency</li> </ul>"},{"location":"Contributing/development-flow/#integration-tests","title":"Integration Tests","text":"<p>Rook's upstream continuous integration (CI) tests will run integration tests against your changes automatically.</p>"},{"location":"Contributing/development-flow/#tmate-session","title":"Tmate Session","text":"<p>Integration tests will be run in Github actions. If an integration test fails, enable a tmate session to troubleshoot the issue by one of the following steps:</p> <ul> <li>Restart the CI action and click the \"Enable debug logging\" checkbox from the github UI, or</li> <li>Add the label <code>debug-ci</code> to the PR and push your changes again.</li> </ul> <p>See the action details for an ssh connection to the Github runner.</p>"},{"location":"Contributing/development-flow/#commit-structure","title":"Commit structure","text":"<p>Rook maintainers value clear, lengthy and explanatory commit messages.</p> <p>Requirements for commits:</p> <ul> <li>A commit prefix from the list of known prefixes</li> <li>At least one paragraph that explains the original issue and the changes in the commit</li> <li>The <code>Signed-off-by</code> tag is at the end of the commit message, achieved by committing with <code>git commit -s</code></li> </ul> <p>An example acceptable commit message:</p> <pre><code>component: commit title\n\nThis is the commit message. Here I'm explaining what the bug was along with its root cause.\nThen I'm explaining how I fixed it.\n\nSigned-off-by: FirstName LastName &lt;email address&gt;\n</code></pre>"},{"location":"Contributing/development-flow/#commit-history","title":"Commit History","text":"<p>To prepare your branch to open a PR, the minimal number of logical commits is preferred to maintain a clean commit history. Most commonly a PR will include a single commit where all changes are squashed, although sometimes there will be multiple logical commits.</p> <pre><code># Inspect your commit history to determine if you need to squash commits\ngit log\n</code></pre> <p>To squash multiple commits or make other changes to the commit history, use <code>git rebase</code>:</p> <pre><code>#\n# In this example, the last 5 commits will be opened in the git rebase tool.\ngit rebase -i HEAD~5\n</code></pre> <p>Once your commit history is clean, ensure the branch is rebased on the latest upstream before opening the PR.</p>"},{"location":"Contributing/development-flow/#submitting","title":"Submitting","text":"<p>Go to the Rook github to open the PR. If you have pushed recently to a branch, you will see an obvious link to open the PR. If you have not pushed recently, go to the Pull Request tab and select your fork and branch for the PR.</p> <p>After the PR is open, make changes simply by pushing new commits. The PR will track the changes in your fork and rerun the CI automatically.</p> <p>Always open a pull request against master. Never open a pull request against a released branch (e.g. release-1.2) unless working directly with a maintainer.</p>"},{"location":"Contributing/development-flow/#backporting-to-a-release-branch","title":"Backporting to a Release Branch","text":"<p>The flow for getting a fix into a release branch is:</p> <ol> <li>Open a PR to merge changes to master following the process outlined above</li> <li>Add the backport label to that PR such as backport-release-1.11</li> <li>After the PR is merged to master, the <code>mergify</code> bot will automatically open a PR with the commits backported to the release branch</li> <li>After the CI is green and a maintainer has approved the PR, the bot will automatically merge the backport PR</li> </ol>"},{"location":"Contributing/development-flow/#debugging-issues-in-ceph-manager-modules","title":"Debugging issues in Ceph manager modules","text":"<p>The Ceph manager modules are written in Python and can be individually and dynamically loaded from the manager. We can take advantage of this feature in order to test changes and to debug issues in the modules. This is just a hack to debug any modification in the manager modules.</p> <p>The <code>dashboard</code> and the <code>rook</code> orchestrator modules are the two modules most commonly have modifications that need to be tested.</p> <p>Make modifications directly in the manager module and reload:</p> <ol> <li> <p>Update the cluster so only a single mgr pod is running. Set the <code>mgr.count: 1</code> in the CephCluster CR if it is not already.</p> </li> <li> <p>Shell into the manager container:</p> <pre><code>kubectl exec -n rook-ceph --stdin --tty $(kubectl get pod -n rook-ceph -l ceph_daemon_type=mgr,instance=a  -o jsonpath='{.items[0].metadata.name}') -c mgr  -- /bin/bash\n</code></pre> </li> <li> <p>Make the modifications needed in the required manager module. The manager module source code is found in <code>/usr/share/ceph/mgr/</code>.</p> <p>Note</p> <p>If the manager pod is restarted, all modifications made in the mgr container will be lost</p> </li> <li> <p>Restart the modified manager module to test the modifications:</p> <p>Example for restarting the rook manager module with the kubectl plugin:</p> <pre><code>kubectl rook-ceph ceph mgr module disable rook\nkubectl rook-ceph ceph mgr module enable rook\n</code></pre> </li> <li> <p>Once the module is restarted the modifications will be running in the active manager.     View the manager pod log or other changed behavior to validate the changes.</p> </li> </ol>"},{"location":"Contributing/documentation/","title":"Documentation","text":"<p>We are using MkDocs with the Material for MkDocs theme.</p>"},{"location":"Contributing/documentation/#markdown-extensions","title":"Markdown Extensions","text":"<p>Thanks to the MkDocs Material theme we have certain \"markdown syntax extensions\" available:</p> <ul> <li>Admonitions</li> <li>Footnotes</li> <li>Icons, Emojis</li> <li>Task lists</li> <li>And more..</li> </ul> <p>For a whole list of features Reference - Material for MkDocs.</p>"},{"location":"Contributing/documentation/#local-preview","title":"Local Preview","text":"<p>To locally preview the documentation, you can run the following command (in the root of the repository):</p> <pre><code>make docs-preview\n</code></pre> <p>When previewing, now you can navigate your browser to http://127.0.0.1:8000/ to open the preview of the documentation.</p> <p>Hint</p> <p>Should you encounter a <code>command not found</code> error while trying to preview the docs for the first time on a machine, you probably need to install the dependencies for MkDocs and extensions used: <code>pip3 install -r build/release/requirements_docs.txt</code>. Make sure that your Python binary path is included in your <code>PATH</code>.</p>"},{"location":"Contributing/documentation/#making-docs","title":"Making docs","text":"<p>helm-docs is a tool that generates the documentation for a helm chart automatically. If there are changes in the helm chart, the developer needs to run <code>make docs</code> (to run helm-docs) and check in the resulting autogenerated files. To make it easy to check locally for uncommitted changes generated by <code>make docs</code>, an additional <code>make</code> target exists: simply running <code>make check.docs</code> will run the docs auto-generation and will complain if this produces uncommitted changes to doc files. It is therefore a good habit to always run <code>make check.docs</code> locally before creating or updating a PR.</p>"},{"location":"Contributing/rook-test-framework/","title":"Integration Tests","text":"<p>The integration tests run end-to-end tests on Rook in a running instance of Kubernetes. The framework includes scripts for starting Kubernetes so users can quickly spin up a Kubernetes cluster. The tests are generally designed to install Rook, run tests, and uninstall Rook.</p> <p>The CI runs the integration tests with each PR and each master or release branch build. If the tests fail in a PR, access the tmate for debugging.</p> <p>This document will outline the steps to run the integration tests locally in a minikube environment, should the CI not be sufficient to troubleshoot.</p> <p>Hint</p> <p>The CI is generally much simpler to troubleshoot than running these tests locally. Running the tests locally is rarely necessary.</p> <p>Warning</p> <p>A risk of running the tests locally is that a local disk is required during the tests. If not running in a VM, your laptop or other test machine could be destroyed.</p>"},{"location":"Contributing/rook-test-framework/#install-minikube","title":"Install Minikube","text":"<p>Follow Rook's developer guide to install Minikube.</p>"},{"location":"Contributing/rook-test-framework/#build-rook-image","title":"Build Rook image","text":"<p>Now that the Kubernetes cluster is running we need to populate the Docker registry to allow local image builds to be easily used inside Minikube.</p> <pre><code>eval $(minikube docker-env -p minikube)\n</code></pre> <p><code>make build</code> will now build and push the images to the Docker registry inside the Minikube virtual machine.</p> <pre><code>make build\n</code></pre> <p>Tag the newly built images to <code>rook/ceph:local-build</code> for running tests, or <code>rook/ceph:master</code> if creating example manifests::</p> <pre><code>docker tag $(docker images|awk '/build-/ {print $1}') rook/ceph:local-build\ndocker tag rook/ceph:local-build rook/ceph:master\n</code></pre>"},{"location":"Contributing/rook-test-framework/#run-integration-tests","title":"Run integration tests","text":"<p>Some settings are available to run the tests under different environments. The settings are all configured with environment variables. See environment.go for the available environment variables.</p> <p>Set the following variables:</p> <pre><code>export TEST_HELM_PATH=/tmp/rook-tests-scripts-helm/helm\nexport TEST_BASE_DIR=WORKING_DIR\nexport TEST_SCRATCH_DEVICE=/dev/vdb\n</code></pre> <p>Set <code>TEST_SCRATCH_DEVICE</code> to the correct block device name based on the driver that's being used.</p> <p>Hint</p> <p>If using the <code>virtualbox</code> minikube driver, the device should be <code>/dev/sdb</code></p> <p>Warning</p> <p>The integration tests erase the contents of <code>TEST_SCRATCH_DEVICE</code> when the test is completed</p> <p>To run a specific suite, specify the suite name:</p> <pre><code>go test -v -timeout 1800s -run CephSmokeSuite github.com/rook/rook/tests/integration\n</code></pre> <p>After running tests, see test logs under <code>tests/integration/_output</code>.</p> <p>To run specific tests inside a suite:</p> <pre><code>go test -v -timeout 1800s -run CephSmokeSuite github.com/rook/rook/tests/integration -testify.m TestARookClusterInstallation_SmokeTest\n</code></pre> <p>Info</p> <p>Only the golang test suites are documented to run locally. Canary and other tests have only ever been supported in the CI.</p>"},{"location":"Contributing/rook-test-framework/#running-tests-on-openshift","title":"Running tests on OpenShift","text":"<ol> <li>Setup OpenShift environment and export KUBECONFIG</li> <li>Make sure <code>oc</code> executable file is in the PATH.</li> <li>Only the <code>CephSmokeSuite</code> is currently supported on OpenShift.</li> <li> <p>Set the following environment variables depending on the environment:</p> <pre><code>export TEST_ENV_NAME=openshift\nexport TEST_STORAGE_CLASS=gp2-csi\nexport TEST_BASE_DIR=/tmp\n</code></pre> </li> <li> <p>Run the integration tests</p> </li> </ol>"},{"location":"Getting-Started/ceph-openshift/","title":"OpenShift","text":"<p>OpenShift adds a number of security and other enhancements to Kubernetes. In particular, security context constraints allow the cluster admin to define exactly which permissions are allowed to pods running in the cluster. You will need to define those permissions that allow the Rook pods to run.</p> <p>The settings for Rook in OpenShift are described below, and are also included in the example yaml files:</p> <ul> <li><code>operator-openshift.yaml</code>: Creates the security context constraints and starts the operator deployment</li> <li><code>object-openshift.yaml</code>: Creates an object store with rgw listening on a valid port number for OpenShift</li> </ul>"},{"location":"Getting-Started/ceph-openshift/#tldr","title":"TL;DR","text":"<p>To create an OpenShift cluster, the commands basically include:</p> <pre><code>oc create -f crds.yaml -f common.yaml\noc create -f operator-openshift.yaml\noc create -f cluster.yaml\n</code></pre>"},{"location":"Getting-Started/ceph-openshift/#helm-installation","title":"Helm Installation","text":"<p>Configuration required for Openshift is automatically created by the Helm charts, such as the SecurityContextConstraints. See the Rook Helm Charts.</p>"},{"location":"Getting-Started/ceph-openshift/#rook-privileges","title":"Rook Privileges","text":"<p>To orchestrate the storage platform, Rook requires the following access in the cluster:</p> <ul> <li>Create <code>hostPath</code> volumes, for persistence by the Ceph mon and osd pods</li> <li>Run pods in <code>privileged</code> mode, for access to <code>/dev</code> and <code>hostPath</code> volumes</li> <li>Host networking for the Rook agent and clusters that require host networking</li> <li>Ceph OSDs require host PIDs for communication on the same node</li> </ul>"},{"location":"Getting-Started/ceph-openshift/#security-context-constraints","title":"Security Context Constraints","text":"<p>Before starting the Rook operator or cluster, create the security context constraints needed by the Rook pods. The following yaml is found in <code>operator-openshift.yaml</code> under <code>/deploy/examples</code>.</p> <p>Hint</p> <p>Older versions of OpenShift may require <code>apiVersion: v1</code>.</p> <p>Important to note is that if you plan on running Rook in namespaces other than the default <code>rook-ceph</code>, the example scc will need to be modified to accommodate for your namespaces where the Rook pods are running.</p> <p>To create the scc you will need a privileged account:</p> <pre><code>oc login -u system:admin\n</code></pre> <p>We will create the security context constraints with the operator in the next section.</p>"},{"location":"Getting-Started/ceph-openshift/#rook-settings","title":"Rook Settings","text":"<p>There are some Rook settings that also need to be adjusted to work in OpenShift.</p>"},{"location":"Getting-Started/ceph-openshift/#operator-settings","title":"Operator Settings","text":"<p>There is an environment variable that needs to be set in the operator spec that will allow Rook to run in OpenShift clusters.</p> <ul> <li><code>ROOK_HOSTPATH_REQUIRES_PRIVILEGED</code>: Must be set to <code>true</code>. Writing to the hostPath is required for the Ceph mon, osd pods and csi provisioners(if logrotation is on). Given the restricted permissions in OpenShift with SELinux, the pod must be running privileged in order to write to the hostPath volume.</li> </ul> <pre><code>- name: ROOK_HOSTPATH_REQUIRES_PRIVILEGED\n  value: \"true\"\n</code></pre> <p>Now create the security context constraints and the operator:</p> <pre><code>oc create -f operator-openshift.yaml\n</code></pre>"},{"location":"Getting-Started/ceph-openshift/#cluster-settings","title":"Cluster Settings","text":"<p>The cluster settings in <code>cluster.yaml</code> are largely isolated from the differences in OpenShift. There is perhaps just one to take note of:</p> <ul> <li><code>dataDirHostPath</code>: Ensure that it points to a valid, writable path on the host systems.</li> </ul>"},{"location":"Getting-Started/ceph-openshift/#object-store-settings","title":"Object Store Settings","text":"<p>In OpenShift, ports less than 1024 cannot be bound. In the object store CRD, ensure the port is modified to meet this requirement.</p> <pre><code>gateway:\n  port: 8080\n</code></pre> <p>You can expose a different port such as <code>80</code> by creating a service.</p> <p>A sample object store can be created with these settings:</p> <pre><code>oc create -f object-openshift.yaml\n</code></pre>"},{"location":"Getting-Started/ceph-teardown/","title":"Cleanup","text":"<p>Rook provides the following clean up options:</p> <ol> <li>Uninstall: Clean up the entire cluster and delete all data</li> <li>Force delete individual resources</li> </ol>"},{"location":"Getting-Started/ceph-teardown/#cleaning-up-a-cluster","title":"Cleaning up a Cluster","text":"<p>To tear down the cluster, the following resources need to be cleaned up:</p> <ul> <li>The resources created under Rook's namespace (default <code>rook-ceph</code>) such as the Rook operator created by <code>operator.yaml</code> and the cluster CR <code>cluster.yaml</code>.</li> <li>All files under <code>dataDirHostPath</code> (default <code>/var/lib/rook</code>): Path on each host in the cluster where configuration is stored by ceph daemons.</li> <li>Devices used by the OSDs</li> </ul> <p>If the default namespaces or paths such as <code>dataDirHostPath</code> are changed in the example yaml files, these namespaces and paths will need to be changed throughout these instructions.</p> <p>If tearing down a cluster frequently for development purposes, it is instead recommended to use an environment such as Minikube that can easily be reset without worrying about any of these steps.</p>"},{"location":"Getting-Started/ceph-teardown/#delete-the-block-and-file-artifacts","title":"Delete the Block and File artifacts","text":"<p>First clean up the resources from applications that consume the Rook storage.</p> <p>These commands will clean up the resources from the example application block and file walkthroughs (unmount volumes, delete volume claims, etc).</p> <pre><code>kubectl delete -f ../wordpress.yaml\nkubectl delete -f ../mysql.yaml\nkubectl delete -n rook-ceph cephblockpool replicapool\nkubectl delete storageclass rook-ceph-block\nkubectl delete -f csi/cephfs/kube-registry.yaml\nkubectl delete storageclass csi-cephfs\n</code></pre> <p>Important</p> <p>After applications have been cleaned up, the Rook cluster can be removed. It is important to delete applications before removing the Rook operator and Ceph cluster. Otherwise, volumes may hang and nodes may require a restart.</p>"},{"location":"Getting-Started/ceph-teardown/#delete-the-cephcluster-crd","title":"Delete the CephCluster CRD","text":"<p>Warning</p> <p>DATA WILL BE PERMANENTLY DELETED AFTER DELETING THE <code>CephCluster</code></p> <ol> <li> <p>To instruct Rook to wipe the host paths and volumes, edit the <code>CephCluster</code> and add the <code>cleanupPolicy</code>:</p> <pre><code>kubectl -n rook-ceph patch cephcluster rook-ceph --type merge -p '{\"spec\":{\"cleanupPolicy\":{\"confirmation\":\"yes-really-destroy-data\"}}}'\n</code></pre> <p>Once the cleanup policy is enabled, any new configuration changes in the CephCluster will be blocked. Nothing will happen until the deletion of the CR is requested, so this <code>cleanupPolicy</code> change can still be reverted if needed.</p> <p>Checkout more details about the <code>cleanupPolicy</code> here</p> </li> <li> <p>Delete the <code>CephCluster</code> CR.</p> <pre><code>kubectl -n rook-ceph delete cephcluster rook-ceph\n</code></pre> </li> <li> <p>Verify that the cluster CR has been deleted before continuing to the next step.</p> <pre><code>kubectl -n rook-ceph get cephcluster\n</code></pre> </li> <li> <p>If the <code>cleanupPolicy</code> was applied, wait for the <code>rook-ceph-cleanup</code> jobs to be completed on all the nodes.</p> <p>These jobs will perform the following operations:</p> <ul> <li>Delete the all files under <code>dataDirHostPath</code> on all the nodes</li> <li>Wipe the data on the drives on all the nodes where OSDs were running in this cluster</li> </ul> </li> </ol> <p>Note</p> <p>The cleanup jobs might not start if the resources created on top of Rook Cluster are not deleted completely. See deleting block and file artifacts</p>"},{"location":"Getting-Started/ceph-teardown/#delete-the-operator-resources","title":"Delete the Operator Resources","text":"<p>Remove the Rook operator, RBAC, and CRDs, and the <code>rook-ceph</code> namespace.</p> <pre><code>kubectl delete -f operator.yaml\nkubectl delete -f common.yaml\nkubectl delete -f crds.yaml\n</code></pre>"},{"location":"Getting-Started/ceph-teardown/#delete-the-data-on-hosts","title":"Delete the data on hosts","text":"<p>Attention</p> <p>The final cleanup step requires deleting files on each host in the cluster. All files under the <code>dataDirHostPath</code> property specified in the cluster CRD will need to be deleted. Otherwise, inconsistent state will remain when a new cluster is started.</p> <p>If the <code>cleanupPolicy</code> was not added to the CephCluster CR before deleting the cluster, these manual steps are required to tear down the cluster.</p> <p>Connect to each machine and delete all files under <code>dataDirHostPath</code>.</p>"},{"location":"Getting-Started/ceph-teardown/#zapping-devices","title":"Zapping Devices","text":"<p>Disks on nodes used by Rook for OSDs can be reset to a usable state. Note that these scripts are not one-size-fits-all. Please use them with discretion to ensure you are not removing data unrelated to Rook.</p> <p>A single disk can usually be cleared with some or all of the steps below.</p> <pre><code>DISK=\"/dev/sdX\"\n\n# Zap the disk to a fresh, usable state (zap-all is important, b/c MBR has to be clean)\nsgdisk --zap-all $DISK\n\n# Wipe a large portion of the beginning of the disk to remove more LVM metadata that may be present\ndd if=/dev/zero of=\"$DISK\" bs=1M count=100 oflag=direct,dsync\n\n# SSDs may be better cleaned with blkdiscard instead of dd\nblkdiscard $DISK\n\n# Inform the OS of partition table changes\npartprobe $DISK\n</code></pre> <p>Ceph can leave LVM and device mapper data on storage drives, preventing them from being redeployed. These steps can clean former Ceph drives for reuse. Note that this only needs to be run once on each node. If you have only one Rook cluster and all Ceph disks are being wiped, run the following command.</p> <pre><code># This command hangs on some systems: with caution, 'dmsetup remove_all --force' can be used\nls /dev/mapper/ceph-* | xargs -I% -- dmsetup remove %\n\n# ceph-volume setup can leave ceph-&lt;UUID&gt; directories in /dev and /dev/mapper (unnecessary clutter)\nrm -rf /dev/ceph-*\nrm -rf /dev/mapper/ceph--*\n</code></pre> <p>If disks are still reported locked, rebooting the node often helps clear LVM-related holds on disks.</p> <p>If there are multiple Ceph clusters and some disks are not wiped yet, it is necessary to manually determine which disks map to which device mapper devices.</p>"},{"location":"Getting-Started/ceph-teardown/#troubleshooting","title":"Troubleshooting","text":"<p>The most common issue cleaning up the cluster is that the <code>rook-ceph</code> namespace or the cluster CRD remain indefinitely in the <code>terminating</code> state. A namespace cannot be removed until all of its resources are removed, so determine which resources are pending termination.</p> <p>If a pod is still terminating, consider forcefully terminating the pod (<code>kubectl -n rook-ceph delete pod &lt;name&gt;</code>).</p> <pre><code>kubectl -n rook-ceph get pod\n</code></pre> <p>If the cluster CRD still exists even though it has been deleted, see the next section on removing the finalizer.</p> <pre><code>kubectl -n rook-ceph get cephcluster\n</code></pre>"},{"location":"Getting-Started/ceph-teardown/#removing-the-cluster-crd-finalizer","title":"Removing the Cluster CRD Finalizer","text":"<p>When a Cluster CRD is created, a finalizer is added automatically by the Rook operator. The finalizer will allow the operator to ensure that before the cluster CRD is deleted, all block and file mounts will be cleaned up. Without proper cleanup, pods consuming the storage will be hung indefinitely until a system reboot.</p> <p>The operator is responsible for removing the finalizer after the mounts have been cleaned up. If for some reason the operator is not able to remove the finalizer (i.e., the operator is not running anymore), delete the finalizer manually with the following command:</p> <pre><code>for CRD in $(kubectl get crd -n rook-ceph | awk '/ceph.rook.io/ {print $1}'); do\n    kubectl get -n rook-ceph \"$CRD\" -o name | \\\n    xargs -I {} kubectl patch -n rook-ceph {} --type merge -p '{\"metadata\":{\"finalizers\": []}}'\ndone\n</code></pre> <p>If the namespace is still stuck in Terminating state, check which resources are holding up the deletion and remove their finalizers as well:</p> <pre><code>kubectl api-resources --verbs=list --namespaced -o name \\\n  | xargs -n 1 kubectl get --show-kind --ignore-not-found -n rook-ceph\n</code></pre>"},{"location":"Getting-Started/ceph-teardown/#remove-critical-resource-finalizers","title":"Remove critical resource finalizers","text":"<p>Rook adds a finalizer <code>ceph.rook.io/disaster-protection</code> to resources critical to the Ceph cluster so that the resources will not be accidentally deleted.</p> <p>The operator is responsible for removing the finalizers when a CephCluster is deleted. If the operator is not able to remove the finalizers (i.e., the operator is not running anymore), remove the finalizers manually:</p> <pre><code>kubectl -n rook-ceph patch configmap rook-ceph-mon-endpoints --type merge -p '{\"metadata\":{\"finalizers\": []}}'\nkubectl -n rook-ceph patch secrets rook-ceph-mon --type merge -p '{\"metadata\":{\"finalizers\": []}}'\n</code></pre>"},{"location":"Getting-Started/ceph-teardown/#force-delete-resources","title":"Force Delete Resources","text":"<p>To keep your data safe in the cluster, Rook disallows deleting critical cluster resources by default. To override this behavior and force delete a specific custom resource, add the annotation <code>rook.io/force-deletion=\"true\"</code> to the resource and then delete it. Rook will start a cleanup job that will delete all the related ceph resources created by that custom resource.</p> <p>For example, run the following commands to clean the <code>CephFilesystemSubVolumeGroup</code> resource named <code>my-subvolumegroup</code></p> <pre><code>kubectl -n rook-ceph annotate cephfilesystemsubvolumegroups.ceph.rook.io my-subvolumegroup rook.io/force-deletion=\"true\"\nkubectl -n rook-ceph delete cephfilesystemsubvolumegroups.ceph.rook.io my-subvolumegroup\n</code></pre> <p>Once the cleanup job is completed successfully, Rook will remove the finalizers from the deleted custom resource.</p> <p>This cleanup is supported only for the following custom resources:</p> Custom Resource Ceph Resources to be cleaned up CephFilesystemSubVolumeGroup CSI stored RADOS OMAP details for pvc/volumesnapshots, subvolume snapshots, subvolume clones, subvolumes CephBlockPoolRadosNamespace Images and snapshots in the RADOS namespace CephBlockPool Images and snapshots in the BlockPool"},{"location":"Getting-Started/example-configurations/","title":"Example Configurations","text":"<p>Configuration for Rook and Ceph can be configured in multiple ways to provide block devices, shared filesystem volumes or object storage in a kubernetes namespace. While several examples are provided to simplify storage setup, settings are available to optimize various production environments.</p> <p>See the example yaml files folder for all the rook/ceph setup example spec files.</p>"},{"location":"Getting-Started/example-configurations/#common-resources","title":"Common Resources","text":"<p>The first step to deploy Rook is to create the CRDs and other common resources. The configuration for these resources will be the same for most deployments. The crds.yaml and common.yaml sets these resources up.</p> <pre><code>kubectl create -f crds.yaml -f common.yaml\n</code></pre> <p>The examples all assume the operator and all Ceph daemons will be started in the same namespace. If deploying the operator in a separate namespace, see the comments throughout <code>common.yaml</code>.</p>"},{"location":"Getting-Started/example-configurations/#operator","title":"Operator","text":"<p>After the common resources are created, the next step is to create the Operator deployment. Several spec file examples are provided in this directory:</p> <ul> <li><code>operator.yaml</code>: The most common settings for production deployments<ul> <li><code>kubectl create -f operator.yaml</code></li> </ul> </li> <li><code>operator-openshift.yaml</code>: Includes all of the operator settings for running a basic Rook cluster in an OpenShift environment. You will also want to review the OpenShift Prerequisites to confirm the settings.<ul> <li><code>oc create -f operator-openshift.yaml</code></li> </ul> </li> </ul> <p>Settings for the operator are configured through environment variables on the operator deployment. The individual settings are documented in operator.yaml.</p>"},{"location":"Getting-Started/example-configurations/#cluster-crd","title":"Cluster CRD","text":"<p>Now that the operator is running, create the Ceph storage cluster with the CephCluster CR. This CR contains the most critical settings that will influence how the operator configures the storage. It is important to understand the various ways to configure the cluster. These examples represent several different ways to configure the storage.</p> <ul> <li><code>cluster.yaml</code>: Common settings for a production storage cluster. Requires at least three worker nodes.</li> <li><code>cluster-test.yaml</code>: Settings for a test cluster where redundancy is not configured. Requires only a single node.</li> <li><code>cluster-on-pvc.yaml</code>: Common settings for backing the Ceph Mons and OSDs by PVs. Useful when running in cloud environments or where local PVs have been created for Ceph to consume.</li> <li><code>cluster-external.yaml</code>: Connect to an external Ceph cluster with minimal access to monitor the health of the cluster and connect to the storage.</li> <li><code>cluster-external-management.yaml</code>: Connect to an external Ceph cluster with the admin key of the external cluster to enable     remote creation of pools and configure services such as an     Object Store or a     Shared Filesystem.</li> <li><code>cluster-stretched.yaml</code>: Create a cluster in \"stretched\" mode, with five mons stretched across three zones, and the OSDs across two zones. See the Stretch documentation.</li> </ul> <p>See the Cluster CRD topic for more details and more examples for the settings.</p>"},{"location":"Getting-Started/example-configurations/#setting-up-consumable-storage","title":"Setting up consumable storage","text":"<p>Now we are ready to setup Block, Shared Filesystem or Object storage in the Rook cluster. These storage types are respectively created with the CephBlockPool, CephFilesystem and CephObjectStore CRs.</p>"},{"location":"Getting-Started/example-configurations/#block-devices","title":"Block Devices","text":"<p>Ceph provides raw block device volumes to pods. Each example below sets up a storage class which can then be used to provision a block device in application pods. The storage class is defined with a Ceph pool which defines the level of data redundancy in Ceph:</p> <ul> <li><code>storageclass.yaml</code>: This example illustrates replication of 3 for production scenarios and requires at least three worker nodes. Data is replicated on three different kubernetes worker nodes. Intermittent or long-lasting single node failures will not result in data unavailability or loss.</li> <li><code>storageclass-ec.yaml</code>: Configures erasure coding for data durability rather than replication. Ceph's erasure coding is more efficient than replication so you can get high reliability without the 3x replication cost of the preceding example (but at the cost of higher computational encoding and decoding costs on the worker nodes). Erasure coding requires at least three worker nodes. See the Erasure coding documentation.</li> <li><code>storageclass-test.yaml</code>: Replication of 1 for test scenarios. Requires only a single node. Do not use this for production applications. A single node failure can result in full data loss.</li> </ul> <p>The block storage classes are found in the examples directory:</p> <ul> <li><code>csi/rbd</code>: the CSI driver examples for block devices</li> </ul> <p>See the CephBlockPool CRD topic for more block storage settings.</p>"},{"location":"Getting-Started/example-configurations/#shared-filesystem","title":"Shared Filesystem","text":"<p>Ceph filesystem (CephFS) allows the user to mount a shared posix-compliant folder into one or more application pods. This storage is similar to NFS shared storage or CIFS shared folders, as explained here.</p> <p>Shared Filesystem storage contains configurable pools for different scenarios:</p> <ul> <li><code>filesystem.yaml</code>: Replication of 3 for production scenarios. Requires at least three worker nodes.</li> <li><code>filesystem-ec.yaml</code>: Erasure coding for production scenarios. Requires at least three worker nodes.</li> <li><code>filesystem-test.yaml</code>: Replication of 1 for test scenarios. Requires only a single node.</li> </ul> <p>Dynamic provisioning is possible with the CSI driver. The storage class for shared filesystems is found in the <code>csi/cephfs</code> directory.</p> <p>See the Shared Filesystem CRD topic for more details on the settings.</p>"},{"location":"Getting-Started/example-configurations/#object-storage","title":"Object Storage","text":"<p>Ceph supports storing blobs of data called objects that support HTTP(s)-type get/put/post and delete semantics. This storage is similar to AWS S3 storage, for example.</p> <p>Object storage contains multiple pools that can be configured for different scenarios:</p> <ul> <li><code>object.yaml</code>: Replication of 3 for production scenarios.  Requires at least three worker nodes.</li> <li><code>object-openshift.yaml</code>: Replication of 3 with rgw in a port range valid for OpenShift. Requires at least three worker nodes.</li> <li><code>object-ec.yaml</code>: Erasure coding rather than replication for production scenarios. Requires at least three worker nodes.</li> <li><code>object-test.yaml</code>: Replication of 1 for test scenarios. Requires only a single node.</li> </ul> <p>See the Object Store CRD topic for more details on the settings.</p>"},{"location":"Getting-Started/example-configurations/#object-storage-user","title":"Object Storage User","text":"<ul> <li><code>object-user.yaml</code>: Creates a simple object storage user and generates credentials for the S3 API</li> </ul>"},{"location":"Getting-Started/example-configurations/#object-storage-buckets","title":"Object Storage Buckets","text":"<p>The Ceph operator also runs an object store bucket provisioner which can grant access to existing buckets or dynamically provision new buckets.</p> <ul> <li>object-bucket-claim-retain.yaml Creates a request for a new bucket by referencing a StorageClass which saves the bucket when the initiating OBC is deleted.</li> <li>object-bucket-claim-delete.yaml Creates a request for a new bucket by referencing a StorageClass which deletes the bucket when the initiating OBC is deleted.</li> <li>storageclass-bucket-retain.yaml Creates a new StorageClass which defines the Ceph Object Store and retains the bucket after the initiating OBC is deleted.</li> <li>storageclass-bucket-delete.yaml Creates a new StorageClass which defines the Ceph Object Store and deletes the bucket after the initiating OBC is deleted.</li> </ul>"},{"location":"Getting-Started/glossary/","title":"Glossary","text":""},{"location":"Getting-Started/glossary/#rook","title":"Rook","text":""},{"location":"Getting-Started/glossary/#cephblockpool-crd","title":"CephBlockPool CRD","text":"<p>The CephBlockPool CRD is used by Rook to allow creation and customization of storage pools.</p>"},{"location":"Getting-Started/glossary/#cephblockpoolradosnamespace-crd","title":"CephBlockPoolRadosNamespace CRD","text":"<p>The CephBlockPoolRadosNamespace CRD is used by Rook to allow creation of Ceph RADOS Namespaces.</p>"},{"location":"Getting-Started/glossary/#cephclient-crd","title":"CephClient CRD","text":"<p>CephClient CRD is used by Rook to allow creation and updating clients.</p>"},{"location":"Getting-Started/glossary/#cephcluster-crd","title":"CephCluster CRD","text":"<p>The CephCluster CRD is used by Rook to allow creation and customization of storage clusters through the custom resource definitions (CRDs).</p>"},{"location":"Getting-Started/glossary/#ceph-csi","title":"Ceph CSI","text":"<p>The Ceph CSI plugins implement an interface between a CSI-enabled Container Orchestrator (CO) and Ceph clusters.</p>"},{"location":"Getting-Started/glossary/#cephfilesystem-crd","title":"CephFilesystem CRD","text":"<p>The CephFilesystem CRD is used by Rook to allow creation and customization of shared filesystems through the custom resource definitions (CRDs).</p>"},{"location":"Getting-Started/glossary/#cephfilesystemmirror-crd","title":"CephFilesystemMirror CRD","text":"<p>The CephFilesystemMirror CRD is used by Rook to allow creation and updating the Ceph fs-mirror daemon.</p>"},{"location":"Getting-Started/glossary/#cephfilesystemsubvolumegroup-crd","title":"CephFilesystemSubVolumeGroup CRD","text":"<p>CephFilesystemMirror CRD is used by Rook to allow creation of Ceph Filesystem SubVolumeGroups.</p>"},{"location":"Getting-Started/glossary/#cephnfs-crd","title":"CephNFS CRD","text":"<p>CephNFS CRD is used by Rook to allow exporting NFS shares of a CephFilesystem or CephObjectStore through the CephNFS custom resource definition. For further information please refer to the example here.</p>"},{"location":"Getting-Started/glossary/#cephobjectstore-crd","title":"CephObjectStore CRD","text":"<p>CephObjectStore CRD is used by Rook to allow creation and customization of object stores.</p>"},{"location":"Getting-Started/glossary/#cephobjectstoreuser-crd","title":"CephObjectStoreUser CRD","text":"<p>CephObjectStoreUser CRD is used by Rook to allow creation and customization of object store users. For more information and examples refer to this documentation.</p>"},{"location":"Getting-Started/glossary/#cephobjectrealm-crd","title":"CephObjectRealm CRD","text":"<p>CephObjectRealm CRD is used by Rook to allow creation of a realm in a Ceph Object Multisite configuration. For more information and examples refer to this documentation.</p>"},{"location":"Getting-Started/glossary/#cephobjectzonegroup-crd","title":"CephObjectZoneGroup CRD","text":"<p>CephObjectZoneGroup CRD is used by Rook to allow creation of zone groups in a Ceph Object Multisite configuration. For more information and examples refer to this documentation.</p>"},{"location":"Getting-Started/glossary/#cephobjectzone-crd","title":"CephObjectZone CRD","text":"<p>CephObjectZone CRD is used by Rook to allow creation of zones in a ceph cluster for a Ceph Object Multisite configuration. For more information and examples refer to this documentation.</p>"},{"location":"Getting-Started/glossary/#cephrbdmirror-crd","title":"CephRBDMirror CRD","text":"<p>CephRBDMirror CRD is used by Rook to allow creation and updating rbd-mirror daemon(s) through the custom resource definitions (CRDs). For more information and examples refer to this documentation.</p>"},{"location":"Getting-Started/glossary/#external-storage-cluster","title":"External Storage Cluster","text":"<p>An external cluster is a Ceph configuration that is managed outside of the local K8s cluster.</p>"},{"location":"Getting-Started/glossary/#host-storage-cluster","title":"Host Storage Cluster","text":"<p>A host storage cluster is where Rook configures Ceph to store data directly on the host devices.</p>"},{"location":"Getting-Started/glossary/#kubectl-plugin","title":"kubectl Plugin","text":"<p>The Rook kubectl plugin is a tool to help troubleshoot your Rook cluster.</p>"},{"location":"Getting-Started/glossary/#object-bucket-claim-obc","title":"Object Bucket Claim (OBC)","text":"<p>An Object Bucket Claim (OBC) is custom resource which requests a bucket (new or existing) from a Ceph object store. For further reference please refer to OBC Custom Resource.</p>"},{"location":"Getting-Started/glossary/#object-bucket-ob","title":"Object Bucket (OB)","text":"<p>An Object Bucket (OB) is a custom resource automatically generated when a bucket is provisioned. It is a global resource, typically not visible to non-admin users, and contains information specific to the bucket.</p>"},{"location":"Getting-Started/glossary/#openshift","title":"OpenShift","text":"<p>OpenShift Container Platform is a distribution of the Kubernetes container platform.</p>"},{"location":"Getting-Started/glossary/#pvc-storage-cluster","title":"PVC Storage Cluster","text":"<p>In a PersistentVolumeClaim-based cluster, the Ceph persistent data is stored on volumes requested from a storage class of your choice.</p>"},{"location":"Getting-Started/glossary/#stretch-storage-cluster","title":"Stretch Storage Cluster","text":"<p>A stretched cluster is a deployment model in which two datacenters with low latency are available for storage in the same K8s cluster, rather than three or more. To support this scenario, Rook has integrated support for stretch clusters.</p>"},{"location":"Getting-Started/glossary/#toolbox","title":"Toolbox","text":"<p>The Rook toolbox is a container with common tools used for rook debugging and testing.</p>"},{"location":"Getting-Started/glossary/#ceph","title":"Ceph","text":"<p>Ceph is a distributed network storage and file system with distributed metadata management and POSIX semantics. See also the Ceph Glossary. Here are a few of the important terms to understand:</p> <ul> <li>Ceph Monitor (MON)</li> <li>Ceph Manager (MGR)</li> <li>Ceph Metadata Server (MDS)</li> <li>Object Storage Device (OSD)</li> <li>RADOS Block Device (RBD)</li> <li>Ceph Object Gateway (RGW)</li> </ul>"},{"location":"Getting-Started/glossary/#kubernetes","title":"Kubernetes","text":"<p>Kubernetes, also known as K8s, is an open-source system for automating deployment, scaling, and management of containerized applications. For further information see also the Kubernetes Glossary for more definitions. Here are a few of the important terms to understand:</p> <ul> <li>Affinity</li> <li>Container Storage Interface (CSI) for Kubernetes</li> <li>CustomResourceDefinition (CRDs)</li> <li>DaemonSet</li> <li>Deployment</li> <li>Finalizer</li> <li>Node affinity</li> <li>Node Selector</li> <li>PersistentVolume (PV)</li> <li>PersistentVolumeClaim (PVC)</li> <li>Selector</li> <li>Storage Class</li> <li>Taint</li> <li>Toleration</li> <li>Volume</li> </ul>"},{"location":"Getting-Started/intro/","title":"Rook","text":"<p>Rook is an open source cloud-native storage orchestrator, providing the platform, framework, and support for Ceph storage to natively integrate with cloud-native environments.</p> <p>Ceph is a distributed storage system that provides file, block and object storage and is deployed in large scale production clusters.</p> <p>Rook automates deployment and management of Ceph to provide self-managing, self-scaling, and self-healing storage services. The Rook operator does this by building on Kubernetes resources to deploy, configure, provision, scale, upgrade, and monitor Ceph.</p> <p>The Ceph operator was declared stable in December 2018 in the Rook v0.9 release, providing a production storage platform for many years. Rook is hosted by the Cloud Native Computing Foundation (CNCF) as a graduated level project.</p>"},{"location":"Getting-Started/intro/#quick-start-guide","title":"Quick Start Guide","text":"<p>Starting Ceph in your cluster is as simple as a few <code>kubectl</code> commands. See our Quickstart guide to get started with the Ceph operator!</p>"},{"location":"Getting-Started/intro/#designs","title":"Designs","text":"<p>Ceph is a highly scalable distributed storage solution for block storage, object storage, and shared filesystems with years of production deployments. See the Ceph overview.</p> <p>For detailed design documentation, see also the design docs.</p>"},{"location":"Getting-Started/intro/#need-help-be-sure-to-join-the-rook-slack","title":"Need help? Be sure to join the Rook Slack","text":"<p>If you have any questions along the way, don't hesitate to ask in our Slack channel. Sign up for the Rook Slack here.</p>"},{"location":"Getting-Started/quickstart/","title":"Quickstart","text":"<p>Welcome to Rook! We hope you have a great experience installing the Rook cloud-native storage orchestrator platform to enable highly available, durable Ceph storage in Kubernetes clusters.</p> <p>Don't hesitate to ask questions in our Slack channel. Sign up for the Rook Slack here.</p> <p>This guide will walk through the basic setup of a Ceph cluster and enable K8s applications to consume block, object, and file storage.</p> <p>Always use a virtual machine when testing Rook. Never use a host system where local devices may mistakenly be consumed.</p>"},{"location":"Getting-Started/quickstart/#kubernetes-version","title":"Kubernetes Version","text":"<p>Kubernetes versions v1.27 through v1.31 are supported.</p>"},{"location":"Getting-Started/quickstart/#cpu-architecture","title":"CPU Architecture","text":"<p>Architectures released are <code>amd64 / x86_64</code> and <code>arm64</code>.</p>"},{"location":"Getting-Started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>To check if a Kubernetes cluster is ready for <code>Rook</code>, see the prerequisites.</p> <p>To configure the Ceph storage cluster, at least one of these local storage options are required:</p> <ul> <li>Raw devices (no partitions or formatted filesystem)</li> <li>Raw partitions (no formatted filesystem)</li> <li>LVM Logical Volumes (no formatted filesystem)</li> <li>Encrypted devices (no formatted filesystem)</li> <li>Multipath devices (no formatted filesystem)</li> <li>Persistent Volumes available from a storage class in <code>block</code> mode</li> </ul>"},{"location":"Getting-Started/quickstart/#tldr","title":"TL;DR","text":"<p>A simple Rook cluster is created for Kubernetes with the following <code>kubectl</code> commands and example manifests.</p> <pre><code>$ git clone --single-branch --branch master https://github.com/rook/rook.git\ncd rook/deploy/examples\nkubectl create -f crds.yaml -f common.yaml -f operator.yaml\nkubectl create -f cluster.yaml\n</code></pre> <p>After the cluster is running, applications can consume block, object, or file storage.</p>"},{"location":"Getting-Started/quickstart/#deploy-the-rook-operator","title":"Deploy the Rook Operator","text":"<p>The first step is to deploy the Rook operator.</p> <p>Important</p> <p>The Rook Helm Chart is available to deploy the operator instead of creating the below manifests.</p> <p>Note</p> <p>Check that the example yaml files are from a tagged release of Rook.</p> <p>Note</p> <p>These steps are for a standard production Rook deployment in Kubernetes. For Openshift, testing, or more options, see the example configurations documentation.</p> <pre><code>cd deploy/examples\nkubectl create -f crds.yaml -f common.yaml -f operator.yaml\n\n# verify the rook-ceph-operator is in the `Running` state before proceeding\nkubectl -n rook-ceph get pod\n</code></pre> <p>Before starting the operator in production, consider these settings:</p> <ol> <li>Some Rook features are disabled by default. See the operator.yaml for these and other advanced settings.<ol> <li>Device discovery: Rook will watch for new devices to configure if the <code>ROOK_ENABLE_DISCOVERY_DAEMON</code> setting is enabled, commonly used in bare metal clusters.</li> <li>Node affinity and tolerations: The CSI driver by default will run on any node in the cluster. To restrict the CSI driver affinity, several settings are available.</li> </ol> </li> <li>If deploying Rook into a namespace other than the default <code>rook-ceph</code>, see the topic on using an alternative namespace.</li> </ol>"},{"location":"Getting-Started/quickstart/#cluster-environments","title":"Cluster Environments","text":"<p>The Rook documentation is focused around starting Rook in a variety of environments. While creating the cluster in this guide, consider these example cluster manifests:</p> <ul> <li>cluster.yaml: Cluster settings for a production cluster running on bare metal. Requires at least three worker nodes.</li> <li>cluster-on-pvc.yaml: Cluster settings for a production cluster running in a dynamic cloud environment.</li> <li>cluster-test.yaml: Cluster settings for a test environment such as minikube.</li> </ul> <p>See the Ceph example configurations for more details.</p>"},{"location":"Getting-Started/quickstart/#create-a-ceph-cluster","title":"Create a Ceph Cluster","text":"<p>Now that the Rook operator is running we can create the Ceph cluster.</p> <p>Important</p> <p>The Rook Cluster Helm Chart is available to deploy the operator instead of creating the below manifests.</p> <p>Important</p> <p>For the cluster to survive reboots, set the <code>dataDirHostPath</code> property that is valid for the hosts. For more settings, see the documentation on configuring the cluster.</p> <p>Create the cluster:</p> <pre><code>kubectl create -f cluster.yaml\n</code></pre> <p>Verify the cluster is running by viewing the pods in the <code>rook-ceph</code> namespace.</p> <p>The number of osd pods will depend on the number of nodes in the cluster and the number of devices configured. For the default <code>cluster.yaml</code> above, one OSD will be created for each available device found on each node.</p> <p>Hint</p> <p>If the <code>rook-ceph-mon</code>, <code>rook-ceph-mgr</code>, or <code>rook-ceph-osd</code> pods are not created, please refer to the Ceph common issues for more details and potential solutions.</p> <pre><code>$ kubectl -n rook-ceph get pod\nNAME                                                 READY   STATUS      RESTARTS   AGE\ncsi-cephfsplugin-provisioner-d77bb49c6-n5tgs         5/5     Running     0          140s\ncsi-cephfsplugin-provisioner-d77bb49c6-v9rvn         5/5     Running     0          140s\ncsi-cephfsplugin-rthrp                               3/3     Running     0          140s\ncsi-rbdplugin-hbsm7                                  3/3     Running     0          140s\ncsi-rbdplugin-provisioner-5b5cd64fd-nvk6c            6/6     Running     0          140s\ncsi-rbdplugin-provisioner-5b5cd64fd-q7bxl            6/6     Running     0          140s\nrook-ceph-crashcollector-minikube-5b57b7c5d4-hfldl   1/1     Running     0          105s\nrook-ceph-mgr-a-64cd7cdf54-j8b5p                     2/2     Running     0          77s\nrook-ceph-mgr-b-657d54fc89-2xxw7                     2/2     Running     0          56s\nrook-ceph-mon-a-694bb7987d-fp9w7                     1/1     Running     0          105s\nrook-ceph-mon-b-856fdd5cb9-5h2qk                     1/1     Running     0          94s\nrook-ceph-mon-c-57545897fc-j576h                     1/1     Running     0          85s\nrook-ceph-operator-85f5b946bd-s8grz                  1/1     Running     0          92m\nrook-ceph-osd-0-6bb747b6c5-lnvb6                     1/1     Running     0          23s\nrook-ceph-osd-1-7f67f9646d-44p7v                     1/1     Running     0          24s\nrook-ceph-osd-2-6cd4b776ff-v4d68                     1/1     Running     0          25s\nrook-ceph-osd-prepare-node1-vx2rz                    0/2     Completed   0          60s\nrook-ceph-osd-prepare-node2-ab3fd                    0/2     Completed   0          60s\nrook-ceph-osd-prepare-node3-w4xyz                    0/2     Completed   0          60s\n</code></pre> <p>To verify that the cluster is in a healthy state, connect to the Rook toolbox and run the <code>ceph status</code> command.</p> <ul> <li>All mons should be in quorum</li> <li>A mgr should be active</li> <li>At least three OSDs should be <code>up</code> and <code>in</code></li> <li>If the health is not <code>HEALTH_OK</code>, the warnings or errors should be investigated</li> </ul> <pre><code>$ ceph status\n  cluster:\n    id:     a0452c76-30d9-4c1a-a948-5d8405f19a7c\n    health: HEALTH_OK\n\n  services:\n    mon: 3 daemons, quorum a,b,c (age 3m)\n    mgr:a(active, since 2m), standbys: b\n    osd: 3 osds: 3 up (since 1m), 3 in (since 1m)\n[]...]\n</code></pre> <p>Hint</p> <p>If the cluster is not healthy, please refer to the Ceph common issues for potential solutions.</p>"},{"location":"Getting-Started/quickstart/#storage","title":"Storage","text":"<p>For a walkthrough of the three types of storage exposed by Rook, see the guides for:</p> <ul> <li>Block: Create block storage to be consumed by a pod (RWO)</li> <li>Shared Filesystem: Create a filesystem to be shared across multiple pods (RWX)</li> <li>Object: Create an object store that is accessible with an S3 endpoint inside or outside the Kubernetes cluster</li> </ul>"},{"location":"Getting-Started/quickstart/#ceph-dashboard","title":"Ceph Dashboard","text":"<p>Ceph has a dashboard to view the status of the cluster. See the dashboard guide.</p>"},{"location":"Getting-Started/quickstart/#tools","title":"Tools","text":"<p>Create a toolbox pod for full access to a ceph admin client for debugging and troubleshooting the Rook cluster. See the toolbox documentation for setup and usage information.</p> <p>The Rook kubectl plugin provides commands to view status and troubleshoot issues.</p> <p>See the advanced configuration document for helpful maintenance and tuning examples.</p>"},{"location":"Getting-Started/quickstart/#monitoring","title":"Monitoring","text":"<p>Each Rook cluster has built-in metrics collectors/exporters for monitoring with Prometheus. To configure monitoring, see the monitoring guide.</p>"},{"location":"Getting-Started/quickstart/#telemetry","title":"Telemetry","text":"<p>The Rook maintainers would like to receive telemetry reports for Rook clusters. The data is anonymous and does not include any identifying information. Enable the telemetry reporting feature with the following command in the toolbox:</p> <pre><code>ceph telemetry on\n</code></pre> <p>For more details on what is reported and how your privacy is protected, see the Ceph Telemetry Documentation.</p>"},{"location":"Getting-Started/quickstart/#teardown","title":"Teardown","text":"<p>When finished with the test cluster, see the cleanup guide.</p>"},{"location":"Getting-Started/release-cycle/","title":"Release Cycle","text":"<p>Rook plans to release a new minor version three times a year, or about every four months.</p> <p>The most recent two minor Rook releases are actively maintained.</p> <p>Patch releases for the latest minor release are typically bi-weekly. Urgent patches may be released sooner.</p> <p>Patch releases for the previous minor release are commonly monthly, though will vary depending on the urgency of fixes.</p>"},{"location":"Getting-Started/release-cycle/#definition-of-maintenance","title":"Definition of Maintenance","text":"<p>The Rook community defines maintenance in that relevant bug fixes that are merged to the main development branch will be eligible to be back-ported to the release branch of any currently maintained version. Patches will be released as needed. It is also possible that a fix may be merged directly to the release branch if no longer applicable on the main development branch.</p> <p>While Rook maintainers make significant efforts to release urgent issues in a timely manner, maintenance does not indicate any SLA on response time.</p>"},{"location":"Getting-Started/release-cycle/#k8s-versions","title":"K8s Versions","text":"<p>The minimum version supported by a Rook release is specified in the Quickstart Guide.</p> <p>Rook expects to support the most recent six versions of Kubernetes. While these K8s versions may not all be supported by the K8s release cycle, we understand that clusters may take time to update.</p>"},{"location":"Getting-Started/storage-architecture/","title":"Storage Architecture","text":"<p>Ceph is a highly scalable distributed storage solution for block storage, object storage, and shared filesystems with years of production deployments.</p>"},{"location":"Getting-Started/storage-architecture/#design","title":"Design","text":"<p>Rook enables Ceph storage to run on Kubernetes using Kubernetes primitives. With Ceph running in the Kubernetes cluster, Kubernetes applications can mount block devices and filesystems managed by Rook, or can use the S3/Swift API for object storage. The Rook operator automates configuration of storage components and monitors the cluster to ensure the storage remains available and healthy.</p> <p>The Rook operator is a simple container that has all that is needed to bootstrap and monitor the storage cluster. The operator will start and monitor Ceph monitor pods, the Ceph OSD daemons to provide RADOS storage, as well as start and manage other Ceph daemons. The operator manages CRDs for pools, object stores (S3/Swift), and filesystems by initializing the pods and other resources necessary to run the services.</p> <p>The operator will monitor the storage daemons to ensure the cluster is healthy. Ceph mons will be started or failed over when necessary, and other adjustments are made as the cluster grows or shrinks.  The operator will also watch for desired state changes specified in the Ceph custom resources (CRs) and apply the changes.</p> <p>Rook automatically configures the Ceph-CSI driver to mount the storage to your pods. The <code>rook/ceph</code> image includes all necessary tools to manage the cluster. Rook is not in the Ceph data path. Many of the Ceph concepts like placement groups and crush maps are hidden so you don't have to worry about them. Instead, Rook creates a simplified user experience for admins that is in terms of physical resources, pools, volumes, filesystems, and buckets. Advanced configuration can be applied when needed with the Ceph tools.</p> <p>Rook is implemented in golang. Ceph is implemented in C++ where the data path is highly optimized. We believe this combination offers the best of both worlds.</p>"},{"location":"Getting-Started/storage-architecture/#architecture","title":"Architecture","text":"<p>Example applications are shown above for the three supported storage types:</p> <ul> <li>Block Storage is represented with a blue app, which has a <code>ReadWriteOnce (RWO)</code> volume mounted. The application can read and write to the RWO volume, while Ceph manages the IO.</li> <li>Shared Filesystem is represented by two purple apps that are sharing a ReadWriteMany (RWX) volume. Both applications can actively read or write simultaneously to the volume. Ceph will ensure the data is safely protected for multiple writers with the MDS daemon.</li> <li>Object storage is represented by an orange app that can read and write to a bucket with a standard S3 client.</li> </ul> <p>Below the dotted line in the above diagram, the components fall into three categories:</p> <ul> <li>Rook operator (blue layer): The operator automates configuration of Ceph</li> <li>CSI plugins and provisioners (orange layer): The Ceph-CSI driver provides the provisioning and mounting of volumes</li> <li>Ceph daemons (red layer): The Ceph daemons run the core storage architecture. See the Glossary to learn more about each daemon.</li> </ul> <p>Production clusters must have three or more nodes for a resilient storage platform.</p>"},{"location":"Getting-Started/storage-architecture/#block-storage","title":"Block Storage","text":"<p>In the diagram above, the flow to create an application with an RWO volume is:</p> <ul> <li>The (blue) app creates a PVC to request storage</li> <li>The PVC defines the Ceph RBD storage class (sc) for provisioning the storage</li> <li>K8s calls the Ceph-CSI RBD provisioner to create the Ceph RBD image.</li> <li>The kubelet calls the CSI RBD volume plugin to mount the volume in the app</li> <li>The volume is now available for reads and writes.</li> </ul> <p>A ReadWriteOnce volume can be mounted on one node at a time.</p>"},{"location":"Getting-Started/storage-architecture/#shared-filesystem","title":"Shared Filesystem","text":"<p>In the diagram above, the flow to create a applications with a RWX volume is:</p> <ul> <li>The (purple) app creates a PVC to request storage</li> <li>The PVC defines the CephFS storage class (sc) for provisioning the storage</li> <li>K8s calls the Ceph-CSI CephFS provisioner to create the CephFS subvolume</li> <li>The kubelet calls the CSI CephFS volume plugin to mount the volume in the app</li> <li>The volume is now available for reads and writes.</li> </ul> <p>A ReadWriteMany volume can be mounted on multiple nodes for your application to use.</p>"},{"location":"Getting-Started/storage-architecture/#object-storage-s3","title":"Object Storage S3","text":"<p>In the diagram above, the flow to create an application with access to an S3 bucket is:</p> <ul> <li>The (orange) app creates an ObjectBucketClaim (OBC) to request a bucket</li> <li>The Rook operator creates a Ceph RGW bucket (via the lib-bucket-provisioner)</li> <li>The Rook operator creates a secret with the credentials for accessing the bucket and a configmap with bucket information</li> <li>The app retrieves the credentials from the secret</li> <li>The app can now read and write to the bucket with an S3 client</li> </ul> <p>A S3 compatible client can use the S3 bucket right away using the credentials (<code>Secret</code>) and bucket info (<code>ConfigMap</code>).</p>"},{"location":"Getting-Started/Prerequisites/authenticated-registry/","title":"Authenticated Container Registries","text":"<p>If you want to use an image from authenticated docker registry (e.g. for image cache/mirror), you'll need to add an <code>imagePullSecret</code> to all relevant service accounts. See the next section for the required service accounts.</p> <p>The whole process is described in the official kubernetes documentation.</p>"},{"location":"Getting-Started/Prerequisites/authenticated-registry/#example-setup-for-a-ceph-cluster","title":"Example setup for a ceph cluster","text":"<p>To get you started, here's a quick rundown for the ceph example from the quickstart guide.</p> <p>First, we'll create the secret for our registry as described here (the secret will be created in the <code>rook-ceph</code> namespace, make sure to change it if your Rook Ceph Operator/Cluster is in another namespace):</p> <pre><code>kubectl -n rook-ceph create secret docker-registry my-registry-secret --docker-server=DOCKER_REGISTRY_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL\n</code></pre> <p>Next we'll add the following snippet to all relevant service accounts as described here:</p> <pre><code>imagePullSecrets:\n- name: my-registry-secret\n</code></pre> <p>The service accounts are:</p> <ul> <li><code>rook-ceph-system</code> (namespace: <code>rook-ceph</code>): Will affect all pods created by the rook operator in the <code>rook-ceph</code> namespace.</li> <li><code>rook-ceph-default</code> (namespace: <code>rook-ceph</code>): Will affect most pods in the <code>rook-ceph</code> namespace.</li> <li><code>rook-ceph-mgr</code> (namespace: <code>rook-ceph</code>): Will affect the MGR pods in the <code>rook-ceph</code> namespace.</li> <li><code>rook-ceph-osd</code> (namespace: <code>rook-ceph</code>): Will affect the OSD pods in the <code>rook-ceph</code> namespace.</li> <li><code>rook-ceph-rgw</code> (namespace: <code>rook-ceph</code>): Will affect the RGW pods in the <code>rook-ceph</code> namespace.</li> </ul> <p>Since it's the same procedure for all service accounts, here is just one example:</p> <pre><code>kubectl -n rook-ceph edit serviceaccount rook-ceph-default\n</code></pre> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: rook-ceph-default\n  namespace: rook-ceph\nsecrets:\n- name: default-token-12345\n# Add the highlighted lines:\nimagePullSecrets:\n- name: my-registry-secret\n</code></pre> <p>After doing this for all service accounts all pods should be able to pull the image from your registry.</p>"},{"location":"Getting-Started/Prerequisites/prerequisites/","title":"Prerequisites","text":"<p>Rook can be installed on any existing Kubernetes cluster as long as it meets the minimum version and Rook is granted the required privileges (see below for more information).</p>"},{"location":"Getting-Started/Prerequisites/prerequisites/#kubernetes-version","title":"Kubernetes Version","text":"<p>Kubernetes versions v1.27 through v1.31 are supported.</p>"},{"location":"Getting-Started/Prerequisites/prerequisites/#cpu-architecture","title":"CPU Architecture","text":"<p>Architectures supported are <code>amd64 / x86_64</code> and <code>arm64</code>.</p>"},{"location":"Getting-Started/Prerequisites/prerequisites/#ceph-prerequisites","title":"Ceph Prerequisites","text":"<p>To configure the Ceph storage cluster, at least one of these local storage types is required:</p> <ul> <li>Raw devices (no partitions or formatted filesystems)</li> <li>Raw partitions (no formatted filesystem)</li> <li>LVM Logical Volumes (no formatted filesystem)</li> <li>Persistent Volumes available from a storage class in <code>block</code> mode</li> </ul> <p>Confirm whether the partitions or devices are formatted with filesystems with the following command:</p> <pre><code>$ lsblk -f\nNAME                  FSTYPE      LABEL UUID                                   MOUNTPOINT\nvda\n\u2514\u2500vda1                LVM2_member       &gt;eSO50t-GkUV-YKTH-WsGq-hNJY-eKNf-3i07IB\n  \u251c\u2500ubuntu--vg-root   ext4              c2366f76-6e21-4f10-a8f3-6776212e2fe4   /\n  \u2514\u2500ubuntu--vg-swap_1 swap              9492a3dc-ad75-47cd-9596-678e8cf17ff9   [SWAP]\nvdb\n</code></pre> <p>If the <code>FSTYPE</code> field is not empty, there is a filesystem on top of the corresponding device. In this example, <code>vdb</code> is available to Rook, while <code>vda</code> and its partitions have a filesystem and are not available.</p>"},{"location":"Getting-Started/Prerequisites/prerequisites/#lvm-package","title":"LVM package","text":"<p>Ceph OSDs have a dependency on LVM in the following scenarios:</p> <ul> <li>If encryption is enabled (<code>encryptedDevice: \"true\"</code> in the cluster CR)</li> <li>A <code>metadata</code> device is specified</li> <li><code>osdsPerDevice</code> is greater than 1</li> </ul> <p>LVM is not required for OSDs in these scenarios:</p> <ul> <li>OSDs are created on raw devices or partitions</li> <li>OSDs are created on PVCs using the <code>storageClassDeviceSets</code></li> </ul> <p>If LVM is required, LVM needs to be available on the hosts where OSDs will be running. Some Linux distributions do not ship with the <code>lvm2</code> package. This package is required on all storage nodes in the k8s cluster to run Ceph OSDs. Without this package even though Rook will be able to successfully create the Ceph OSDs, when a node is rebooted the OSD pods running on the restarted node will fail to start. Please install LVM using your Linux distribution's package manager. For example:</p> <p>CentOS:</p> <pre><code>sudo yum install -y lvm2\n</code></pre> <p>Ubuntu:</p> <pre><code>sudo apt-get install -y lvm2\n</code></pre> <p>RancherOS:</p> <ul> <li>Since version 1.5.0 LVM is supported</li> <li>Logical volumes will not be activated during the boot process. You need to add an runcmd command for that.</li> </ul> <pre><code>runcmd:\n- [ \"vgchange\", \"-ay\" ]\n</code></pre>"},{"location":"Getting-Started/Prerequisites/prerequisites/#kernel","title":"Kernel","text":""},{"location":"Getting-Started/Prerequisites/prerequisites/#rbd","title":"RBD","text":"<p>Ceph requires a Linux kernel built with the RBD module. Many Linux distributions have this module, but not all. For example, the GKE Container-Optimised OS (COS) does not have RBD.</p> <p>Test your Kubernetes nodes by running <code>modprobe rbd</code>. If the rbd module is 'not found', rebuild the kernel to include the <code>rbd</code> module, install a newer kernel, or choose a different Linux distribution.</p> <p>Rook's default RBD configuration specifies only the <code>layering</code> feature, for broad compatibility with older kernels. If your Kubernetes nodes run a 5.4 or later kernel, additional feature flags can be enabled in the storage class. The <code>fast-diff</code> and <code>object-map</code> features are especially useful.</p> <pre><code>imageFeatures: layering,fast-diff,object-map,deep-flatten,exclusive-lock\n</code></pre>"},{"location":"Getting-Started/Prerequisites/prerequisites/#cephfs","title":"CephFS","text":"<p>If creating RWX volumes from a Ceph shared file system (CephFS), the recommended minimum kernel version is 4.17. If the kernel version is less than 4.17, the requested PVC sizes will not be enforced. Storage quotas will only be enforced on newer kernels.</p>"},{"location":"Getting-Started/Prerequisites/prerequisites/#distro-notes","title":"Distro Notes","text":"<p>Specific configurations for some distributions.</p>"},{"location":"Getting-Started/Prerequisites/prerequisites/#nixos","title":"NixOS","text":"<p>For NixOS, the kernel modules will be found in the non-standard path <code>/run/current-system/kernel-modules/lib/modules/</code>, and they'll be symlinked inside the also non-standard path <code>/nix</code>.</p> <p>Rook containers require read access to those locations to be able to load the required modules. They have to be bind-mounted as volumes in the CephFS and RBD plugin pods.</p> <p>If installing Rook with Helm, uncomment these example settings in <code>values.yaml</code>:</p> <ul> <li><code>csi.csiCephFSPluginVolume</code></li> <li><code>csi.csiCephFSPluginVolumeMount</code></li> <li><code>csi.csiRBDPluginVolume</code></li> <li><code>csi.csiRBDPluginVolumeMount</code></li> </ul> <p>If deploying without Helm, add those same values to the settings in the <code>rook-ceph-operator-config</code> ConfigMap found in operator.yaml:</p> <ul> <li><code>CSI_CEPHFS_PLUGIN_VOLUME</code></li> <li><code>CSI_CEPHFS_PLUGIN_VOLUME_MOUNT</code></li> <li><code>CSI_RBD_PLUGIN_VOLUME</code></li> <li><code>CSI_RBD_PLUGIN_VOLUME_MOUNT</code></li> </ul> <p>If using containerd, remove <code>LimitNOFILE</code> from containerd service config to avoid issues like slow ceph commands or mons falling out of quorum.</p> <pre><code>systemd.services.containerd.serviceConfig = {\n  LimitNOFILE = lib.mkForce null;\n};\n</code></pre>"},{"location":"Helm-Charts/ceph-cluster-chart/","title":"Ceph Cluster Helm Chart","text":"<p>Creates Rook resources to configure a Ceph cluster using the Helm package manager. This chart is a simple packaging of templates that will optionally create Rook resources such as:</p> <ul> <li>CephCluster, CephFilesystem, and CephObjectStore CRs</li> <li>Storage classes to expose Ceph RBD volumes, CephFS volumes, and RGW buckets</li> <li>Ingress for external access to the dashboard</li> <li>Toolbox</li> </ul>"},{"location":"Helm-Charts/ceph-cluster-chart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes 1.22+</li> <li>Helm 3.x</li> <li>Install the Rook Operator chart</li> </ul>"},{"location":"Helm-Charts/ceph-cluster-chart/#installing","title":"Installing","text":"<p>The <code>helm install</code> command deploys rook on the Kubernetes cluster in the default configuration. The configuration section lists the parameters that can be configured during installation. It is recommended that the rook operator be installed into the <code>rook-ceph</code> namespace. The clusters can be installed into the same namespace as the operator or a separate namespace.</p> <p>Rook currently publishes builds of this chart to the <code>release</code> and <code>master</code> channels.</p> <p>Before installing, review the values.yaml to confirm if the default settings need to be updated.</p> <ul> <li>If the operator was installed in a namespace other than <code>rook-ceph</code>, the namespace   must be set in the <code>operatorNamespace</code> variable.</li> <li>Set the desired settings in the <code>cephClusterSpec</code>. The defaults   are only an example and not likely to apply to your cluster.</li> <li>The <code>monitoring</code> section should be removed from the <code>cephClusterSpec</code>, as it is specified separately in the helm settings.</li> <li>The default values for <code>cephBlockPools</code>, <code>cephFileSystems</code>, and <code>CephObjectStores</code> will create one of each, and their corresponding storage classes.</li> <li>All Ceph components now have default values for the pod resources. The resources may need to be adjusted in production clusters depending on the load. The resources can also be disabled if Ceph should not be limited (e.g. test clusters).</li> </ul>"},{"location":"Helm-Charts/ceph-cluster-chart/#release","title":"Release","text":"<p>The release channel is the most recent release of Rook that is considered stable for the community.</p> <p>The example install assumes you have first installed the Rook Operator Helm Chart and created your customized values.yaml.</p> <pre><code>helm repo add rook-release https://charts.rook.io/release\nhelm install --create-namespace --namespace rook-ceph rook-ceph-cluster \\\n   --set operatorNamespace=rook-ceph rook-release/rook-ceph-cluster -f values.yaml\n</code></pre> <p>Note</p> <p>--namespace specifies the cephcluster namespace, which may be different from the rook operator namespace.</p>"},{"location":"Helm-Charts/ceph-cluster-chart/#configuration","title":"Configuration","text":"<p>The following table lists the configurable parameters of the rook-operator chart and their default values.</p> Parameter Description Default <code>cephBlockPools</code> A list of CephBlockPool configurations to deploy See below <code>cephBlockPoolsVolumeSnapshotClass</code> Settings for the block pool snapshot class See RBD Snapshots <code>cephClusterSpec</code> Cluster configuration. See below <code>cephFileSystemVolumeSnapshotClass</code> Settings for the filesystem snapshot class See CephFS Snapshots <code>cephFileSystems</code> A list of CephFileSystem configurations to deploy See below <code>cephObjectStores</code> A list of CephObjectStore configurations to deploy See below <code>clusterName</code> The metadata.name of the CephCluster CR The same as the namespace <code>configOverride</code> Cluster ceph.conf override <code>nil</code> <code>csiDriverNamePrefix</code> CSI driver name prefix for cephfs, rbd and nfs. <code>namespace name where rook-ceph operator is deployed</code> <code>ingress.dashboard</code> Enable an ingress for the ceph-dashboard <code>{}</code> <code>kubeVersion</code> Optional override of the target kubernetes version <code>nil</code> <code>monitoring.createPrometheusRules</code> Whether to create the Prometheus rules for Ceph alerts <code>false</code> <code>monitoring.enabled</code> Enable Prometheus integration, will also create necessary RBAC rules to allow Operator to create ServiceMonitors. Monitoring requires Prometheus to be pre-installed <code>false</code> <code>monitoring.prometheusRule.annotations</code> Annotations applied to PrometheusRule <code>{}</code> <code>monitoring.prometheusRule.labels</code> Labels applied to PrometheusRule <code>{}</code> <code>monitoring.rulesNamespaceOverride</code> The namespace in which to create the prometheus rules, if different from the rook cluster namespace. If you have multiple rook-ceph clusters in the same k8s cluster, choose the same namespace (ideally, namespace with prometheus deployed) to set rulesNamespaceOverride for all the clusters. Otherwise, you will get duplicate alerts with multiple alert definitions. <code>nil</code> <code>operatorNamespace</code> Namespace of the main rook operator <code>\"rook-ceph\"</code> <code>pspEnable</code> Create &amp; use PSP resources. Set this to the same value as the rook-ceph chart. <code>false</code> <code>toolbox.affinity</code> Toolbox affinity <code>{}</code> <code>toolbox.containerSecurityContext</code> Toolbox container security context <code>{\"capabilities\":{\"drop\":[\"ALL\"]},\"runAsGroup\":2016,\"runAsNonRoot\":true,\"runAsUser\":2016}</code> <code>toolbox.enabled</code> Enable Ceph debugging pod deployment. See toolbox <code>false</code> <code>toolbox.image</code> Toolbox image, defaults to the image used by the Ceph cluster <code>nil</code> <code>toolbox.priorityClassName</code> Set the priority class for the toolbox if desired <code>nil</code> <code>toolbox.resources</code> Toolbox resources <code>{\"limits\":{\"memory\":\"1Gi\"},\"requests\":{\"cpu\":\"100m\",\"memory\":\"128Mi\"}}</code> <code>toolbox.tolerations</code> Toolbox tolerations <code>[]</code>"},{"location":"Helm-Charts/ceph-cluster-chart/#ceph-cluster-spec","title":"Ceph Cluster Spec","text":"<p>The <code>CephCluster</code> CRD takes its spec from <code>cephClusterSpec.*</code>. This is not an exhaustive list of parameters. For the full list, see the Cluster CRD topic.</p> <p>The cluster spec example is for a converged cluster where all the Ceph daemons are running locally, as in the host-based example (cluster.yaml). For a different configuration such as a PVC-based cluster (cluster-on-pvc.yaml), external cluster (cluster-external.yaml), or stretch cluster (cluster-stretched.yaml), replace this entire <code>cephClusterSpec</code> with the specs from those examples.</p>"},{"location":"Helm-Charts/ceph-cluster-chart/#ceph-block-pools","title":"Ceph Block Pools","text":"<p>The <code>cephBlockPools</code> array in the values file will define a list of CephBlockPool as described in the table below.</p> Parameter Description Default <code>name</code> The name of the CephBlockPool <code>ceph-blockpool</code> <code>spec</code> The CephBlockPool spec, see the CephBlockPool documentation. <code>{}</code> <code>storageClass.enabled</code> Whether a storage class is deployed alongside the CephBlockPool <code>true</code> <code>storageClass.isDefault</code> Whether the storage class will be the default storage class for PVCs. See PersistentVolumeClaim documentation for details. <code>true</code> <code>storageClass.name</code> The name of the storage class <code>ceph-block</code> <code>storageClass.annotations</code> Additional storage class annotations <code>{}</code> <code>storageClass.labels</code> Additional storage class labels <code>{}</code> <code>storageClass.parameters</code> See Block Storage documentation or the helm values.yaml for suitable values see values.yaml <code>storageClass.reclaimPolicy</code> The default Reclaim Policy to apply to PVCs created with this storage class. <code>Delete</code> <code>storageClass.allowVolumeExpansion</code> Whether volume expansion is allowed by default. <code>true</code> <code>storageClass.mountOptions</code> Specifies the mount options for storageClass <code>[]</code> <code>storageClass.allowedTopologies</code> Specifies the allowedTopologies for storageClass <code>[]</code>"},{"location":"Helm-Charts/ceph-cluster-chart/#ceph-file-systems","title":"Ceph File Systems","text":"<p>The <code>cephFileSystems</code> array in the values file will define a list of CephFileSystem as described in the table below.</p> Parameter Description Default <code>name</code> The name of the CephFileSystem <code>ceph-filesystem</code> <code>spec</code> The CephFileSystem spec, see the CephFilesystem CRD documentation. see values.yaml <code>storageClass.enabled</code> Whether a storage class is deployed alongside the CephFileSystem <code>true</code> <code>storageClass.name</code> The name of the storage class <code>ceph-filesystem</code> <code>storageClass.annotations</code> Additional storage class annotations <code>{}</code> <code>storageClass.labels</code> Additional storage class labels <code>{}</code> <code>storageClass.pool</code> The name of Data Pool, without the filesystem name prefix <code>data0</code> <code>storageClass.parameters</code> See Shared Filesystem documentation or the helm values.yaml for suitable values see values.yaml <code>storageClass.reclaimPolicy</code> The default Reclaim Policy to apply to PVCs created with this storage class. <code>Delete</code> <code>storageClass.mountOptions</code> Specifies the mount options for storageClass <code>[]</code>"},{"location":"Helm-Charts/ceph-cluster-chart/#ceph-object-stores","title":"Ceph Object Stores","text":"<p>The <code>cephObjectStores</code> array in the values file will define a list of CephObjectStore as described in the table below.</p> Parameter Description Default <code>name</code> The name of the CephObjectStore <code>ceph-objectstore</code> <code>spec</code> The CephObjectStore spec, see the CephObjectStore CRD documentation. see values.yaml <code>storageClass.enabled</code> Whether a storage class is deployed alongside the CephObjectStore <code>true</code> <code>storageClass.name</code> The name of the storage class <code>ceph-bucket</code> <code>storageClass.annotations</code> Additional storage class annotations <code>{}</code> <code>storageClass.labels</code> Additional storage class labels <code>{}</code> <code>storageClass.parameters</code> See Object Store storage class documentation or the helm values.yaml for suitable values see values.yaml <code>storageClass.reclaimPolicy</code> The default Reclaim Policy to apply to PVCs created with this storage class. <code>Delete</code> <code>ingress.enabled</code> Enable an ingress for the object store <code>false</code> <code>ingress.annotations</code> Ingress annotations <code>{}</code> <code>ingress.host.name</code> Ingress hostname <code>\"\"</code> <code>ingress.host.path</code> Ingress path prefix <code>/</code> <code>ingress.tls</code> Ingress tls <code>/</code> <code>ingress.ingressClassName</code> Ingress tls <code>\"\"</code>"},{"location":"Helm-Charts/ceph-cluster-chart/#existing-clusters","title":"Existing Clusters","text":"<p>If you have an existing CephCluster CR that was created without the helm chart and you want the helm chart to start managing the cluster:</p> <ol> <li> <p>Extract the <code>spec</code> section of your existing CephCluster CR and copy to the <code>cephClusterSpec</code>    section in <code>values.yaml</code>.</p> </li> <li> <p>Add the following annotations and label to your existing CephCluster CR:</p> </li> </ol> <pre><code>  annotations:\n    meta.helm.sh/release-name: rook-ceph-cluster\n    meta.helm.sh/release-namespace: rook-ceph\n  labels:\n    app.kubernetes.io/managed-by: Helm\n</code></pre> <ol> <li> <p>Run the <code>helm install</code> command in the Installing section to create the chart.</p> </li> <li> <p>In the future when updates to the cluster are needed, ensure the values.yaml always    contains the desired CephCluster spec.</p> </li> </ol>"},{"location":"Helm-Charts/ceph-cluster-chart/#development-build","title":"Development Build","text":"<p>To deploy from a local build from your development environment:</p> <pre><code>cd deploy/charts/rook-ceph-cluster\nhelm install --create-namespace --namespace rook-ceph rook-ceph-cluster -f values.yaml .\n</code></pre>"},{"location":"Helm-Charts/ceph-cluster-chart/#uninstalling-the-chart","title":"Uninstalling the Chart","text":"<p>To see the currently installed Rook chart:</p> <pre><code>helm ls --namespace rook-ceph\n</code></pre> <p>To uninstall/delete the <code>rook-ceph-cluster</code> chart:</p> <pre><code>helm delete --namespace rook-ceph rook-ceph-cluster\n</code></pre> <p>The command removes all the Kubernetes components associated with the chart and deletes the release. Removing the cluster chart does not remove the Rook operator. In addition, all data on hosts in the Rook data directory (<code>/var/lib/rook</code> by default) and on OSD raw devices is kept. To reuse disks, you will have to wipe them before recreating the cluster.</p> <p>See the teardown documentation for more information.</p>"},{"location":"Helm-Charts/helm-charts/","title":"Helm Charts Overview","text":"<p>Rook has published the following Helm charts for the Ceph storage provider:</p> <ul> <li>Rook Ceph Operator: Starts the Ceph Operator, which will watch for Ceph CRs (custom resources)</li> <li>Rook Ceph Cluster: Creates Ceph CRs that the operator will use to configure the cluster</li> </ul> <p>The Helm charts are intended to simplify deployment and upgrades. Configuring the Rook resources without Helm is also fully supported by creating the manifests directly.</p>"},{"location":"Helm-Charts/operator-chart/","title":"Ceph Operator Helm Chart","text":"<p>Installs rook to create, configure, and manage Ceph clusters on Kubernetes.</p>"},{"location":"Helm-Charts/operator-chart/#introduction","title":"Introduction","text":"<p>This chart bootstraps a rook-ceph-operator deployment on a Kubernetes cluster using the Helm package manager.</p>"},{"location":"Helm-Charts/operator-chart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes 1.22+</li> <li>Helm 3.x</li> </ul> <p>See the Helm support matrix for more details.</p>"},{"location":"Helm-Charts/operator-chart/#installing","title":"Installing","text":"<p>The Ceph Operator helm chart will install the basic components necessary to create a storage platform for your Kubernetes cluster.</p> <ol> <li>Install the Helm chart</li> <li>Create a Rook cluster.</li> </ol> <p>The <code>helm install</code> command deploys rook on the Kubernetes cluster in the default configuration. The configuration section lists the parameters that can be configured during installation. It is recommended that the rook operator be installed into the <code>rook-ceph</code> namespace (you will install your clusters into separate namespaces).</p> <p>Rook currently publishes builds of the Ceph operator to the <code>release</code> and <code>master</code> channels.</p>"},{"location":"Helm-Charts/operator-chart/#release","title":"Release","text":"<p>The release channel is the most recent release of Rook that is considered stable for the community.</p> <pre><code>helm repo add rook-release https://charts.rook.io/release\nhelm install --create-namespace --namespace rook-ceph rook-ceph rook-release/rook-ceph -f values.yaml\n</code></pre> <p>For example settings, see the next section or values.yaml</p>"},{"location":"Helm-Charts/operator-chart/#configuration","title":"Configuration","text":"<p>The following table lists the configurable parameters of the rook-operator chart and their default values.</p> Parameter Description Default <code>allowLoopDevices</code> If true, loop devices are allowed to be used for osds in test clusters <code>false</code> <code>annotations</code> Pod annotations <code>{}</code> <code>cephCommandsTimeoutSeconds</code> The timeout for ceph commands in seconds <code>\"15\"</code> <code>containerSecurityContext</code> Set the container security context for the operator <code>{\"capabilities\":{\"drop\":[\"ALL\"]},\"runAsGroup\":2016,\"runAsNonRoot\":true,\"runAsUser\":2016}</code> <code>crds.enabled</code> Whether the helm chart should create and update the CRDs. If false, the CRDs must be managed independently with deploy/examples/crds.yaml. WARNING Only set during first deployment. If later disabled the cluster may be DESTROYED. If the CRDs are deleted in this case, see the disaster recovery guide to restore them. <code>true</code> <code>csi.attacher.repository</code> Kubernetes CSI Attacher image repository <code>\"registry.k8s.io/sig-storage/csi-attacher\"</code> <code>csi.attacher.tag</code> Attacher image tag <code>\"v4.6.1\"</code> <code>csi.cephFSAttachRequired</code> Whether to skip any attach operation altogether for CephFS PVCs. See more details here. If cephFSAttachRequired is set to false it skips the volume attachments and makes the creation of pods using the CephFS PVC fast. WARNING It's highly discouraged to use this for CephFS RWO volumes. Refer to this issue for more details. <code>true</code> <code>csi.cephFSFSGroupPolicy</code> Policy for modifying a volume's ownership or permissions when the CephFS PVC is being mounted. supported values are documented at https://kubernetes-csi.github.io/docs/support-fsgroup.html <code>\"File\"</code> <code>csi.cephFSKernelMountOptions</code> Set CephFS Kernel mount options to use https://docs.ceph.com/en/latest/man/8/mount.ceph/#options. Set to \"ms_mode=secure\" when connections.encrypted is enabled in CephCluster CR <code>nil</code> <code>csi.cephFSPluginUpdateStrategy</code> CSI CephFS plugin daemonset update strategy, supported values are OnDelete and RollingUpdate <code>RollingUpdate</code> <code>csi.cephFSPluginUpdateStrategyMaxUnavailable</code> A maxUnavailable parameter of CSI cephFS plugin daemonset update strategy. <code>1</code> <code>csi.cephcsi.repository</code> Ceph CSI image repository <code>\"quay.io/cephcsi/cephcsi\"</code> <code>csi.cephcsi.tag</code> Ceph CSI image tag <code>\"v3.12.3\"</code> <code>csi.cephfsLivenessMetricsPort</code> CSI CephFS driver metrics port <code>9081</code> <code>csi.cephfsPodLabels</code> Labels to add to the CSI CephFS Deployments and DaemonSets Pods <code>nil</code> <code>csi.clusterName</code> Cluster name identifier to set as metadata on the CephFS subvolume and RBD images. This will be useful in cases like for example, when two container orchestrator clusters (Kubernetes/OCP) are using a single ceph cluster <code>nil</code> <code>csi.csiAddons.enabled</code> Enable CSIAddons <code>false</code> <code>csi.csiAddons.repository</code> CSIAddons sidecar image repository <code>\"quay.io/csiaddons/k8s-sidecar\"</code> <code>csi.csiAddons.tag</code> CSIAddons sidecar image tag <code>\"v0.11.0\"</code> <code>csi.csiAddonsPort</code> CSI Addons server port <code>9070</code> <code>csi.csiCephFSPluginResource</code> CEPH CSI CephFS plugin resource requirement list see values.yaml <code>csi.csiCephFSPluginVolume</code> The volume of the CephCSI CephFS plugin DaemonSet <code>nil</code> <code>csi.csiCephFSPluginVolumeMount</code> The volume mounts of the CephCSI CephFS plugin DaemonSet <code>nil</code> <code>csi.csiCephFSProvisionerResource</code> CEPH CSI CephFS provisioner resource requirement list see values.yaml <code>csi.csiDriverNamePrefix</code> CSI driver name prefix for cephfs, rbd and nfs. <code>namespace name where rook-ceph operator is deployed</code> <code>csi.csiLeaderElectionLeaseDuration</code> Duration in seconds that non-leader candidates will wait to force acquire leadership. <code>137s</code> <code>csi.csiLeaderElectionRenewDeadline</code> Deadline in seconds that the acting leader will retry refreshing leadership before giving up. <code>107s</code> <code>csi.csiLeaderElectionRetryPeriod</code> Retry period in seconds the LeaderElector clients should wait between tries of actions. <code>26s</code> <code>csi.csiNFSPluginResource</code> CEPH CSI NFS plugin resource requirement list see values.yaml <code>csi.csiNFSProvisionerResource</code> CEPH CSI NFS provisioner resource requirement list see values.yaml <code>csi.csiRBDPluginResource</code> CEPH CSI RBD plugin resource requirement list see values.yaml <code>csi.csiRBDPluginVolume</code> The volume of the CephCSI RBD plugin DaemonSet <code>nil</code> <code>csi.csiRBDPluginVolumeMount</code> The volume mounts of the CephCSI RBD plugin DaemonSet <code>nil</code> <code>csi.csiRBDProvisionerResource</code> CEPH CSI RBD provisioner resource requirement list csi-omap-generator resources will be applied only if <code>enableOMAPGenerator</code> is set to <code>true</code> see values.yaml <code>csi.disableCsiDriver</code> Disable the CSI driver. <code>\"false\"</code> <code>csi.enableCSIEncryption</code> Enable Ceph CSI PVC encryption support <code>false</code> <code>csi.enableCSIHostNetwork</code> Enable host networking for CSI CephFS and RBD nodeplugins. This may be necessary in some network configurations where the SDN does not provide access to an external cluster or there is significant drop in read/write performance <code>true</code> <code>csi.enableCephfsDriver</code> Enable Ceph CSI CephFS driver <code>true</code> <code>csi.enableCephfsSnapshotter</code> Enable Snapshotter in CephFS provisioner pod <code>true</code> <code>csi.enableLiveness</code> Enable Ceph CSI Liveness sidecar deployment <code>false</code> <code>csi.enableMetadata</code> Enable adding volume metadata on the CephFS subvolumes and RBD images. Not all users might be interested in getting volume/snapshot details as metadata on CephFS subvolume and RBD images. Hence enable metadata is false by default <code>false</code> <code>csi.enableNFSSnapshotter</code> Enable Snapshotter in NFS provisioner pod <code>true</code> <code>csi.enableOMAPGenerator</code> OMAP generator generates the omap mapping between the PV name and the RBD image which helps CSI to identify the rbd images for CSI operations. <code>CSI_ENABLE_OMAP_GENERATOR</code> needs to be enabled when we are using rbd mirroring feature. By default OMAP generator is disabled and when enabled, it will be deployed as a sidecar with CSI provisioner pod, to enable set it to true. <code>false</code> <code>csi.enablePluginSelinuxHostMount</code> Enable Host mount for <code>/etc/selinux</code> directory for Ceph CSI nodeplugins <code>false</code> <code>csi.enableRBDSnapshotter</code> Enable Snapshotter in RBD provisioner pod <code>true</code> <code>csi.enableRbdDriver</code> Enable Ceph CSI RBD driver <code>true</code> <code>csi.enableVolumeGroupSnapshot</code> Enable volume group snapshot feature. This feature is enabled by default as long as the necessary CRDs are available in the cluster. <code>true</code> <code>csi.forceCephFSKernelClient</code> Enable Ceph Kernel clients on kernel &lt; 4.17. If your kernel does not support quotas for CephFS you may want to disable this setting. However, this will cause an issue during upgrades with the FUSE client. See the upgrade guide <code>true</code> <code>csi.grpcTimeoutInSeconds</code> Set GRPC timeout for csi containers (in seconds). It should be &gt;= 120. If this value is not set or is invalid, it defaults to 150 <code>150</code> <code>csi.imagePullPolicy</code> Image pull policy <code>\"IfNotPresent\"</code> <code>csi.kubeApiBurst</code> Burst to use while communicating with the kubernetes apiserver. <code>nil</code> <code>csi.kubeApiQPS</code> QPS to use while communicating with the kubernetes apiserver. <code>nil</code> <code>csi.kubeletDirPath</code> Kubelet root directory path (if the Kubelet uses a different path for the <code>--root-dir</code> flag) <code>/var/lib/kubelet</code> <code>csi.logLevel</code> Set logging level for cephCSI containers maintained by the cephCSI. Supported values from 0 to 5. 0 for general useful logs, 5 for trace level verbosity. <code>0</code> <code>csi.nfs.enabled</code> Enable the nfs csi driver <code>false</code> <code>csi.nfsAttachRequired</code> Whether to skip any attach operation altogether for NFS PVCs. See more details here. If cephFSAttachRequired is set to false it skips the volume attachments and makes the creation of pods using the NFS PVC fast. WARNING It's highly discouraged to use this for NFS RWO volumes. Refer to this issue for more details. <code>true</code> <code>csi.nfsFSGroupPolicy</code> Policy for modifying a volume's ownership or permissions when the NFS PVC is being mounted. supported values are documented at https://kubernetes-csi.github.io/docs/support-fsgroup.html <code>\"File\"</code> <code>csi.nfsPluginUpdateStrategy</code> CSI NFS plugin daemonset update strategy, supported values are OnDelete and RollingUpdate <code>RollingUpdate</code> <code>csi.nfsPodLabels</code> Labels to add to the CSI NFS Deployments and DaemonSets Pods <code>nil</code> <code>csi.pluginNodeAffinity</code> The node labels for affinity of the CephCSI RBD plugin DaemonSet <sup>1</sup> <code>nil</code> <code>csi.pluginPriorityClassName</code> PriorityClassName to be set on csi driver plugin pods <code>\"system-node-critical\"</code> <code>csi.pluginTolerations</code> Array of tolerations in YAML format which will be added to CephCSI plugin DaemonSet <code>nil</code> <code>csi.provisioner.repository</code> Kubernetes CSI provisioner image repository <code>\"registry.k8s.io/sig-storage/csi-provisioner\"</code> <code>csi.provisioner.tag</code> Provisioner image tag <code>\"v5.0.1\"</code> <code>csi.provisionerNodeAffinity</code> The node labels for affinity of the CSI provisioner deployment <sup>1</sup> <code>nil</code> <code>csi.provisionerPriorityClassName</code> PriorityClassName to be set on csi driver provisioner pods <code>\"system-cluster-critical\"</code> <code>csi.provisionerReplicas</code> Set replicas for csi provisioner deployment <code>2</code> <code>csi.provisionerTolerations</code> Array of tolerations in YAML format which will be added to CSI provisioner deployment <code>nil</code> <code>csi.rbdAttachRequired</code> Whether to skip any attach operation altogether for RBD PVCs. See more details here. If set to false it skips the volume attachments and makes the creation of pods using the RBD PVC fast. WARNING It's highly discouraged to use this for RWO volumes as it can cause data corruption. csi-addons operations like Reclaimspace and PVC Keyrotation will also not be supported if set to false since we'll have no VolumeAttachments to determine which node the PVC is mounted on. Refer to this issue for more details. <code>true</code> <code>csi.rbdFSGroupPolicy</code> Policy for modifying a volume's ownership or permissions when the RBD PVC is being mounted. supported values are documented at https://kubernetes-csi.github.io/docs/support-fsgroup.html <code>\"File\"</code> <code>csi.rbdLivenessMetricsPort</code> Ceph CSI RBD driver metrics port <code>8080</code> <code>csi.rbdPluginUpdateStrategy</code> CSI RBD plugin daemonset update strategy, supported values are OnDelete and RollingUpdate <code>RollingUpdate</code> <code>csi.rbdPluginUpdateStrategyMaxUnavailable</code> A maxUnavailable parameter of CSI RBD plugin daemonset update strategy. <code>1</code> <code>csi.rbdPodLabels</code> Labels to add to the CSI RBD Deployments and DaemonSets Pods <code>nil</code> <code>csi.registrar.repository</code> Kubernetes CSI registrar image repository <code>\"registry.k8s.io/sig-storage/csi-node-driver-registrar\"</code> <code>csi.registrar.tag</code> Registrar image tag <code>\"v2.11.1\"</code> <code>csi.resizer.repository</code> Kubernetes CSI resizer image repository <code>\"registry.k8s.io/sig-storage/csi-resizer\"</code> <code>csi.resizer.tag</code> Resizer image tag <code>\"v1.11.1\"</code> <code>csi.serviceMonitor.enabled</code> Enable ServiceMonitor for Ceph CSI drivers <code>false</code> <code>csi.serviceMonitor.interval</code> Service monitor scrape interval <code>\"10s\"</code> <code>csi.serviceMonitor.labels</code> ServiceMonitor additional labels <code>{}</code> <code>csi.serviceMonitor.namespace</code> Use a different namespace for the ServiceMonitor <code>nil</code> <code>csi.sidecarLogLevel</code> Set logging level for Kubernetes-csi sidecar containers. Supported values from 0 to 5. 0 for general useful logs (the default), 5 for trace level verbosity. <code>0</code> <code>csi.snapshotter.repository</code> Kubernetes CSI snapshotter image repository <code>\"registry.k8s.io/sig-storage/csi-snapshotter\"</code> <code>csi.snapshotter.tag</code> Snapshotter image tag <code>\"v8.0.1\"</code> <code>csi.topology.domainLabels</code> domainLabels define which node labels to use as domains for CSI nodeplugins to advertise their domains <code>nil</code> <code>csi.topology.enabled</code> Enable topology based provisioning <code>false</code> <code>currentNamespaceOnly</code> Whether the operator should watch cluster CRD in its own namespace or not <code>false</code> <code>disableDeviceHotplug</code> Disable automatic orchestration when new devices are discovered. <code>false</code> <code>discover.nodeAffinity</code> The node labels for affinity of <code>discover-agent</code> <sup>1</sup> <code>nil</code> <code>discover.podLabels</code> Labels to add to the discover pods <code>nil</code> <code>discover.resources</code> Add resources to discover daemon pods <code>nil</code> <code>discover.toleration</code> Toleration for the discover pods. Options: <code>NoSchedule</code>, <code>PreferNoSchedule</code> or <code>NoExecute</code> <code>nil</code> <code>discover.tolerationKey</code> The specific key of the taint to tolerate <code>nil</code> <code>discover.tolerations</code> Array of tolerations in YAML format which will be added to discover deployment <code>nil</code> <code>discoverDaemonUdev</code> Blacklist certain disks according to the regex provided. <code>nil</code> <code>discoveryDaemonInterval</code> Set the discovery daemon device discovery interval (default to 60m) <code>\"60m\"</code> <code>enableDiscoveryDaemon</code> Enable discovery daemon <code>false</code> <code>enableOBCWatchOperatorNamespace</code> Whether the OBC provisioner should watch on the operator namespace or not, if not the namespace of the cluster will be used <code>true</code> <code>enforceHostNetwork</code> Whether to create all Rook pods to run on the host network, for example in environments where a CNI is not enabled <code>false</code> <code>hostpathRequiresPrivileged</code> Runs Ceph Pods as privileged to be able to write to <code>hostPaths</code> in OpenShift with SELinux restrictions. <code>false</code> <code>image.pullPolicy</code> Image pull policy <code>\"IfNotPresent\"</code> <code>image.repository</code> Image <code>\"docker.io/rook/ceph\"</code> <code>image.tag</code> Image tag <code>master</code> <code>imagePullSecrets</code> imagePullSecrets option allow to pull docker images from private docker registry. Option will be passed to all service accounts. <code>nil</code> <code>logLevel</code> Global log level for the operator. Options: <code>ERROR</code>, <code>WARNING</code>, <code>INFO</code>, <code>DEBUG</code> <code>\"INFO\"</code> <code>monitoring.enabled</code> Enable monitoring. Requires Prometheus to be pre-installed. Enabling will also create RBAC rules to allow Operator to create ServiceMonitors <code>false</code> <code>nodeSelector</code> Kubernetes <code>nodeSelector</code> to add to the Deployment. <code>{}</code> <code>obcProvisionerNamePrefix</code> Specify the prefix for the OBC provisioner in place of the cluster namespace <code>ceph cluster namespace</code> <code>priorityClassName</code> Set the priority class for the rook operator deployment if desired <code>nil</code> <code>pspEnable</code> If true, create &amp; use PSP resources <code>false</code> <code>rbacAggregate.enableOBCs</code> If true, create a ClusterRole aggregated to user facing roles for objectbucketclaims <code>false</code> <code>rbacEnable</code> If true, create &amp; use RBAC resources <code>true</code> <code>resources</code> Pod resource requests &amp; limits <code>{\"limits\":{\"memory\":\"512Mi\"},\"requests\":{\"cpu\":\"200m\",\"memory\":\"128Mi\"}}</code> <code>revisionHistoryLimit</code> The revision history limit for all pods created by Rook. If blank, the K8s default is 10. <code>nil</code> <code>scaleDownOperator</code> If true, scale down the rook operator. This is useful for administrative actions where the rook operator must be scaled down, while using gitops style tooling to deploy your helm charts. <code>false</code> <code>tolerations</code> List of Kubernetes <code>tolerations</code> to add to the Deployment. <code>[]</code> <code>unreachableNodeTolerationSeconds</code> Delay to use for the <code>node.kubernetes.io/unreachable</code> pod failure toleration to override the Kubernetes default of 5 minutes <code>5</code> <code>useOperatorHostNetwork</code> If true, run rook operator on the host network <code>nil</code>"},{"location":"Helm-Charts/operator-chart/#development-build","title":"Development Build","text":"<p>To deploy from a local build from your development environment:</p> <ol> <li>Build the Rook docker image: <code>make</code></li> <li>Copy the image to your K8s cluster, such as with the <code>docker save</code> then the <code>docker load</code> commands</li> <li>Install the helm chart:</li> </ol> <pre><code>cd deploy/charts/rook-ceph\nhelm install --create-namespace --namespace rook-ceph rook-ceph .\n</code></pre>"},{"location":"Helm-Charts/operator-chart/#uninstalling-the-chart","title":"Uninstalling the Chart","text":"<p>To see the currently installed Rook chart:</p> <pre><code>helm ls --namespace rook-ceph\n</code></pre> <p>To uninstall/delete the <code>rook-ceph</code> deployment:</p> <pre><code>helm delete --namespace rook-ceph rook-ceph\n</code></pre> <p>The command removes all the Kubernetes components associated with the chart and deletes the release.</p> <p>After uninstalling you may want to clean up the CRDs as described on the teardown documentation.</p> <ol> <li> <p><code>nodeAffinity</code> and <code>*NodeAffinity</code> options should have the format <code>\"role=storage,rook; storage=ceph\"</code> or <code>storage;role=rook-example</code> or <code>storage;</code> (checks only for presence of key)\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"Storage-Configuration/ceph-teardown/","title":"Cleanup","text":"<p>Rook provides the following clean up options:</p> <ol> <li>Uninstall: Clean up the entire cluster and delete all data</li> <li>Force delete individual resources</li> </ol>"},{"location":"Storage-Configuration/ceph-teardown/#cleaning-up-a-cluster","title":"Cleaning up a Cluster","text":"<p>To tear down the cluster, the following resources need to be cleaned up:</p> <ul> <li>The resources created under Rook's namespace (default <code>rook-ceph</code>) such as the Rook operator created by <code>operator.yaml</code> and the cluster CR <code>cluster.yaml</code>.</li> <li>All files under <code>dataDirHostPath</code> (default <code>/var/lib/rook</code>): Path on each host in the cluster where configuration is stored by ceph daemons.</li> <li>Devices used by the OSDs</li> </ul> <p>If the default namespaces or paths such as <code>dataDirHostPath</code> are changed in the example yaml files, these namespaces and paths will need to be changed throughout these instructions.</p> <p>If tearing down a cluster frequently for development purposes, it is instead recommended to use an environment such as Minikube that can easily be reset without worrying about any of these steps.</p>"},{"location":"Storage-Configuration/ceph-teardown/#delete-the-block-and-file-artifacts","title":"Delete the Block and File artifacts","text":"<p>First clean up the resources from applications that consume the Rook storage.</p> <p>These commands will clean up the resources from the example application block and file walkthroughs (unmount volumes, delete volume claims, etc).</p> <pre><code>kubectl delete -f ../wordpress.yaml\nkubectl delete -f ../mysql.yaml\nkubectl delete -n rook-ceph cephblockpool replicapool\nkubectl delete storageclass rook-ceph-block\nkubectl delete -f csi/cephfs/kube-registry.yaml\nkubectl delete storageclass csi-cephfs\n</code></pre> <p>Important</p> <p>After applications have been cleaned up, the Rook cluster can be removed. It is important to delete applications before removing the Rook operator and Ceph cluster. Otherwise, volumes may hang and nodes may require a restart.</p>"},{"location":"Storage-Configuration/ceph-teardown/#delete-the-cephcluster-crd","title":"Delete the CephCluster CRD","text":"<p>Warning</p> <p>DATA WILL BE PERMANENTLY DELETED AFTER DELETING THE <code>CephCluster</code></p> <ol> <li> <p>To instruct Rook to wipe the host paths and volumes, edit the <code>CephCluster</code> and add the <code>cleanupPolicy</code>:</p> <pre><code>kubectl -n rook-ceph patch cephcluster rook-ceph --type merge -p '{\"spec\":{\"cleanupPolicy\":{\"confirmation\":\"yes-really-destroy-data\"}}}'\n</code></pre> <p>Once the cleanup policy is enabled, any new configuration changes in the CephCluster will be blocked. Nothing will happen until the deletion of the CR is requested, so this <code>cleanupPolicy</code> change can still be reverted if needed.</p> <p>Checkout more details about the <code>cleanupPolicy</code> here</p> </li> <li> <p>Delete the <code>CephCluster</code> CR.</p> <pre><code>kubectl -n rook-ceph delete cephcluster rook-ceph\n</code></pre> </li> <li> <p>Verify that the cluster CR has been deleted before continuing to the next step.</p> <pre><code>kubectl -n rook-ceph get cephcluster\n</code></pre> </li> <li> <p>If the <code>cleanupPolicy</code> was applied, wait for the <code>rook-ceph-cleanup</code> jobs to be completed on all the nodes.</p> <p>These jobs will perform the following operations:</p> <ul> <li>Delete the all files under <code>dataDirHostPath</code> on all the nodes</li> <li>Wipe the data on the drives on all the nodes where OSDs were running in this cluster</li> </ul> </li> </ol> <p>Note</p> <p>The cleanup jobs might not start if the resources created on top of Rook Cluster are not deleted completely. See deleting block and file artifacts</p>"},{"location":"Storage-Configuration/ceph-teardown/#delete-the-operator-resources","title":"Delete the Operator Resources","text":"<p>Remove the Rook operator, RBAC, and CRDs, and the <code>rook-ceph</code> namespace.</p> <pre><code>kubectl delete -f operator.yaml\nkubectl delete -f common.yaml\nkubectl delete -f crds.yaml\n</code></pre>"},{"location":"Storage-Configuration/ceph-teardown/#delete-the-data-on-hosts","title":"Delete the data on hosts","text":"<p>Attention</p> <p>The final cleanup step requires deleting files on each host in the cluster. All files under the <code>dataDirHostPath</code> property specified in the cluster CRD will need to be deleted. Otherwise, inconsistent state will remain when a new cluster is started.</p> <p>If the <code>cleanupPolicy</code> was not added to the CephCluster CR before deleting the cluster, these manual steps are required to tear down the cluster.</p> <p>Connect to each machine and delete all files under <code>dataDirHostPath</code>.</p>"},{"location":"Storage-Configuration/ceph-teardown/#zapping-devices","title":"Zapping Devices","text":"<p>Disks on nodes used by Rook for OSDs can be reset to a usable state. Note that these scripts are not one-size-fits-all. Please use them with discretion to ensure you are not removing data unrelated to Rook.</p> <p>A single disk can usually be cleared with some or all of the steps below.</p> <pre><code>DISK=\"/dev/sdX\"\n\n# Zap the disk to a fresh, usable state (zap-all is important, b/c MBR has to be clean)\nsgdisk --zap-all $DISK\n\n# Wipe a large portion of the beginning of the disk to remove more LVM metadata that may be present\ndd if=/dev/zero of=\"$DISK\" bs=1M count=100 oflag=direct,dsync\n\n# SSDs may be better cleaned with blkdiscard instead of dd\nblkdiscard $DISK\n\n# Inform the OS of partition table changes\npartprobe $DISK\n</code></pre> <p>Ceph can leave LVM and device mapper data on storage drives, preventing them from being redeployed. These steps can clean former Ceph drives for reuse. Note that this only needs to be run once on each node. If you have only one Rook cluster and all Ceph disks are being wiped, run the following command.</p> <pre><code># This command hangs on some systems: with caution, 'dmsetup remove_all --force' can be used\nls /dev/mapper/ceph-* | xargs -I% -- dmsetup remove %\n\n# ceph-volume setup can leave ceph-&lt;UUID&gt; directories in /dev and /dev/mapper (unnecessary clutter)\nrm -rf /dev/ceph-*\nrm -rf /dev/mapper/ceph--*\n</code></pre> <p>If disks are still reported locked, rebooting the node often helps clear LVM-related holds on disks.</p> <p>If there are multiple Ceph clusters and some disks are not wiped yet, it is necessary to manually determine which disks map to which device mapper devices.</p>"},{"location":"Storage-Configuration/ceph-teardown/#troubleshooting","title":"Troubleshooting","text":"<p>The most common issue cleaning up the cluster is that the <code>rook-ceph</code> namespace or the cluster CRD remain indefinitely in the <code>terminating</code> state. A namespace cannot be removed until all of its resources are removed, so determine which resources are pending termination.</p> <p>If a pod is still terminating, consider forcefully terminating the pod (<code>kubectl -n rook-ceph delete pod &lt;name&gt;</code>).</p> <pre><code>kubectl -n rook-ceph get pod\n</code></pre> <p>If the cluster CRD still exists even though it has been deleted, see the next section on removing the finalizer.</p> <pre><code>kubectl -n rook-ceph get cephcluster\n</code></pre>"},{"location":"Storage-Configuration/ceph-teardown/#removing-the-cluster-crd-finalizer","title":"Removing the Cluster CRD Finalizer","text":"<p>When a Cluster CRD is created, a finalizer is added automatically by the Rook operator. The finalizer will allow the operator to ensure that before the cluster CRD is deleted, all block and file mounts will be cleaned up. Without proper cleanup, pods consuming the storage will be hung indefinitely until a system reboot.</p> <p>The operator is responsible for removing the finalizer after the mounts have been cleaned up. If for some reason the operator is not able to remove the finalizer (i.e., the operator is not running anymore), delete the finalizer manually with the following command:</p> <pre><code>for CRD in $(kubectl get crd -n rook-ceph | awk '/ceph.rook.io/ {print $1}'); do\n    kubectl get -n rook-ceph \"$CRD\" -o name | \\\n    xargs -I {} kubectl patch -n rook-ceph {} --type merge -p '{\"metadata\":{\"finalizers\": []}}'\ndone\n</code></pre> <p>If the namespace is still stuck in Terminating state, check which resources are holding up the deletion and remove their finalizers as well:</p> <pre><code>kubectl api-resources --verbs=list --namespaced -o name \\\n  | xargs -n 1 kubectl get --show-kind --ignore-not-found -n rook-ceph\n</code></pre>"},{"location":"Storage-Configuration/ceph-teardown/#remove-critical-resource-finalizers","title":"Remove critical resource finalizers","text":"<p>Rook adds a finalizer <code>ceph.rook.io/disaster-protection</code> to resources critical to the Ceph cluster so that the resources will not be accidentally deleted.</p> <p>The operator is responsible for removing the finalizers when a CephCluster is deleted. If the operator is not able to remove the finalizers (i.e., the operator is not running anymore), remove the finalizers manually:</p> <pre><code>kubectl -n rook-ceph patch configmap rook-ceph-mon-endpoints --type merge -p '{\"metadata\":{\"finalizers\": []}}'\nkubectl -n rook-ceph patch secrets rook-ceph-mon --type merge -p '{\"metadata\":{\"finalizers\": []}}'\n</code></pre>"},{"location":"Storage-Configuration/ceph-teardown/#force-delete-resources","title":"Force Delete Resources","text":"<p>To keep your data safe in the cluster, Rook disallows deleting critical cluster resources by default. To override this behavior and force delete a specific custom resource, add the annotation <code>rook.io/force-deletion=\"true\"</code> to the resource and then delete it. Rook will start a cleanup job that will delete all the related ceph resources created by that custom resource.</p> <p>For example, run the following commands to clean the <code>CephFilesystemSubVolumeGroup</code> resource named <code>my-subvolumegroup</code></p> <pre><code>kubectl -n rook-ceph annotate cephfilesystemsubvolumegroups.ceph.rook.io my-subvolumegroup rook.io/force-deletion=\"true\"\nkubectl -n rook-ceph delete cephfilesystemsubvolumegroups.ceph.rook.io my-subvolumegroup\n</code></pre> <p>Once the cleanup job is completed successfully, Rook will remove the finalizers from the deleted custom resource.</p> <p>This cleanup is supported only for the following custom resources:</p> Custom Resource Ceph Resources to be cleaned up CephFilesystemSubVolumeGroup CSI stored RADOS OMAP details for pvc/volumesnapshots, subvolume snapshots, subvolume clones, subvolumes CephBlockPoolRadosNamespace Images and snapshots in the RADOS namespace CephBlockPool Images and snapshots in the BlockPool"},{"location":"Storage-Configuration/Advanced/ceph-configuration/","title":"Ceph Configuration","text":"<p>These examples show how to perform advanced configuration tasks on your Rook storage cluster.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#prerequisites","title":"Prerequisites","text":"<p>Most of the examples make use of the <code>ceph</code> client command.  A quick way to use the Ceph client suite is from a Rook Toolbox container.</p> <p>The Kubernetes based examples assume Rook OSD pods are in the <code>rook-ceph</code> namespace. If you run them in a different namespace, modify <code>kubectl -n rook-ceph [...]</code> to fit your situation.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#using-alternate-namespaces","title":"Using alternate namespaces","text":"<p>If you wish to deploy the Rook Operator and/or Ceph clusters to namespaces other than the default <code>rook-ceph</code>, the manifests are commented to allow for easy <code>sed</code> replacements. Change <code>ROOK_CLUSTER_NAMESPACE</code> to tailor the manifests for additional Ceph clusters. You can choose to also change <code>ROOK_OPERATOR_NAMESPACE</code> to create a new Rook Operator for each Ceph cluster (don't forget to set <code>ROOK_CURRENT_NAMESPACE_ONLY</code>), or you can leave it at the same value for every Ceph cluster if you only wish to have one Operator manage all Ceph clusters.</p> <p>If the operator namespace is different from the cluster namespace, the operator namespace must be created before running the steps below. The cluster namespace does not need to be created first, as it will be created by <code>common.yaml</code> in the script below.</p> <pre><code>kubectl create namespace $ROOK_OPERATOR_NAMESPACE\n</code></pre> <p>This will help you manage namespaces more easily, but you should still make sure the resources are configured to your liking.</p> <pre><code>cd deploy/examples\n\nexport ROOK_OPERATOR_NAMESPACE=\"rook-ceph\"\nexport ROOK_CLUSTER_NAMESPACE=\"rook-ceph\"\n\nsed -i.bak \\\n    -e \"s/\\(.*\\):.*# namespace:operator/\\1: $ROOK_OPERATOR_NAMESPACE # namespace:operator/g\" \\\n    -e \"s/\\(.*\\):.*# namespace:cluster/\\1: $ROOK_CLUSTER_NAMESPACE # namespace:cluster/g\" \\\n    -e \"s/\\(.*serviceaccount\\):.*:\\(.*\\) # serviceaccount:namespace:operator/\\1:$ROOK_OPERATOR_NAMESPACE:\\2 # serviceaccount:namespace:operator/g\" \\\n    -e \"s/\\(.*serviceaccount\\):.*:\\(.*\\) # serviceaccount:namespace:cluster/\\1:$ROOK_CLUSTER_NAMESPACE:\\2 # serviceaccount:namespace:cluster/g\" \\\n    -e \"s/\\(.*\\): [-_A-Za-z0-9]*\\.\\(.*\\) # driver:namespace:cluster/\\1: $ROOK_CLUSTER_NAMESPACE.\\2 # driver:namespace:cluster/g\" \\\n  common.yaml operator.yaml cluster.yaml # add other files or change these as desired for your config\n\n# You need to use `apply` for all Ceph clusters after the first if you have only one Operator\nkubectl apply -f common.yaml -f operator.yaml -f cluster.yaml # add other files as desired for yourconfig\n</code></pre> <p>Also see the CSI driver documentation to update the csi provisioner names in the storageclass and volumesnapshotclass.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#deploying-a-second-cluster","title":"Deploying a second cluster","text":"<p>If you wish to create a new CephCluster in a separate namespace, you can easily do so by modifying the <code>ROOK_OPERATOR_NAMESPACE</code> and <code>SECOND_ROOK_CLUSTER_NAMESPACE</code> values in the below instructions. The default configuration in <code>common-second-cluster.yaml</code> is already set up to utilize <code>rook-ceph</code> for the operator and <code>rook-ceph-secondary</code> for the cluster. There's no need to run the <code>sed</code> command if you prefer to use these default values.</p> <pre><code>cd deploy/examples\nexport ROOK_OPERATOR_NAMESPACE=\"rook-ceph\"\nexport SECOND_ROOK_CLUSTER_NAMESPACE=\"rook-ceph-secondary\"\n\nsed -i.bak \\\n    -e \"s/\\(.*\\):.*# namespace:operator/\\1: $ROOK_OPERATOR_NAMESPACE # namespace:operator/g\" \\\n    -e \"s/\\(.*\\):.*# namespace:cluster/\\1: $SECOND_ROOK_CLUSTER_NAMESPACE # namespace:cluster/g\" \\\n  common-second-cluster.yaml\n\nkubectl create -f common-second-cluster.yaml\n</code></pre> <p>This will create all the necessary RBACs as well as the new namespace. The script assumes that <code>common.yaml</code> was already created. When you create the second CephCluster CR, use the same <code>NAMESPACE</code> and the operator will configure the second cluster.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#log-collection","title":"Log Collection","text":"<p>All Rook logs can be collected in a Kubernetes environment with the following command:</p> <pre><code>for p in $(kubectl -n rook-ceph get pods -o jsonpath='{.items[*].metadata.name}')\ndo\n    for c in $(kubectl -n rook-ceph get pod ${p} -o jsonpath='{.spec.containers[*].name}')\n    do\n        echo \"BEGIN logs from pod: ${p} ${c}\"\n        kubectl -n rook-ceph logs -c ${c} ${p}\n        echo \"END logs from pod: ${p} ${c}\"\n    done\ndone\n</code></pre> <p>This gets the logs for every container in every Rook pod and then compresses them into a <code>.gz</code> archive for easy sharing.  Note that instead of <code>gzip</code>, you could instead pipe to <code>less</code> or to a single text file.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#osd-information","title":"OSD Information","text":"<p>Keeping track of OSDs and their underlying storage devices can be difficult. The following scripts will clear things up quickly.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#kubernetes","title":"Kubernetes","text":"<pre><code># Get OSD Pods\n# This uses the example/default cluster name \"rook\"\nOSD_PODS=$(kubectl get pods --all-namespaces -l \\\n  app=rook-ceph-osd,rook_cluster=rook-ceph -o jsonpath='{.items[*].metadata.name}')\n\n# Find node and drive associations from OSD pods\nfor pod in $(echo ${OSD_PODS})\ndo\n echo \"Pod:  ${pod}\"\n echo \"Node: $(kubectl -n rook-ceph get pod ${pod} -o jsonpath='{.spec.nodeName}')\"\n kubectl -n rook-ceph exec ${pod} -- sh -c '\\\n  for i in /var/lib/ceph/osd/ceph-*; do\n    [ -f ${i}/ready ] || continue\n    echo -ne \"-$(basename ${i}) \"\n    echo $(lsblk -n -o NAME,SIZE ${i}/block 2&gt; /dev/null || \\\n    findmnt -n -v -o SOURCE,SIZE -T ${i}) $(cat ${i}/type)\n  done | sort -V\n  echo'\ndone\n</code></pre> <p>The output should look something like this.</p> <pre><code>Pod:  osd-m2fz2\nNode: node1.zbrbdl\n-osd0  sda3  557.3G  bluestore\n-osd1  sdf3  110.2G  bluestore\n-osd2  sdd3  277.8G  bluestore\n-osd3  sdb3  557.3G  bluestore\n-osd4  sde3  464.2G  bluestore\n-osd5  sdc3  557.3G  bluestore\n\nPod:  osd-nxxnq\nNode: node3.zbrbdl\n-osd6   sda3  110.7G  bluestore\n-osd17  sdd3  1.8T    bluestore\n-osd18  sdb3  231.8G  bluestore\n-osd19  sdc3  231.8G  bluestore\n\nPod:  osd-tww1h\nNode: node2.zbrbdl\n-osd7   sdc3  464.2G  bluestore\n-osd8   sdj3  557.3G  bluestore\n-osd9   sdf3  66.7G   bluestore\n-osd10  sdd3  464.2G  bluestore\n-osd11  sdb3  147.4G  bluestore\n-osd12  sdi3  557.3G  bluestore\n-osd13  sdk3  557.3G  bluestore\n-osd14  sde3  66.7G   bluestore\n-osd15  sda3  110.2G  bluestore\n-osd16  sdh3  135.1G  bluestore\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#separate-storage-groups","title":"Separate Storage Groups","text":"<p>Attention</p> <p>It is deprecated to manually need to set this, the <code>deviceClass</code> property can be used on Pool structures in <code>CephBlockPool</code>, <code>CephFilesystem</code> and <code>CephObjectStore</code> CRD objects.</p> <p>By default Rook/Ceph puts all storage under one replication rule in the CRUSH Map which provides the maximum amount of storage capacity for a cluster.  If you would like to use different storage endpoints for different purposes, you'll have to create separate storage groups.</p> <p>In the following example we will separate SSD drives from spindle-based drives, a common practice for those looking to target certain workloads onto faster (database) or slower (file archive) storage.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#configuring-pools","title":"Configuring Pools","text":""},{"location":"Storage-Configuration/Advanced/ceph-configuration/#placement-group-sizing","title":"Placement Group Sizing","text":"<p>Note</p> <p>Since Ceph Nautilus (v14.x), you can use the Ceph MGR <code>pg_autoscaler</code> module to auto scale the PGs as needed. It is highly advisable to configure default pg_num value on per-pool basis, If you want to enable this feature, please refer to Default PG and PGP counts.</p> <p>The general rules for deciding how many PGs your pool(s) should contain is:</p> <ul> <li>Fewer than 5 OSDs set <code>pg_num</code> to 128</li> <li>Between 5 and 10 OSDs set <code>pg_num</code> to 512</li> <li>Between 10 and 50 OSDs set <code>pg_num</code> to 1024</li> </ul> <p>If you have more than 50 OSDs, you need to understand the tradeoffs and how to calculate the pg_num value by yourself. For calculating pg_num yourself please make use of the pgcalc tool.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#setting-pg-count","title":"Setting PG Count","text":"<p>Be sure to read the placement group sizing section before changing the number of PGs.</p> <pre><code># Set the number of PGs in the rbd pool to 512\nceph osd pool set rbd pg_num 512\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#custom-cephconf-settings","title":"Custom <code>ceph.conf</code> Settings","text":"<p>Info</p> <p>The advised method for controlling Ceph configuration is to use the <code>cephConfig:</code> structure in the <code>CephCluster</code> CRD. It is highly recommended that this only be used when absolutely necessary and that the <code>config</code> be reset to an empty string if/when the configurations are no longer necessary. Configurations in the config file will make the Ceph cluster less configurable from the CLI and dashboard and may make future tuning or debugging difficult.</p> <p>Setting configs via Ceph's CLI requires that at least one mon be available for the configs to be set, and setting configs via dashboard requires at least one mgr to be available. Ceph also has a number of very advanced settings that cannot be modified easily via the CLI or dashboard. In order to set configurations before monitors are available or to set advanced configuration settings, the <code>rook-config-override</code> ConfigMap exists, and the <code>config</code> field can be set with the contents of a <code>ceph.conf</code> file. The contents will be propagated to all mon, mgr, OSD, MDS, and RGW daemons as an <code>/etc/ceph/ceph.conf</code> file.</p> <p>Warning</p> <p>Rook performs no validation on the config, so the  validity of the settings is the user's responsibility.</p> <p>If the <code>rook-config-override</code> ConfigMap is created before the cluster is started, the Ceph daemons will automatically pick up the settings. If you add the settings to the ConfigMap after the cluster has been initialized, each daemon will need to be restarted where you want the settings applied:</p> <ul> <li>mons: ensure all three mons are online and healthy before restarting each mon pod, one at a time.</li> <li>mgrs: the pods are stateless and can be restarted as needed, but note that this will disrupt the     Ceph dashboard during restart.</li> <li>OSDs: restart your the pods by deleting them, one at a time, and running <code>ceph -s</code> between each restart to ensure the cluster goes back to \"active/clean\" state.</li> <li>RGW: the pods are stateless and can be restarted as needed.</li> <li>MDS: the pods are stateless and can be restarted as needed.</li> </ul> <p>After the pod restart, the new settings should be in effect. Note that if the ConfigMap in the Ceph cluster's namespace is created before the cluster is created, the daemons will pick up the settings at first launch.</p> <p>To automate the restart of the Ceph daemon pods, you will need to trigger an update to the pod specs. The simplest way to trigger the update is to add annotations or labels to the CephCluster CR for the daemons you want to restart. The operator will then proceed with a rolling update, similar to any other update to the cluster.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#example","title":"Example","text":"<p>In this example we will set the default pool <code>size</code> to two, and tell OSD daemons not to change the weight of OSDs on startup.</p> <p>Warning</p> <p>Modify Ceph settings carefully. You are leaving the sandbox tested by Rook. Changing the settings could result in unhealthy daemons or even data loss if used incorrectly.</p> <p>When the Rook Operator creates a cluster, a placeholder ConfigMap is created that will allow you to override Ceph configuration settings. When the daemon pods are started, the settings specified in this ConfigMap will be merged with the default settings generated by Rook.</p> <p>The default override settings are blank. Cutting out the extraneous properties, we would see the following defaults after creating a cluster:</p> <pre><code>kubectl -n rook-ceph get ConfigMap rook-config-override -o yaml\n</code></pre> <pre><code>kind: ConfigMap\napiVersion: v1\nmetadata:\n  name: rook-config-override\n  namespace: rook-ceph\ndata:\n  config: \"\"\n</code></pre> <p>To apply your desired configuration, you will need to update this ConfigMap. The next time the daemon pod(s) start, they will use the updated configs.</p> <pre><code>kubectl -n rook-ceph edit configmap rook-config-override\n</code></pre> <p>Modify the settings and save. Each line you add should be indented from the <code>config</code> property as such:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: rook-config-override\n  namespace: rook-ceph\ndata:\n  config: |\n    [global]\n    osd crush update on start = false\n    osd pool default size = 2\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#custom-csi-cephconf-settings","title":"Custom CSI <code>ceph.conf</code> Settings","text":"<p>Warning</p> <p>It is highly recommended to use the default setting that comes with CephCSI and this can only be used when absolutely necessary. The <code>ceph.conf</code> should be reset back to default values if/when the configurations are no longer necessary.</p> <p>If the <code>csi-ceph-conf-override</code> ConfigMap is created before the cluster is started, the CephCSI pods will automatically pick up the settings. If you add the settings to the ConfigMap after the cluster has been initialized, you can restart the Rook operator pod and wait for Rook to recreate CSI pods to take immediate effect.</p> <p>After the CSI pods are restarted, the new settings should be in effect.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#example-csi-cephconf-settings","title":"Example CSI <code>ceph.conf</code> Settings","text":"<p>In this Example we will set the <code>rbd_validate_pool</code> to <code>false</code> to skip rbd pool validation.</p> <p>Warning</p> <p>Modify Ceph settings carefully to avoid modifying the default configuration. Changing the settings could result in unexpected results if used incorrectly.</p> <pre><code>kubectl create -f csi-ceph-conf-override.yaml\n</code></pre> <p>Restart the Rook operator pod and wait for CSI pods to be recreated.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#osd-crush-settings","title":"OSD CRUSH Settings","text":"<p>A useful view of the CRUSH Map is generated with the following command:</p> <pre><code>ceph osd tree\n</code></pre> <p>In this section we will be tweaking some of the values seen in the output.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#osd-weight","title":"OSD Weight","text":"<p>The CRUSH weight controls the ratio of data that should be distributed to each OSD.  This also means a higher or lower amount of disk I/O operations for an OSD with higher/lower weight, respectively.</p> <p>By default OSDs get a weight relative to their storage capacity, which maximizes overall cluster capacity by filling all drives at the same rate, even if drive sizes vary.  This should work for most use-cases, but the following situations could warrant weight changes:</p> <ul> <li>Your cluster has some relatively slow OSDs or nodes. Lowering their weight can     reduce the impact of this bottleneck.</li> <li>You're using bluestore drives provisioned with Rook v0.3.1 or older.  In this     case you may notice OSD weights did not get set relative to their storage     capacity.  Changing the weight can fix this and maximize cluster capacity.</li> </ul> <p>This example sets the weight of osd.0 which is 600GiB</p> <pre><code>ceph osd crush reweight osd.0 .600\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#osd-primary-affinity","title":"OSD Primary Affinity","text":"<p>When pools are set with a size setting greater than one, data is replicated between nodes and OSDs.  For every chunk of data a Primary OSD is selected to be used for reading that data to be sent to clients.  You can control how likely it is for an OSD to become a Primary using the Primary Affinity setting.  This is similar to the OSD weight setting, except it only affects reads on the storage device, not capacity or writes.</p> <p>In this example we will ensure that <code>osd.0</code> is only selected as Primary if all other OSDs holding data replicas are unavailable:</p> <pre><code>ceph osd primary-affinity osd.0 0\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#osd-dedicated-network","title":"OSD Dedicated Network","text":"<p>Tip</p> <p>This documentation is left for historical purposes. It is still valid, but Rook offers native support for this feature via the CephCluster network configuration.</p> <p>It is possible to configure ceph to leverage a dedicated network for the OSDs to communicate across. A useful overview is the Ceph Networks section of the Ceph documentation. If you declare a cluster network, OSDs will route heartbeat, object replication, and recovery traffic over the cluster network. This may improve performance compared to using a single network, especially when slower network technologies are used. The tradeoff is additional expense and subtle failure modes.</p> <p>Two changes are necessary to the configuration to enable this capability:</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#use-hostnetwork-in-the-cluster-configuration","title":"Use hostNetwork in the cluster configuration","text":"<p>Enable the <code>hostNetwork</code> setting in the Ceph Cluster CRD configuration. For example,</p> <pre><code>  network:\n    provider: host\n</code></pre> <p>Important</p> <p>Changing this setting is not supported in a running Rook cluster. Host networking should be configured when the cluster is first created.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#define-the-subnets-to-use-for-public-and-private-osd-networks","title":"Define the subnets to use for public and private OSD networks","text":"<p>Edit the <code>rook-config-override</code> configmap to define the custom network configuration:</p> <pre><code>kubectl -n rook-ceph edit configmap rook-config-override\n</code></pre> <p>In the editor, add a custom configuration to instruct ceph which subnet is the public network and which subnet is the private network. For example:</p> <pre><code>apiVersion: v1\ndata:\n  config: |\n    [global]\n    public network = 10.0.7.0/24\n    cluster network = 10.0.10.0/24\n    public addr = \"\"\n    cluster addr = \"\"\n</code></pre> <p>After applying the updated rook-config-override configmap, it will be necessary to restart the OSDs by deleting the OSD pods in order to apply the change. Restart the OSD pods by deleting them, one at a time, and running ceph -s between each restart to ensure the cluster goes back to \"active/clean\" state.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#phantom-osd-removal","title":"Phantom OSD Removal","text":"<p>If you have OSDs in which are not showing any disks, you can remove those \"Phantom OSDs\" by following the instructions below. To check for \"Phantom OSDs\", you can run (example output):</p> <pre><code>$ ceph osd tree\nID  CLASS WEIGHT  TYPE NAME STATUS REWEIGHT PRI-AFF\n-1       57.38062 root default\n-13        7.17258     host node1.example.com\n2   hdd  3.61859         osd.2                up  1.00000 1.00000\n-7              0     host node2.example.com   down    0    1.00000\n</code></pre> <p>The host <code>node2.example.com</code> in the output has no disks, so it is most likely a \"Phantom OSD\".</p> <p>Now to remove it, use the ID in the first column of the output and replace <code>&lt;ID&gt;</code> with it. In the example output above the ID would be <code>-7</code>. The commands are:</p> <pre><code>ceph osd out &lt;ID&gt;\nceph osd crush remove osd.&lt;ID&gt;\nceph auth del osd.&lt;ID&gt;\nceph osd rm &lt;ID&gt;\n</code></pre> <p>To recheck that the Phantom OSD was removed, re-run the following command and check if the OSD with the ID doesn't show up anymore:</p> <pre><code>ceph osd tree\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#auto-expansion-of-osds","title":"Auto Expansion of OSDs","text":""},{"location":"Storage-Configuration/Advanced/ceph-configuration/#prerequisites-for-auto-expansion-of-osds","title":"Prerequisites for Auto Expansion of OSDs","text":"<p>1) A PVC-based cluster deployed in dynamic provisioning environment with a <code>storageClassDeviceSet</code>.</p> <p>2) Create the Rook Toolbox.</p> <p>Note</p> <p>Prometheus Operator and [Prometheus ../Monitoring/ceph-monitoring.mdnitoring.md#prometheus-instances) are Prerequisites that are created by the auto-grow-storage script.</p>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#to-scale-osds-vertically","title":"To scale OSDs Vertically","text":"<p>Run the following script to auto-grow the size of OSDs on a PVC-based Rook cluster whenever the OSDs have reached the storage near-full threshold.</p> <pre><code>tests/scripts/auto-grow-storage.sh size  --max maxSize --growth-rate percent\n</code></pre> <p><code>growth-rate</code> percentage represents the percent increase you want in the OSD capacity and maxSize represent the maximum disk size.</p> <p>For example, if you need to increase the size of OSD by 30% and max disk size is 1Ti</p> <pre><code>./auto-grow-storage.sh size  --max 1Ti --growth-rate 30\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-configuration/#to-scale-osds-horizontally","title":"To scale OSDs Horizontally","text":"<p>Run the following script to auto-grow the number of OSDs on a PVC-based Rook cluster whenever the OSDs have reached the storage near-full threshold.</p> <pre><code>tests/scripts/auto-grow-storage.sh count --max maxCount --count rate\n</code></pre> <p>Count of OSD represents the number of OSDs you need to add and maxCount represents the number of disks a storage cluster will support.</p> <p>For example, if you need to increase the number of OSDs by 3 and maxCount is 10</p> <pre><code>./auto-grow-storage.sh count --max 10 --count 3\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-mon-health/","title":"Monitor Health","text":"<p>Failure in a distributed system is to be expected. Ceph was designed from the ground up to deal with the failures of a distributed system. At the next layer, Rook was designed from the ground up to automate recovery of Ceph components that traditionally required admin intervention. Monitor health is the most critical piece of the equation that Rook actively monitors. If they are not in a good state, the operator will take action to restore their health and keep your cluster protected from disaster.</p> <p>The Ceph monitors (mons) are the brains of the distributed cluster. They control all of the metadata that is necessary to store and retrieve your data as well as keep it safe. If the monitors are not in a healthy state you will risk losing all the data in your system.</p>"},{"location":"Storage-Configuration/Advanced/ceph-mon-health/#monitor-identity","title":"Monitor Identity","text":"<p>Each monitor in a Ceph cluster has a static identity. Every component in the cluster is aware of the identity, and that identity must be immutable. The identity of a mon is its IP address.</p> <p>To have an immutable IP address in Kubernetes, Rook creates a K8s service for each monitor. The clusterIP of the service will act as the stable identity.</p> <p>When a monitor pod starts, it will bind to its podIP and it will expect communication to be via its service IP address.</p>"},{"location":"Storage-Configuration/Advanced/ceph-mon-health/#monitor-quorum","title":"Monitor Quorum","text":"<p>Multiple mons work together to provide redundancy by each keeping a copy of the metadata. A variation of the distributed algorithm Paxos is used to establish consensus about the state of the cluster. Paxos requires a super-majority of mons to be running in order to establish quorum and perform operations in the cluster. If the majority of mons are not running, quorum is lost and nothing can be done in the cluster.</p>"},{"location":"Storage-Configuration/Advanced/ceph-mon-health/#how-many-mons","title":"How many mons?","text":"<p>Most commonly a cluster will have three mons. This would mean that one mon could go down and allow the cluster to remain healthy. You would still have 2/3 mons running to give you consensus in the cluster for any operation.</p> <p>For highest availability, an odd number of mons is required. Fifty percent of mons will not be sufficient to maintain quorum. If you had two mons and one of them went down, you would have 1/2 of quorum. Since that is not a super-majority, the cluster would have to wait until the second mon is up again. Rook allows an even number of mons for higher durability. See the disaster recovery guide if quorum is lost and to recover mon quorum from a single mon.</p> <p>The number of mons to create in a cluster depends on your tolerance for losing a node. If you have 1 mon zero nodes can be lost to maintain quorum. With 3 mons one node can be lost, and with 5 mons two nodes can be lost. Because the Rook operator will automatically start a new monitor if one dies, you typically only need three mons. The more mons you have, the more overhead there will be to make a change to the cluster, which could become a performance issue in a large cluster.</p>"},{"location":"Storage-Configuration/Advanced/ceph-mon-health/#mitigating-monitor-failure","title":"Mitigating Monitor Failure","text":"<p>Whatever the reason that a mon may fail (power failure, software crash, software hang, etc), there are several layers of mitigation in place to help recover the mon. It is always better to bring an existing mon back up than to failover to bring up a new mon.</p> <p>The Rook operator creates a mon with a Deployment to ensure that the mon pod will always be restarted if it fails. If a mon pod stops for any reason, Kubernetes will automatically start the pod up again.</p> <p>In order for a mon to support a pod/node restart, the mon metadata is persisted to disk, either under the <code>dataDirHostPath</code> specified in the CephCluster CR, or in the volume defined by the <code>volumeClaimTemplate</code> in the CephCluster CR. This will allow the mon to start back up with its existing metadata and continue where it left off even if the pod had to be re-created. Without this persistence, the mon cannot restart.</p>"},{"location":"Storage-Configuration/Advanced/ceph-mon-health/#failing-over-a-monitor","title":"Failing over a Monitor","text":"<p>If a mon is unhealthy and the K8s pod restart or liveness probe are not sufficient to bring a mon back up, the operator will make the decision to terminate the unhealthy monitor deployment and bring up a new monitor with a new identity. This is an operation that must be done while mon quorum is maintained by other mons in the cluster.</p> <p>The operator checks for mon health every 45 seconds. If a monitor is down, the operator will wait 10 minutes before failing over the unhealthy mon. These two intervals can be configured as parameters to the CephCluster CR (see below). If the intervals are too short, it could be unhealthy if the mons are failed over too aggressively. If the intervals are too long, the cluster could be at risk of losing quorum if a new monitor is not brought up before another mon fails.</p> <pre><code>healthCheck:\n  daemonHealth:\n    mon:\n      disabled: false\n      interval: 45s\n      timeout: 10m\n</code></pre> <p>If you want to force a mon to failover for testing or other purposes, you can scale down the mon deployment to 0, then wait for the timeout. Note that the operator may scale up the mon again automatically if the operator is restarted or if a full reconcile is triggered, such as when the CephCluster CR is updated.</p> <p>If the mon pod is in pending state and couldn't be assigned to a node (say, due to node drain), then the operator will wait for the timeout again before the mon failover. So the timeout waiting for the mon failover will be doubled in this case.</p> <p>To disable monitor automatic failover, the <code>timeout</code> can be set to <code>0</code>, if the monitor goes out of quorum Rook will never fail it over onto another node. This is especially useful for planned maintenance.</p>"},{"location":"Storage-Configuration/Advanced/ceph-mon-health/#example-failover","title":"Example Failover","text":"<p>Rook will create mons with pod names such as mon-a, mon-b, and mon-c. Let's say mon-b had an issue and the pod failed.</p> <pre><code>$ kubectl -n rook-ceph get pod -l app=rook-ceph-mon\nNAME                               READY   STATUS    RESTARTS   AGE\nrook-ceph-mon-a-74dc96545-ch5ns    1/1     Running   0          9m\nrook-ceph-mon-b-6b9d895c4c-bcl2h   1/1     Error     2          9m\nrook-ceph-mon-c-7d6df6d65c-5cjwl   1/1     Running   0          8m\n</code></pre> <p>After a failover, you will see the unhealthy mon removed and a new mon added such as mon-d. A fully healthy mon quorum is now running again.</p> <pre><code>$ kubectl -n rook-ceph get pod -l app=rook-ceph-mon\nNAME                             READY     STATUS    RESTARTS   AGE\nrook-ceph-mon-a-74dc96545-ch5ns    1/1     Running   0          19m\nrook-ceph-mon-c-7d6df6d65c-5cjwl   1/1     Running   0          18m\nrook-ceph-mon-d-9e7ea7e76d-4bhxm   1/1     Running   0          20s\n</code></pre> <p>From the toolbox we can verify the status of the health mon quorum:</p> <pre><code>$ ceph -s\n  cluster:\n    id:     35179270-8a39-4e08-a352-a10c52bb04ff\n    health: HEALTH_OK\n\n  services:\n    mon: 3 daemons, quorum a,b,d (age 2m)\n    mgr: a(active, since 12m)\n    osd: 3 osds: 3 up (since 10m), 3 in (since 10m)\n[...]\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-mon-health/#automatic-monitor-failover","title":"Automatic Monitor Failover","text":"<p>Rook will automatically fail over the mons when the following settings are updated in the CephCluster CR:</p> <ul> <li><code>spec.network.hostNetwork</code>: When enabled or disabled, Rook fails over all monitors, configuring them to enable or disable host networking.</li> <li><code>spec.network.Provider</code> : When updated from being empty to \"host\", Rook fails over all monitors, configuring them to enable or disable host networking.</li> <li><code>spec.network.multiClusterService</code>: When enabled or disabled, Rook fails over all monitors, configuring them to start (or stop) using service IPs compatible with the multi-cluster service.</li> </ul>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/","title":"Ceph OSD Management","text":"<p>Ceph Object Storage Daemons (OSDs) are the heart and soul of the Ceph storage platform. Each OSD manages a local device and together they provide the distributed storage. Rook will automate creation and management of OSDs to hide the complexity based on the desired state in the CephCluster CR as much as possible. This guide will walk through some of the scenarios to configure OSDs where more configuration may be required.</p>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#osd-health","title":"OSD Health","text":"<p>The rook-ceph-tools pod provides a simple environment to run Ceph tools. The <code>ceph</code> commands mentioned in this document should be run from the toolbox.</p> <p>Once the is created, connect to the pod to execute the <code>ceph</code> commands to analyze the health of the cluster, in particular the OSDs and placement groups (PGs). Some common commands to analyze OSDs include:</p> <pre><code>ceph status\nceph osd tree\nceph osd status\nceph osd df\nceph osd utilization\n</code></pre> <pre><code>kubectl -n rook-ceph exec -it $(kubectl -n rook-ceph get pod -l \"app=rook-ceph-tools\" -o jsonpath='{.items[0].metadata.name}') bash\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#add-an-osd","title":"Add an OSD","text":"<p>The QuickStart Guide will provide the basic steps to create a cluster and start some OSDs. For more details on the OSD settings also see the Cluster CRD documentation. If you are not seeing OSDs created, see the Ceph Troubleshooting Guide.</p> <p>To add more OSDs, Rook will automatically watch for new nodes and devices being added to your cluster. If they match the filters or other settings in the <code>storage</code> section of the cluster CR, the operator will create new OSDs.</p>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#add-an-osd-on-a-pvc","title":"Add an OSD on a PVC","text":"<p>In more dynamic environments where storage can be dynamically provisioned with a raw block storage provider, the OSDs can be backed by PVCs. See the <code>storageClassDeviceSets</code> documentation in the Cluster CRD topic.</p> <p>To add more OSDs, you can either increase the <code>count</code> of the OSDs in an existing device set or you can add more device sets to the cluster CR. The operator will then automatically create new OSDs according to the updated cluster CR.</p>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#remove-an-osd","title":"Remove an OSD","text":"<p>To remove an OSD due to a failed disk or other re-configuration, consider the following to ensure the health of the data through the removal process:</p> <ul> <li>Confirm you will have enough space on your cluster after removing your OSDs to properly handle the deletion</li> <li>Confirm the remaining OSDs and their placement groups (PGs) are healthy in order to handle the rebalancing of the data</li> <li>Do not remove too many OSDs at once</li> <li>Wait for rebalancing between removing multiple OSDs</li> </ul> <p>If all the PGs are <code>active+clean</code> and there are no warnings about being low on space, this means the data is fully replicated and it is safe to proceed. If an OSD is failing, the PGs will not be perfectly clean and you will need to proceed anyway.</p>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#host-based-cluster","title":"Host-based cluster","text":"<p>Update your CephCluster CR. Depending on your CR settings, you may need to remove the device from the list or update the device filter. If you are using <code>useAllDevices: true</code>, no change to the CR is necessary.</p> <p>Important</p> <p>On host-based clusters, you may need to stop the Rook Operator while performing OSD removal steps in order to prevent Rook from detecting the old OSD and trying to re-create it before the disk is wiped or removed.</p> <p>To stop the Rook Operator, run:</p> <pre><code>kubectl -n rook-ceph scale deployment rook-ceph-operator --replicas=0\n</code></pre> <p>You must perform steps below to (1) purge the OSD and either (2.a) delete the underlying data or (2.b)replace the disk before starting the Rook Operator again.</p> <p>Once you have done that, you can start the Rook operator again with:</p> <pre><code>kubectl -n rook-ceph scale deployment rook-ceph-operator --replicas=1\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#pvc-based-cluster","title":"PVC-based cluster","text":"<p>To reduce the storage in your cluster or remove a failed OSD on a PVC:</p> <ol> <li>Shrink the number of OSDs in the <code>storageClassDeviceSets</code> in the CephCluster CR. If you have multiple device sets,     you may need to change the index of <code>0</code> in this example path.<ul> <li><code>kubectl -n rook-ceph patch CephCluster rook-ceph --type=json -p '[{\"op\": \"replace\", \"path\": \"/spec/storage/storageClassDeviceSets/0/count\", \"value\":&lt;desired number&gt;}]'</code></li> <li>Reduce the <code>count</code> of the OSDs to the desired number. Rook will not take any action to automatically remove the extra OSD(s).</li> </ul> </li> <li>Identify the PVC that belongs to the OSD that is failed or otherwise being removed.<ul> <li><code>kubectl -n rook-ceph get pvc -l ceph.rook.io/DeviceSet=&lt;deviceSet&gt;</code></li> </ul> </li> <li>Identify the OSD you desire to remove.<ul> <li>The OSD assigned to the PVC can be found in the labels on the PVC</li> <li><code>kubectl -n rook-ceph get pod -l ceph.rook.io/pvc=&lt;orphaned-pvc&gt; -o yaml | grep ceph-osd-id</code></li> <li>For example, this might return: <code>ceph-osd-id: \"0\"</code></li> <li>Remember the OSD ID for purging the OSD below</li> </ul> </li> </ol> <p>If you later increase the count in the device set, note that the operator will create PVCs with the highest index that is not currently in use by existing OSD PVCs.</p>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#confirm-the-osd-is-down","title":"Confirm the OSD is down","text":"<p>If you want to remove an unhealthy OSD, the osd pod may be in an error state such as <code>CrashLoopBackoff</code> or the <code>ceph</code> commands in the toolbox may show which OSD is <code>down</code>. If you want to remove a healthy OSD, you should run the following commands:</p> <pre><code>$ kubectl -n rook-ceph scale deployment rook-ceph-osd-&lt;ID&gt; --replicas=0\n# Inside the toolbox\n$ ceph osd down osd.&lt;ID&gt;\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#purge-the-osd-with-kubectl","title":"Purge the OSD with kubectl","text":"<p>Note</p> <p>The <code>rook-ceph</code> kubectl plugin must be installed</p> <pre><code>kubectl rook-ceph rook purge-osd 0 --force\n\n# 2022-09-14 08:58:28.888431 I | rookcmd: starting Rook v1.10.0-alpha.0.164.gcb73f728c with arguments 'rook ceph osd remove --osd-ids=0 --force-osd-removal=true'\n# 2022-09-14 08:58:28.889217 I | rookcmd: flag values: --force-osd-removal=true, --help=false, --log-level=INFO, --operator-image=, --osd-ids=0, --preserve-pvc=false, --service-account=\n# 2022-09-14 08:58:28.889582 I | op-mon: parsing mon endpoints: b=10.106.118.240:6789\n# 2022-09-14 08:58:28.898898 I | cephclient: writing config file /var/lib/rook/rook-ceph/rook-ceph.config\n# 2022-09-14 08:58:28.899567 I | cephclient: generated admin config in /var/lib/rook/rook-ceph\n# 2022-09-14 08:58:29.421345 I | cephosd: validating status of osd.0\n---\n</code></pre>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#purge-the-osd-with-a-job","title":"Purge the OSD with a Job","text":"<p>OSD removal can be automated with the example found in the rook-ceph-purge-osd job. In the osd-purge.yaml, change the <code>&lt;OSD-IDs&gt;</code> to the ID(s) of the OSDs you want to remove.</p> <ol> <li>Run the job: <code>kubectl create -f osd-purge.yaml</code></li> <li>When the job is completed, review the logs to ensure success: <code>kubectl -n rook-ceph logs -l app=rook-ceph-purge-osd</code></li> <li>When finished, you can delete the job: <code>kubectl delete -f osd-purge.yaml</code></li> </ol> <p>If you want to remove OSDs by hand, continue with the following sections. However, we recommend you use the above-mentioned steps to avoid operation errors.</p>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#purge-the-osd-manually","title":"Purge the OSD manually","text":"<p>If the OSD purge job fails or you need fine-grained control of the removal, here are the individual commands that can be run from the toolbox.</p> <ol> <li>Detach the OSD PVC from Rook<ul> <li><code>kubectl -n rook-ceph label pvc &lt;orphaned-pvc&gt; ceph.rook.io/DeviceSetPVCId-</code></li> </ul> </li> <li>Mark the OSD as <code>out</code> if not already marked as such by Ceph. This signals Ceph to start moving (backfilling) the data that was on that OSD to another OSD.<ul> <li><code>ceph osd out osd.&lt;ID&gt;</code> (for example if the OSD ID is 23 this would be <code>ceph osd out osd.23</code>)</li> </ul> </li> <li>Wait for the data to finish backfilling to other OSDs.<ul> <li><code>ceph status</code> will indicate the backfilling is done when all of the PGs are <code>active+clean</code>. If desired, it's safe to remove the disk after that.</li> </ul> </li> <li>Remove the OSD from the Ceph cluster<ul> <li><code>ceph osd purge &lt;ID&gt; --yes-i-really-mean-it</code></li> </ul> </li> <li>Verify the OSD is removed from the node in the CRUSH map<ul> <li><code>ceph osd tree</code></li> </ul> </li> </ol> <p>The operator can automatically remove OSD deployments that are considered \"safe-to-destroy\" by Ceph. After the steps above, the OSD will be considered safe to remove since the data has all been moved to other OSDs. But this will only be done automatically by the operator if you have this setting in the cluster CR:</p> <pre><code>removeOSDsIfOutAndSafeToRemove: true\n</code></pre> <p>Otherwise, you will need to delete the deployment directly:</p> <pre><code>kubectl delete deployment -n rook-ceph rook-ceph-osd-&lt;ID&gt;\n</code></pre> <p>In PVC-based cluster, remove the orphaned PVC, if necessary.</p>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#delete-the-underlying-data","title":"Delete the underlying data","text":"<p>If you want to clean the device where the OSD was running, see in the instructions to wipe a disk on the Cleaning up a Cluster topic.</p>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#replace-an-osd","title":"Replace an OSD","text":"<p>To replace a disk that has failed:</p> <ol> <li>Run the steps in the previous section to Remove an OSD.</li> <li>Replace the physical device and verify the new device is attached.</li> <li>Check if your cluster CR will find the new device. If you are using <code>useAllDevices: true</code> you can skip this step. If your cluster CR lists individual devices or uses a device filter you may need to update the CR.</li> <li>The operator ideally will automatically create the new OSD within a few minutes of adding the new device or updating the CR. If you don't see a new OSD automatically created, restart the operator (by deleting the operator pod) to trigger the OSD creation.</li> <li>Verify if the OSD is created on the node by running <code>ceph osd tree</code> from the toolbox.</li> </ol> <p>Note</p> <p>The OSD might have a different ID than the previous OSD that was replaced.</p>"},{"location":"Storage-Configuration/Advanced/ceph-osd-mgmt/#osd-migration","title":"OSD Migration","text":"<p>Ceph does not support changing certain settings on existing OSDs. To support changing these settings on an OSD, the OSD must be destroyed and re-created with the new settings. Rook will automate this by migrating only one OSD at a time. The operator waits for the data to rebalance (PGs to become <code>active+clean</code>) before migrating the next OSD. This ensures that there is no data loss. Refer to the OSD migration design doc for more information. </p> <p>The following scenarios are supported for OSD migration:</p> <ul> <li>Enable or disable OSD encryption for existing PVC-based OSDs by changing the <code>encrypted</code> setting under the <code>storageClassDeviceSets</code></li> </ul> <p>For example:</p> <pre><code>storage:\n    migration:\n        confirmation: \"yes-really-migrate-osds\" \n    storageClassDeviceSets:\n        - name: set1\n          count: 3\n          encrypted: true  # change to true or false based on whether encryption needs to enable or disabled.\n</code></pre> <p>Details about the migration status can be found under the cephCluster <code>status.storage.osd.migrationStatus.pending</code> field which shows the total number of OSDs that are pending migration.</p> <p>Note</p> <p>Performance of the cluster might be impacted during data rebalancing while OSDs are being migrated.</p>"},{"location":"Storage-Configuration/Advanced/configuration/","title":"Configuration","text":"<p>For most any Ceph cluster, the user will want to--and may need to--change some Ceph configurations. These changes often may be warranted in order to alter performance to meet SLAs or to update default data resiliency settings.</p> <p>Warning</p> <p>Modify Ceph settings carefully, and review the Ceph configuration documentation before making any changes. Changing the settings could result in unhealthy daemons or even data loss if used incorrectly.</p>"},{"location":"Storage-Configuration/Advanced/configuration/#required-configurations","title":"Required configurations","text":"<p>Rook and Ceph both strive to make configuration as easy as possible, but there are some configuration options which users are well advised to consider for any production cluster.</p>"},{"location":"Storage-Configuration/Advanced/configuration/#default-pg-and-pgp-counts","title":"Default PG and PGP counts","text":"<p>The number of PGs and PGPs can be configured on a per-pool basis, but it is advised to set default values that are appropriate for your Ceph cluster. Appropriate values depend on the number of OSDs the user expects to have backing each pool. These can be configured by declaring pg_num and pgp_num parameters under CephBlockPool resource.</p> <p>For determining the right value for pg_num please refer placement group sizing</p> <p>In this example configuration, 128 PGs are applied to the pool:</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\n  name: ceph-block-pool-test\n  namespace: rook-ceph\nspec:\n  deviceClass: hdd\n  replicated:\n    size: 3\nspec:\n  parameters:\n    pg_num: '128' # create the pool with a pre-configured placement group number\n    pgp_num: '128' # this should at least match `pg_num` so that all PGs are used\n</code></pre> <p>Ceph OSD and Pool config docs provide detailed information about how to tune these parameters.</p> <p>Nautilus introduced the PG auto-scaler mgr module capable of automatically managing PG and PGP values for pools. Please see Ceph New in Nautilus: PG merging and autotuning for more information about this module.</p> <p>The <code>pg_autoscaler</code> module is enabled by default.</p> <p>To disable this module, in the CephCluster CR:</p> <pre><code>spec:\n  mgr:\n    modules:\n    - name: pg_autoscaler\n      enabled: false\n</code></pre> <p>With that setting, the autoscaler will be enabled for all new pools. If you do not desire to have the autoscaler enabled for all new pools, you will need to use the Rook toolbox to enable the module and enable the autoscaling on individual pools.</p>"},{"location":"Storage-Configuration/Advanced/configuration/#specifying-configuration-options","title":"Specifying configuration options","text":""},{"location":"Storage-Configuration/Advanced/configuration/#toolbox-ceph-cli","title":"Toolbox + Ceph CLI","text":"<p>The most recommended way of configuring Ceph is to set Ceph's configuration directly. The first method for doing so is to use Ceph's CLI from the Rook toolbox pod. Using the toolbox pod is detailed here. From the toolbox, the user can change Ceph configurations, enable manager modules, create users and pools, and much more.</p>"},{"location":"Storage-Configuration/Advanced/configuration/#ceph-dashboard","title":"Ceph Dashboard","text":"<p>The Ceph Dashboard, examined in more detail here, is another way of setting some of Ceph's configuration directly. Configuration by the Ceph dashboard is recommended with the same priority as configuration via the Ceph CLI (above).</p>"},{"location":"Storage-Configuration/Advanced/configuration/#advanced-configuration-via-cephconf-override-configmap","title":"Advanced configuration via ceph.conf override ConfigMap","text":"<p>Setting configs via Ceph's CLI requires that at least one mon be available for the configs to be set, and setting configs via dashboard requires at least one mgr to be available. Ceph may also have a small number of very advanced settings that aren't able to be modified easily via CLI or dashboard. The least recommended method for configuring Ceph is intended as a last-resort fallback in situations like these. This is covered in detail here.</p>"},{"location":"Storage-Configuration/Advanced/key-management-system/","title":"Key Management System","text":"<p>Rook has the ability to encrypt OSDs of clusters running on PVC via the flag (<code>encrypted: true</code>) in your <code>storageClassDeviceSets</code> template. Rook also has the ability to rotate encryption keys of OSDs using a cron job per OSD. By default, the Key Encryption Keys (also known as Data Encryption Keys) are stored in a Kubernetes Secret. However, if a Key Management System exists Rook is capable of using it.</p> <p>The <code>security</code> section contains settings related to encryption of the cluster.</p> <ul> <li><code>security</code>:<ul> <li><code>kms</code>: Key Management System settings<ul> <li><code>connectionDetails</code>: the list of parameters representing kms connection details</li> <li><code>tokenSecretName</code>: the name of the Kubernetes Secret containing the kms authentication token</li> </ul> </li> <li><code>keyRotation</code>: Key Rotation settings<ul> <li><code>enabled</code>: whether key rotation is enabled or not, default is <code>false</code></li> <li><code>schedule</code>: the schedule, written in cron format, with which key rotation CronJob is created, default value is <code>\"@weekly\"</code>.</li> </ul> </li> </ul> </li> </ul> <p>Note</p> <p>Currently key rotation is supported when the Key Encryption Keys are stored in a Kubernetes Secret or Vault KMS.</p> <p>Supported KMS providers:</p> <ul> <li>Vault<ul> <li>Authentication methods<ul> <li>Token-based authentication</li> <li>Kubernetes-based authentication</li> </ul> </li> <li>General Vault configuration</li> <li>TLS configuration</li> </ul> </li> <li>IBM Key Protect<ul> <li>Configuration</li> </ul> </li> <li>Key Management Interoperability Protocol<ul> <li>Configuration</li> </ul> </li> <li>Azure Key Vault<ul> <li>Client Authentication</li> </ul> </li> </ul>"},{"location":"Storage-Configuration/Advanced/key-management-system/#vault","title":"Vault","text":"<p>Rook supports storing OSD encryption keys in HashiCorp Vault KMS.</p>"},{"location":"Storage-Configuration/Advanced/key-management-system/#authentication-methods","title":"Authentication methods","text":"<p>Rook support two authentication methods:</p> <ul> <li>token-based: a token is provided by the user and is stored in a Kubernetes Secret. It's used to     authenticate the KMS by the Rook operator. This has several pitfalls such as:<ul> <li>when the token expires it must be renewed, so the secret holding it must be updated</li> <li>no token automatic rotation</li> </ul> </li> <li>Kubernetes Service Account uses Vault Kubernetes native     authentication mechanism and alleviate some of the limitations from the token authentication such as token automatic renewal. This method is     generally recommended over the token-based authentication.</li> </ul>"},{"location":"Storage-Configuration/Advanced/key-management-system/#token-based-authentication","title":"Token-based authentication","text":"<p>When using the token-based authentication, a Kubernetes Secret must be created to hold the token. This is governed by the <code>tokenSecretName</code> parameter.</p> <p>Note: Rook supports all the Vault environment variables.</p> <p>The Kubernetes Secret <code>rook-vault-token</code> should contain:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: rook-vault-token\n  namespace: rook-ceph\ndata:\n  token: &lt;TOKEN&gt; # base64 of a token to connect to Vault, for example: cy5GWXpsbzAyY2duVGVoRjhkWG5Bb3EyWjkK\n</code></pre> <p>You can create a token in Vault by running the following command:</p> <pre><code>vault token create -policy=rook\n</code></pre> <p>Refer to the official vault document for more details on how to create a token. For which policy to apply see the next section.</p> <p>In order for Rook to connect to Vault, you must configure the following in your <code>CephCluster</code> template:</p> <pre><code>security:\n  kms:\n    # name of the k8s config map containing all the kms connection details\n    connectionDetails:\n      KMS_PROVIDER: vault\n      VAULT_ADDR: https://vault.default.svc.cluster.local:8200\n      VAULT_BACKEND_PATH: rook\n      VAULT_SECRET_ENGINE: kv\n      VAULT_AUTH_METHOD: token\n    # name of the k8s secret containing the kms authentication token\n    tokenSecretName: rook-vault-token\n</code></pre>"},{"location":"Storage-Configuration/Advanced/key-management-system/#kubernetes-based-authentication","title":"Kubernetes-based authentication","text":"<p>In order to use the Kubernetes Service Account authentication method, the following must be run to properly configure Vault:</p> <pre><code>ROOK_NAMESPACE=rook-ceph\nROOK_VAULT_SA=rook-vault-auth\nROOK_SYSTEM_SA=rook-ceph-system\nROOK_OSD_SA=rook-ceph-osd\nVAULT_POLICY_NAME=rook\n\n# create service account for vault to validate API token\nkubectl -n \"$ROOK_NAMESPACE\" create serviceaccount \"$ROOK_VAULT_SA\"\n\n# create the RBAC for this SA\nkubectl -n \"$ROOK_NAMESPACE\" create clusterrolebinding vault-tokenreview-binding --clusterrole=system:auth-delegator --serviceaccount=\"$ROOK_NAMESPACE\":\"$ROOK_VAULT_SA\"\n\n# get the service account common.yaml created earlier\nVAULT_SA_SECRET_NAME=$(kubectl -n \"$ROOK_NAMESPACE\" get sa \"$ROOK_VAULT_SA\" -o jsonpath=\"{.secrets[*]['name']}\")\n\n# Set SA_JWT_TOKEN value to the service account JWT used to access the TokenReview API\nSA_JWT_TOKEN=$(kubectl -n \"$ROOK_NAMESPACE\" get secret \"$VAULT_SA_SECRET_NAME\" -o jsonpath=\"{.data.token}\" | base64 --decode)\n\n# Set SA_CA_CRT to the PEM encoded CA cert used to talk to Kubernetes API\nSA_CA_CRT=$(kubectl -n \"$ROOK_NAMESPACE\" get secret \"$VAULT_SA_SECRET_NAME\" -o jsonpath=\"{.data['ca\\.crt']}\" | base64 --decode)\n\n# get kubernetes endpoint\nK8S_HOST=$(kubectl config view --minify --flatten -o jsonpath=\"{.clusters[0].cluster.server}\")\n\n# enable kubernetes auth\nvault auth enable kubernetes\n\n# To fetch the service account issuer\nkubectl proxy &amp;\nproxy_pid=$!\n\n# configure the kubernetes auth\nvault write auth/kubernetes/config \\\n    token_reviewer_jwt=\"$SA_JWT_TOKEN\" \\\n    kubernetes_host=\"$K8S_HOST\" \\\n    kubernetes_ca_cert=\"$SA_CA_CRT\" \\\n    issuer=\"$(curl --silent http://127.0.0.1:8001/.well-known/openid-configuration | jq -r .issuer)\"\n\nkill $proxy_pid\n\n# configure a role for rook\nvault write auth/kubernetes/role/\"$ROOK_NAMESPACE\" \\\n    bound_service_account_names=\"$ROOK_SYSTEM_SA\",\"$ROOK_OSD_SA\" \\\n    bound_service_account_namespaces=\"$ROOK_NAMESPACE\" \\\n    policies=\"$VAULT_POLICY_NAME\" \\\n    ttl=1440h\n</code></pre> <p>Once done, your <code>CephCluster</code> CR should look like:</p> <pre><code>security:\n  kms:\n    connectionDetails:\n        KMS_PROVIDER: vault\n        VAULT_ADDR: https://vault.default.svc.cluster.local:8200\n        VAULT_BACKEND_PATH: rook\n        VAULT_SECRET_ENGINE: kv\n        VAULT_AUTH_METHOD: kubernetes\n        VAULT_AUTH_KUBERNETES_ROLE: rook-ceph\n</code></pre> <p>Note</p> <p>The <code>VAULT_ADDR</code> value above assumes that Vault is accessible within the cluster itself on the default port (8200). If running elsewhere, please update the URL accordingly.</p>"},{"location":"Storage-Configuration/Advanced/key-management-system/#general-vault-configuration","title":"General Vault configuration","text":"<p>As part of the token, here is an example of a policy that can be used:</p> <pre><code>path \"rook/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"sys/mounts\" {\ncapabilities = [\"read\"]\n}\n</code></pre> <p>You can write the policy like so and then create a token:</p> <pre><code>$ vault policy write rook /tmp/rook.hcl\n$ vault token create -policy=rook\nKey                  Value\n---                  -----\ntoken                s.FYzlo02cgnTehF8dXnAoq2Z9\ntoken_accessor       oMo7sAXQKbYtxU4HtO8k3pko\ntoken_duration       768h\ntoken_renewable      true\ntoken_policies       [\"default\" \"rook\"]\nidentity_policies    []\npolicies             [\"default\" \"rook\"]\n</code></pre> <p>In the above example, Vault's secret backend path name is <code>rook</code>. It must be enabled with the following:</p> <pre><code>vault secrets enable -path=rook kv\n</code></pre> <p>If a different path is used, the <code>VAULT_BACKEND_PATH</code> key in <code>connectionDetails</code> must be changed.</p>"},{"location":"Storage-Configuration/Advanced/key-management-system/#tls-configuration","title":"TLS configuration","text":"<p>This is an advanced but recommended configuration for production deployments, in this case the <code>vault-connection-details</code> will look like:</p> <pre><code>security:\n  kms:\n    # name of the k8s config map containing all the kms connection details\n    connectionDetails:\n      KMS_PROVIDER: vault\n      VAULT_ADDR: https://vault.default.svc.cluster.local:8200\n      VAULT_CACERT: &lt;name of the k8s secret containing the PEM-encoded CA certificate&gt;\n      VAULT_CLIENT_CERT: &lt;name of the k8s secret containing the PEM-encoded client certificate&gt;\n      VAULT_CLIENT_KEY: &lt;name of the k8s secret containing the PEM-encoded private key&gt;\n    # name of the k8s secret containing the kms authentication token\n    tokenSecretName: rook-vault-token\n</code></pre> <p>Each secret keys are expected to be:</p> <ul> <li>VAULT_CACERT: <code>cert</code></li> <li>VAULT_CLIENT_CERT: <code>cert</code></li> <li>VAULT_CLIENT_KEY: <code>key</code></li> </ul> <p>For instance <code>VAULT_CACERT</code> Secret named <code>vault-tls-ca-certificate</code> will look like:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: vault-tls-ca-certificate\n  namespace: rook-ceph\ndata:\n  cert: &lt;PEM base64 encoded CA certificate&gt;\n</code></pre> <p>Note: if you are using self-signed certificates (not known/approved by a proper CA) you must pass <code>VAULT_SKIP_VERIFY: true</code>. Communications will remain encrypted but the validity of the certificate will not be verified.</p>"},{"location":"Storage-Configuration/Advanced/key-management-system/#ibm-key-protect","title":"IBM Key Protect","text":"<p>Rook supports storing OSD encryption keys in IBM Key Protect. The current implementation stores OSD encryption keys as Standard Keys using the Bring Your Own Key (BYOK) method. This means that the Key Protect instance policy must have Standard Imported Key enabled.</p>"},{"location":"Storage-Configuration/Advanced/key-management-system/#configuration","title":"Configuration","text":"<p>First, you need to provision the Key Protect service on the IBM Cloud. Once completed, retrieve the instance ID. Make a record of it; we need it in the CRD.</p> <p>On the IBM Cloud, the user must create a Service ID, then assign an Access Policy to this service. Ultimately, a Service API Key needs to be generated. All the steps are summarized in the official documentation.</p> <p>The Service ID must be granted access to the Key Protect Service. Once the Service API Key is generated, store it in a Kubernetes Secret.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: ibm-kp-svc-api-key\n  namespace: rook-ceph\ndata:\n  IBM_KP_SERVICE_API_KEY: &lt;service API Key&gt;\n</code></pre> <p>In order for Rook to connect to IBM Key Protect, you must configure the following in your <code>CephCluster</code> template:</p> <pre><code>security:\n  kms:\n    # name of the k8s config map containing all the kms connection details\n    connectionDetails:\n      KMS_PROVIDER: ibmkeyprotect\n      IBM_KP_SERVICE_INSTANCE_ID: &lt;instance ID that was retrieved in the first paragraph&gt;\n    # name of the k8s secret containing the service API Key\n    tokenSecretName: ibm-kp-svc-api-key\n</code></pre> <p>More options are supported such as:</p> <ul> <li><code>IBM_BASE_URL</code>: the base URL of the Key Protect instance, depending on your     region. Defaults to <code>https://us-south.kms.cloud.ibm.com</code>.</li> <li><code>IBM_TOKEN_URL</code>: the URL of the Key Protect instance to retrieve the token. Defaults to     <code>https://iam.cloud.ibm.com/oidc/token</code>. Only needed for private instances.</li> </ul>"},{"location":"Storage-Configuration/Advanced/key-management-system/#key-management-interoperability-protocol","title":"Key Management Interoperability Protocol","text":"<p>Rook supports storing OSD encryption keys in Key Management Interoperability Protocol (KMIP) supported KMS. The current implementation stores OSD encryption keys using the Register operation. Key is fetched and deleted using Get and Destroy operations respectively.</p>"},{"location":"Storage-Configuration/Advanced/key-management-system/#configuration_1","title":"Configuration","text":"<p>The Secret with credentials for the KMIP KMS is expected to contain the following.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: kmip-credentials\n  namespace: rook-ceph\nstringData:\n  CA_CERT: &lt;ca certificate&gt;\n  CLIENT_CERT: &lt;client certificate&gt;\n  CLIENT_KEY: &lt;client key&gt;\n</code></pre> <p>In order for Rook to connect to KMIP, you must configure the following in your <code>CephCluster</code> template:</p> <pre><code>security:\n  kms:\n    # name of the k8s config map containing all the kms connection details\n    connectionDetails:\n      KMS_PROVIDER: kmip\n      KMIP_ENDPOINT: &lt;KMIP endpoint address&gt;\n      # (optional) The endpoint server name. Useful when the KMIP endpoint does not have a DNS entry.\n      TLS_SERVER_NAME: &lt;tls server name&gt;\n      # (optional) Network read timeout, in seconds. The default value is 10.\n      READ_TIMEOUT: &lt;read timeout&gt;\n      # (optional) Network write timeout, in seconds. The default value is 10.\n      WRITE_TIMEOUT: &lt;write timeout&gt;\n    # name of the k8s secret containing the credentials.\n    tokenSecretName: kmip-credentials\n</code></pre>"},{"location":"Storage-Configuration/Advanced/key-management-system/#azure-key-vault","title":"Azure Key Vault","text":"<p>Rook supports storing OSD encryption keys in Azure Key vault</p>"},{"location":"Storage-Configuration/Advanced/key-management-system/#client-authentication","title":"Client Authentication","text":"<p>Different methods are available in Azure to authenticate a client. Rook supports Azure recommended method of authentication with Service Principal and a certificate. Refer the following Azure documentation to set up key vault and authenticate it via service principal and certtificate</p> <ul> <li> <p>Create Azure Key Vault</p> <ul> <li><code>AZURE_VAULT_URL</code> can be retrieved at this step</li> </ul> </li> <li> <p>Create Service Principal</p> <ul> <li><code>AZURE_CLIENT_ID</code> and <code>AZURE_TENANT_ID</code> can be obtained after creating the service principal</li> <li>Ensure that the service principal is authenticated with a certificate and not with a client secret.</li> </ul> </li> <li> <p>Set Azure Key Vault RBAC</p> <ul> <li>Ensure that the role assigned to the key vault should be able to create, retrieve and delete secrets in the key vault.</li> </ul> </li> </ul> <p>Provide the following KMS connection details in order to connect with Azure Key Vault.</p> <pre><code>security:\n  kms:\n    connectionDetails:\n      KMS_PROVIDER: azure-kv\n      AZURE_VAULT_URL: https://&lt;key-vault name&gt;.vault.azure.net\n      AZURE_CLIENT_ID: Application ID of an Azure service principal\n      AZURE_TENANT_ID: ID of the application's Microsoft Entra tenant\n      AZURE_CERT_SECRET_NAME: &lt;name of the k8s secret containing the certificate along with the private key (without password protection)&gt;\n</code></pre> <ul> <li><code>AZURE_CERT_SECRET_NAME</code> should hold the name of the k8s secret. The secret data should be base64 encoded certificate along with private key (without password protection)</li> </ul>"},{"location":"Storage-Configuration/Block-Storage-RBD/block-storage/","title":"Block Storage Overview","text":"<p>Block storage allows a single pod to mount storage. This guide shows how to create a simple, multi-tier web application on Kubernetes using persistent volumes enabled by Rook.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/block-storage/#prerequisites","title":"Prerequisites","text":"<p>This guide assumes a Rook cluster as explained in the Quickstart.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/block-storage/#provision-storage","title":"Provision Storage","text":"<p>Before Rook can provision storage, a <code>StorageClass</code> and <code>CephBlockPool</code> CR need to be created. This will allow Kubernetes to interoperate with Rook when provisioning persistent volumes.</p> <p>Note</p> <p>This sample requires at least 1 OSD per node, with each OSD located on 3 different nodes.</p> <p>Each OSD must be located on a different node, because the <code>failureDomain</code> is set to <code>host</code> and the <code>replicated.size</code> is set to <code>3</code>.</p> <p>Save this <code>StorageClass</code> definition as <code>storageclass.yaml</code>:</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\n  name: replicapool\n  namespace: rook-ceph\nspec:\n  failureDomain: host\n  replicated:\n    size: 3\n---\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n   name: rook-ceph-block\n# Change \"rook-ceph\" provisioner prefix to match the operator namespace if needed\nprovisioner: rook-ceph.rbd.csi.ceph.com\nparameters:\n    # clusterID is the namespace where the rook cluster is running\n    clusterID: rook-ceph\n    # Ceph pool into which the RBD image shall be created\n    pool: replicapool\n\n    # (optional) mapOptions is a comma-separated list of map options.\n    # For krbd options refer\n    # https://docs.ceph.com/docs/master/man/8/rbd/#kernel-rbd-krbd-options\n    # For nbd options refer\n    # https://docs.ceph.com/docs/master/man/8/rbd-nbd/#options\n    # mapOptions: lock_on_read,queue_depth=1024\n\n    # (optional) unmapOptions is a comma-separated list of unmap options.\n    # For krbd options refer\n    # https://docs.ceph.com/docs/master/man/8/rbd/#kernel-rbd-krbd-options\n    # For nbd options refer\n    # https://docs.ceph.com/docs/master/man/8/rbd-nbd/#options\n    # unmapOptions: force\n\n    # RBD image format. Defaults to \"2\".\n    imageFormat: \"2\"\n\n    # RBD image features\n    # Available for imageFormat: \"2\". Older releases of CSI RBD\n    # support only the `layering` feature. The Linux kernel (KRBD) supports the\n    # full complement of features as of 5.4\n    # `layering` alone corresponds to Ceph's bitfield value of \"2\" ;\n    # `layering` + `fast-diff` + `object-map` + `deep-flatten` + `exclusive-lock` together\n    # correspond to Ceph's OR'd bitfield value of \"63\". Here we use\n    # a symbolic, comma-separated format:\n    # For 5.4 or later kernels:\n    #imageFeatures: layering,fast-diff,object-map,deep-flatten,exclusive-lock\n    # For 5.3 or earlier kernels:\n    imageFeatures: layering\n\n    # The secrets contain Ceph admin credentials.\n    csi.storage.k8s.io/provisioner-secret-name: rook-csi-rbd-provisioner\n    csi.storage.k8s.io/provisioner-secret-namespace: rook-ceph\n    csi.storage.k8s.io/controller-expand-secret-name: rook-csi-rbd-provisioner\n    csi.storage.k8s.io/controller-expand-secret-namespace: rook-ceph\n    csi.storage.k8s.io/node-stage-secret-name: rook-csi-rbd-node\n    csi.storage.k8s.io/node-stage-secret-namespace: rook-ceph\n\n    # Specify the filesystem type of the volume. If not specified, csi-provisioner\n    # will set default as `ext4`. Note that `xfs` is not recommended due to potential deadlock\n    # in hyperconverged settings where the volume is mounted on the same node as the osds.\n    csi.storage.k8s.io/fstype: ext4\n\n# Delete the rbd volume when a PVC is deleted\nreclaimPolicy: Delete\n\n# Optional, if you want to add dynamic resize for PVC.\n# For now only ext3, ext4, xfs resize support provided, like in Kubernetes itself.\nallowVolumeExpansion: true\n</code></pre> <p>If you've deployed the Rook operator in a namespace other than \"rook-ceph\", change the prefix in the provisioner to match the namespace you used. For example, if the Rook operator is running in the namespace \"my-namespace\" the provisioner value should be \"my-namespace.rbd.csi.ceph.com\".</p> <p>Create the storage class.</p> <pre><code>kubectl create -f deploy/examples/csi/rbd/storageclass.yaml\n</code></pre> <p>Note</p> <p>As specified by Kubernetes, when using the <code>Retain</code> reclaim policy, any Ceph RBD image that is backed by a <code>PersistentVolume</code> will continue to exist even after the <code>PersistentVolume</code> has been deleted. These Ceph RBD images will need to be cleaned up manually using <code>rbd rm</code>.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/block-storage/#consume-the-storage-wordpress-sample","title":"Consume the storage: Wordpress sample","text":"<p>We create a sample app to consume the block storage provisioned by Rook with the classic wordpress and mysql apps. Both of these apps will make use of block volumes provisioned by Rook.</p> <p>Start mysql and wordpress from the <code>deploy/examples</code> folder:</p> <pre><code>kubectl create -f mysql.yaml\nkubectl create -f wordpress.yaml\n</code></pre> <p>Both of these apps create a block volume and mount it to their respective pod. You can see the Kubernetes volume claims by running the following:</p> <pre><code>kubectl get pvc\n</code></pre> <p>Example Output: <code>kubectl get pvc</code></p> <pre><code>NAME             STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE\nmysql-pv-claim   Bound     pvc-95402dbc-efc0-11e6-bc9a-0cc47a3459ee   20Gi       RWO           1m\nwp-pv-claim      Bound     pvc-39e43169-efc1-11e6-bc9a-0cc47a3459ee   20Gi       RWO           1m\n</code></pre> <p>Once the wordpress and mysql pods are in the <code>Running</code> state, get the cluster IP of the wordpress app and enter it in your browser:</p> <pre><code>kubectl get svc wordpress\n</code></pre> <p>Example Output: <code>kubectl get svc wordpress</code></p> <pre><code>NAME        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE\nwordpress   10.3.0.155   &lt;pending&gt;     80:30841/TCP   2m\n</code></pre> <p>You should see the wordpress app running.</p> <p>If you are using Minikube, the Wordpress URL can be retrieved with this one-line command:</p> <pre><code>echo http://$(minikube ip):$(kubectl get service wordpress -o jsonpath='{.spec.ports[0].nodePort}')\n</code></pre> <p>Note</p> <p>When running in a vagrant environment, there will be no external IP address to reach wordpress with.  You will only be able to reach wordpress via the <code>CLUSTER-IP</code> from inside the Kubernetes cluster.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/block-storage/#consume-the-storage-toolbox","title":"Consume the storage: Toolbox","text":"<p>With the pool that was created above, we can also create a block image and mount it directly in a pod. See the Direct Block Tools topic for more details.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/block-storage/#teardown","title":"Teardown","text":"<p>To clean up all the artifacts created by the block demo:</p> <pre><code>kubectl delete -f wordpress.yaml\nkubectl delete -f mysql.yaml\nkubectl delete -n rook-ceph cephblockpools.ceph.rook.io replicapool\nkubectl delete storageclass rook-ceph-block\n</code></pre>"},{"location":"Storage-Configuration/Block-Storage-RBD/block-storage/#advanced-example-erasure-coded-block-storage","title":"Advanced Example: Erasure Coded Block Storage","text":"<p>If you want to use erasure coded pool with RBD, your OSDs must use <code>bluestore</code> as their <code>storeType</code>. Additionally the nodes that are going to mount the erasure coded RBD block storage must have Linux kernel &gt;= <code>4.11</code>.</p> <p>Attention</p> <p>This example requires at least 3 bluestore OSDs, with each OSD located on a different node.</p> <p>The OSDs must be located on different nodes, because the <code>failureDomain</code> is set to <code>host</code> and the <code>erasureCoded</code> chunk settings require at least 3 different OSDs (2 <code>dataChunks</code> + 1 <code>codingChunks</code>).</p> <p>To be able to use an erasure coded pool you need to create two pools (as seen below in the definitions): one erasure coded and one replicated.</p> <p>Attention</p> <p>This example requires at least 3 bluestore OSDs, with each OSD located on a different node.</p> <p>The OSDs must be located on different nodes, because the <code>failureDomain</code> is set to <code>host</code> and the <code>erasureCoded</code> chunk settings require at least 3 different OSDs (2 <code>dataChunks</code> + 1 <code>codingChunks</code>).</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/block-storage/#erasure-coded-csi-driver","title":"Erasure Coded CSI Driver","text":"<p>The erasure coded pool must be set as the <code>dataPool</code> parameter in <code>storageclass-ec.yaml</code> It is used for the data of the RBD images.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/block-storage/#node-loss","title":"Node Loss","text":"<p>If a node goes down where a pod is running where a RBD RWO volume is mounted, the volume cannot automatically be mounted on another node. The node must be guaranteed to be offline before the volume can be mounted on another node.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/block-storage/#configure-csi-addons","title":"Configure CSI-Addons","text":"<p>Deploy csi-addons controller and enable <code>csi-addons</code> sidecar as mentioned in the CSI Addons guide.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/block-storage/#handling-node-loss","title":"Handling Node Loss","text":"<p>Warning</p> <p>Automated node loss handling is currently disabled, please refer to the manual steps to recover from the node loss. We are actively working on a new design for this feature. For more details see the tracking issue.</p> <p>When a node is confirmed to be down, add the following taints to the node:</p> <pre><code>kubectl taint nodes &lt;node-name&gt; node.kubernetes.io/out-of-service=nodeshutdown:NoExecute\nkubectl taint nodes &lt;node-name&gt; node.kubernetes.io/out-of-service=nodeshutdown:NoSchedule\n</code></pre> <p>After the taint is added to the node, Rook will automatically blocklist the node to prevent connections to Ceph from the RBD volume on that node. To verify a node is blocklisted:</p> <pre><code>kubectl get networkfences.csiaddons.openshift.io\nNAME           DRIVER                       CIDRS                     FENCESTATE   AGE   RESULT\nminikube-m02   rook-ceph.rbd.csi.ceph.com   [\"192.168.39.187:0/32\"]   Fenced       20s   Succeeded\n</code></pre> <p>The node is blocklisted if the state is <code>Fenced</code> and the result is <code>Succeeded</code> as seen above.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/block-storage/#node-recovery","title":"Node Recovery","text":"<p>If the node comes back online, the network fence can be removed from the node by removing the node taints:</p> <pre><code>kubectl taint nodes &lt;node-name&gt; node.kubernetes.io/out-of-service=nodeshutdown:NoExecute-\nkubectl taint nodes &lt;node-name&gt; node.kubernetes.io/out-of-service=nodeshutdown:NoSchedule-\n</code></pre>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-async-disaster-recovery-failover-failback/","title":"RBD Asynchronous DR Failover and Failback","text":""},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-async-disaster-recovery-failover-failback/#planned-migration-and-disaster-recovery","title":"Planned Migration and Disaster Recovery","text":"<p>Rook comes with the volume replication support, which allows users to perform disaster recovery and planned migration of clusters.</p> <p>The following document will help to track the procedure for failover and failback in case of a Disaster recovery or Planned migration use cases.</p> <p>Note</p> <p>The document assumes that RBD Mirroring is set up between the peer clusters. For information on rbd mirroring and how to set it up using rook, please refer to the rbd-mirroring guide.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-async-disaster-recovery-failover-failback/#planned-migration","title":"Planned Migration","text":"<p>Info</p> <p>Use cases: Datacenter maintenance, technology refresh, disaster avoidance, etc.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-async-disaster-recovery-failover-failback/#relocation","title":"Relocation","text":"<p>The Relocation operation is the process of switching production to a backup facility(normally your recovery site) or vice versa. For relocation, access to the image on the primary site should be stopped. The image should now be made primary on the secondary cluster so that the access can be resumed there.</p> <p>Note</p> <p> Periodic or one-time backup of the application should be available for restore on the secondary site (cluster-2).</p> <p>Follow the below steps for planned migration of workload from the primary cluster to the secondary cluster:</p> <ul> <li>Scale down all the application pods which are using the     mirrored PVC on the Primary Cluster.</li> <li>Take a backup of PVC and PV object from the primary cluster.     This can be done using some backup tools like     velero.</li> <li>Update VolumeReplication CR to set <code>replicationState</code> to <code>secondary</code> at the Primary Site.     When the operator sees this change, it will pass the information down to the     driver via GRPC request to mark the dataSource as <code>secondary</code>.</li> <li>If you are manually recreating the PVC and PV on the secondary cluster,     remove the <code>claimRef</code> section in the PV objects. (See this for details)</li> <li>Recreate the storageclass, PVC, and PV objects on the secondary site.</li> <li>As you are creating the static binding between PVC and PV, a new PV won\u2019t     be created here, the PVC will get bind to the existing PV.</li> <li>Create the VolumeReplicationClass on the secondary site.</li> <li>Create VolumeReplications for all the PVC\u2019s for which mirroring is enabled<ul> <li><code>replicationState</code> should be <code>primary</code> for all the PVC\u2019s on the secondary site.</li> </ul> </li> <li>Check VolumeReplication CR status to verify if the image is marked <code>primary</code> on the secondary site.</li> <li>Once the Image is marked as <code>primary</code>, the PVC is now ready     to be used. Now, we can scale up the applications to use the PVC.</li> </ul> <p>Warning</p> <p> In Async Disaster recovery use case, we don't get the complete data. We will only get the crash-consistent data based on the snapshot interval time.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-async-disaster-recovery-failover-failback/#disaster-recovery","title":"Disaster Recovery","text":"<p>Info</p> <p>Use cases: Natural disasters, Power failures, System failures, and crashes, etc.</p> <p>Note</p> <p>To effectively resume operations after a failover/relocation, backup of the kubernetes artifacts like deployment, PVC, PV, etc need to be created beforehand by the admin; so that the application can be restored on the peer cluster. For more information, see backup and restore.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-async-disaster-recovery-failover-failback/#failover-abrupt-shutdown","title":"Failover (abrupt shutdown)","text":"<p>In case of Disaster recovery, create VolumeReplication CR at the Secondary Site. Since the connection to the Primary Site is lost, the operator automatically sends a GRPC request down to the driver to forcefully mark the dataSource as <code>primary</code> on the Secondary Site.</p> <ul> <li>If you are manually creating the PVC and PV on the secondary cluster, remove     the claimRef section in the PV objects. (See this for details)</li> <li>Create the storageclass, PVC, and PV objects on the secondary site.</li> <li>As you are creating the static binding between PVC and PV, a new PV won\u2019t be     created here, the PVC will get bind to the existing PV.</li> <li>Create the VolumeReplicationClass and VolumeReplication CR on the secondary site.</li> <li>Check VolumeReplication CR status to verify if the image is marked <code>primary</code> on the secondary site.</li> <li>Once the Image is marked as <code>primary</code>, the PVC is now ready to be used. Now,     we can scale up the applications to use the PVC.</li> </ul>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-async-disaster-recovery-failover-failback/#failback-post-disaster-recovery","title":"Failback (post-disaster recovery)","text":"<p>Once the failed cluster is recovered on the primary site and you want to failback from secondary site, follow the below steps:</p> <ul> <li>Scale down the running applications (if any) on the primary site.     Ensure that all persistent volumes in use by the workload are no     longer in use on the primary cluster.</li> <li>Update VolumeReplication CR replicationState     from <code>primary</code> to <code>secondary</code> on the primary site.</li> <li>Scale down the applications on the secondary site.</li> <li>Update VolumeReplication CR replicationState state from <code>primary</code> to     <code>secondary</code> in secondary site.</li> <li>On the primary site, verify the VolumeReplication status is marked as     volume ready to use.</li> <li>Once the volume is marked to ready to use, change the replicationState state     from <code>secondary</code> to <code>primary</code> in primary site.</li> <li>Scale up the applications again on the primary site.</li> </ul>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/","title":"RBD Mirroring","text":""},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#disaster-recovery","title":"Disaster Recovery","text":"<p>Disaster recovery (DR) is an organization's ability to react to and recover from an incident that negatively affects business operations. This plan comprises strategies for minimizing the consequences of a disaster, so an organization can continue to operate \u2013 or quickly resume the key operations. Thus, disaster recovery is one of the aspects of business continuity. One of the solutions, to achieve the same, is RBD mirroring.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#rbd-mirroring","title":"RBD Mirroring","text":"<p>RBD mirroring is an asynchronous replication of RBD images between multiple Ceph clusters. This capability is available in two modes:</p> <ul> <li>Journal-based: Every write to the RBD image is first recorded     to the associated journal before modifying the actual image.     The remote cluster will read from this associated journal and     replay the updates to its local image.</li> <li>Snapshot-based: This mode uses periodically scheduled or     manually created RBD image mirror-snapshots to replicate     crash-consistent RBD images between clusters.</li> </ul> <p>Note</p> <p>This document sheds light on rbd mirroring and how to set it up using rook. See also the topic on Failover and Failback</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#create-rbd-pools","title":"Create RBD Pools","text":"<p>In this section, we create specific RBD pools that are RBD mirroring enabled for use with the DR use case.</p> <p>Execute the following steps on each peer cluster to create mirror enabled pools:</p> <ul> <li> <p>Create a RBD pool that is enabled for mirroring by adding the section     <code>spec.mirroring</code> in the CephBlockPool CR:</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\nname: mirrored-pool\nnamespace: rook-ceph\nspec:\nreplicated:\n    size: 1\nmirroring:\n    enabled: true\n    mode: image\n</code></pre> <pre><code>kubectl create -f pool-mirrored.yaml\n</code></pre> </li> <li> <p>Repeat the steps on the peer cluster.</p> </li> </ul> <p>Note</p> <p>Pool name across the cluster peers must be the same for RBD replication to function.</p> <p>See the CephBlockPool documentation for more details.</p> <p>Note</p> <p>It is also feasible to edit existing pools and enable them for replication.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#bootstrap-peers","title":"Bootstrap Peers","text":"<p>In order for the rbd-mirror daemon to discover its peer cluster, the peer must be registered and a user account must be created.</p> <p>The following steps enable bootstrapping peers to discover and authenticate to each other:</p> <ul> <li>For Bootstrapping a peer cluster its bootstrap secret is required. To determine the name of the secret that contains the bootstrap secret execute the following command on the remote cluster (cluster-2)</li> </ul> <pre><code>[cluster-2]$ kubectl get cephblockpool.ceph.rook.io/mirrored-pool -n rook-ceph -ojsonpath='{.status.info.rbdMirrorBootstrapPeerSecretName}'\n</code></pre> <p>Here, <code>pool-peer-token-mirrored-pool</code> is the desired bootstrap secret name.</p> <ul> <li> <p>The secret pool-peer-token-mirrored-pool contains all the information related to the token and needs to be injected to the peer, to fetch the decoded secret:</p> <pre><code>[cluster-2]$ kubectl get secret -n rook-ceph pool-peer-token-mirrored-pool -o jsonpath='{.data.token}'|base64 -d\neyJmc2lkIjoiNGQ1YmNiNDAtNDY3YS00OWVkLThjMGEtOWVhOGJkNDY2OTE3IiwiY2xpZW50X2lkIjoicmJkLW1pcnJvci1wZWVyIiwia2V5IjoiQVFDZ3hmZGdxN013R0JBQWZzcUtCaGpZVjJUZDRxVzJYQm5kemc9PSIsIm1vbl9ob3N0IjoiW3YyOjE5Mi4xNjguMzkuMzY6MzMwMCx2MToxOTIuMTY4LjM5LjM2OjY3ODldIn0=\n</code></pre> </li> <li> <p>With this Decoded value, create a secret on the primary site (cluster-1):</p> <pre><code>[cluster-1]$ kubectl -n rook-ceph create secret generic rbd-primary-site-secret --from-literal=token=eyJmc2lkIjoiNGQ1YmNiNDAtNDY3YS00OWVkLThjMGEtOWVhOGJkNDY2OTE3IiwiY2xpZW50X2lkIjoicmJkLW1pcnJvci1wZWVyIiwia2V5IjoiQVFDZ3hmZGdxN013R0JBQWZzcUtCaGpZVjJUZDRxVzJYQm5kemc9PSIsIm1vbl9ob3N0IjoiW3YyOjE5Mi4xNjguMzkuMzY6MzMwMCx2MToxOTIuMTY4LjM5LjM2OjY3ODldIn0= --from-literal=pool=mirrored-pool\n</code></pre> </li> <li> <p>This completes the bootstrap process for cluster-1 to be peered with cluster-2.</p> </li> <li>Repeat the process switching cluster-2 in place of cluster-1, to complete the bootstrap process across both peer clusters.</li> </ul> <p>For more details, refer to the official rbd mirror documentation on how to create a bootstrap peer.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#configure-the-rbdmirror-daemon","title":"Configure the RBDMirror Daemon","text":"<p>Replication is handled by the rbd-mirror daemon. The rbd-mirror daemon is responsible for pulling image updates from the remote, peer cluster, and applying them to image within the local cluster.</p> <p>Creation of the rbd-mirror daemon(s) is done through the custom resource definitions (CRDs), as follows:</p> <ul> <li> <p>Create mirror.yaml, to deploy the rbd-mirror daemon</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephRBDMirror\nmetadata:\nname: my-rbd-mirror\nnamespace: rook-ceph\nspec:\n# the number of rbd-mirror daemons to deploy\ncount: 1\n</code></pre> </li> <li> <p>Create the RBD mirror daemon</p> <pre><code>[cluster-1]$ kubectl create -f mirror.yaml -n rook-ceph\n</code></pre> </li> <li> <p>Validate if <code>rbd-mirror</code> daemon pod is now up</p> <pre><code>[cluster-1]$ kubectl get pods -n rook-ceph\nrook-ceph-rbd-mirror-a-6985b47c8c-dpv4k  1/1  Running  0  10s\n</code></pre> </li> <li> <p>Verify that daemon health is OK</p> <pre><code>kubectl get cephblockpools.ceph.rook.io mirrored-pool -n rook-ceph -o jsonpath='{.status.mirroringStatus.summary}'\n{\"daemon_health\":\"OK\",\"health\":\"OK\",\"image_health\":\"OK\",\"states\":{\"replaying\":1}}\n</code></pre> </li> <li> <p>Repeat the above steps on the peer cluster.</p> </li> </ul> <p>See the CephRBDMirror CRD for more details on the mirroring settings.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#add-mirroring-peer-information-to-rbd-pools","title":"Add mirroring peer information to RBD pools","text":"<p>Each pool can have its own peer. To add the peer information, patch the already created mirroring enabled pool to update the CephBlockPool CRD.</p> <pre><code>[cluster-1]$ kubectl -n rook-ceph patch cephblockpool mirrored-pool --type merge -p '{\"spec\":{\"mirroring\":{\"peers\": {\"secretNames\": [\"rbd-primary-site-secret\"]}}}}'\n</code></pre>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#create-volumereplication-crds","title":"Create VolumeReplication CRDs","text":"<p>Volume Replication Operator follows controller pattern and provides extended APIs for storage disaster recovery. The extended APIs are provided via Custom Resource Definition(CRD). Create the VolumeReplication CRDs on all the peer clusters.</p> <pre><code>kubectl create -f https://raw.githubusercontent.com/csi-addons/kubernetes-csi-addons/v0.5.0/config/crd/bases/replication.storage.openshift.io_volumereplicationclasses.yaml\nkubectl create -f https://raw.githubusercontent.com/csi-addons/kubernetes-csi-addons/v0.5.0/config/crd/bases/replication.storage.openshift.io_volumereplications.yaml\n</code></pre>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#enable-csi-replication-sidecars","title":"Enable CSI Replication Sidecars","text":"<p>To achieve RBD Mirroring, <code>csi-omap-generator</code> and <code>csi-addons</code> containers need to be deployed in the RBD provisioner pods, which are not enabled by default.</p> <ul> <li> <p>Omap Generator: Omap generator is a sidecar container that when     deployed with the CSI provisioner pod, generates the internal CSI     omaps between the PV and the RBD image. This is required as static PVs are     transferred across peer clusters in the DR use case, and hence     is needed to preserve PVC to storage mappings.</p> </li> <li> <p>Volume Replication Operator: Volume Replication Operator is a     kubernetes operator that provides common and reusable APIs for     storage disaster recovery. The volume replication operation is     supported by the CSIAddons     It is based on csi-addons/spec     specification and can be used by any storage provider.</p> </li> </ul> <p>Execute the following steps on each peer cluster to enable the OMap generator and CSIADDONS sidecars:</p> <ul> <li> <p>Edit the <code>rook-ceph-operator-config</code> configmap and add the following configurations</p> <pre><code>kubectl edit cm rook-ceph-operator-config -n rook-ceph\n</code></pre> <p>Add the following properties if not present:</p> <pre><code>data:\nCSI_ENABLE_OMAP_GENERATOR: \"true\"\nCSI_ENABLE_CSIADDONS: \"true\"\n</code></pre> </li> <li> <p>After updating the configmap with those settings, two new sidecars     should now start automatically in the CSI provisioner pod.</p> </li> <li> <p>Repeat the steps on the peer cluster.</p> </li> </ul>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#volume-replication-custom-resources","title":"Volume Replication Custom Resources","text":"<p>VolumeReplication CRDs provide support for two custom resources:</p> <ul> <li> <p>VolumeReplicationClass: VolumeReplicationClass is a cluster scoped resource that contains driver related configuration parameters. It holds the storage admin information required for the volume replication operator.</p> </li> <li> <p>VolumeReplication: VolumeReplication is a namespaced resource that contains references to storage object to be replicated and VolumeReplicationClass corresponding to the driver providing replication.</p> </li> </ul>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#enable-mirroring-on-a-pvc","title":"Enable mirroring on a PVC","text":"<p>Below guide assumes that we have a PVC (rbd-pvc) in BOUND state; created using StorageClass with <code>Retain</code> reclaimPolicy.</p> <pre><code>[cluster-1]$ kubectl get pvc\nNAME      STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS      AGE\nrbd-pvc   Bound    pvc-65dc0aac-5e15-4474-90f4-7a3532c621ec   1Gi        RWO            csi-rbd-sc   44s\n</code></pre>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#create-a-volume-replication-class-cr","title":"Create a Volume Replication Class CR","text":"<p>In this case, we create a Volume Replication Class on cluster-1</p> <pre><code>[cluster-1]$ kubectl apply -f deploy/examples/volume-replication-class.yaml\n</code></pre> <p>Note</p> <p>The <code>schedulingInterval</code> can be specified in formats of minutes, hours or days using suffix <code>m</code>, <code>h</code> and <code>d</code> respectively. The optional schedulingStartTime can be specified using the ISO 8601 time format.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#create-a-volumereplication-cr","title":"Create a VolumeReplication CR","text":"<ul> <li>Once VolumeReplicationClass is created, create a Volume Replication for     the PVC which we intend to replicate to secondary cluster.</li> </ul> <pre><code>[cluster-1]$ kubectl apply -f deploy/examples/volume-replication.yaml\n</code></pre> <p>Note</p> <p> <code>VolumeReplication</code> is a namespace scoped object. Thus, it should be created in the same namespace as of PVC.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#checking-replication-status","title":"Checking Replication Status","text":"<p><code>replicationState</code> is the state of the volume being referenced. Possible values are primary, secondary, and resync.</p> <ul> <li><code>primary</code> denotes that the volume is primary.</li> <li><code>secondary</code> denotes that the volume is secondary.</li> <li><code>resync</code> denotes that the volume needs to be resynced.</li> </ul> <p>To check VolumeReplication CR status:</p> <pre><code>[cluster-1]$kubectl get volumereplication pvc-volumereplication -oyaml\n</code></pre> <pre><code>...\nspec:\n  dataSource:\n    apiGroup: \"\"\n    kind: PersistentVolumeClaim\n    name: rbd-pvc\n  replicationState: primary\n  volumeReplicationClass: rbd-volumereplicationclass\nstatus:\n  conditions:\n  - lastTransitionTime: \"2021-05-04T07:39:00Z\"\n    message: \"\"\n    observedGeneration: 1\n    reason: Promoted\n    status: \"True\"\n    type: Completed\n  - lastTransitionTime: \"2021-05-04T07:39:00Z\"\n    message: \"\"\n    observedGeneration: 1\n    reason: Healthy\n    status: \"False\"\n    type: Degraded\n  - lastTransitionTime: \"2021-05-04T07:39:00Z\"\n    message: \"\"\n    observedGeneration: 1\n    reason: NotResyncing\n    status: \"False\"\n    type: Resyncing\n  lastCompletionTime: \"2021-05-04T07:39:00Z\"\n  lastStartTime: \"2021-05-04T07:38:59Z\"\n  message: volume is marked primary\n  observedGeneration: 1\n  state: Primary\n</code></pre>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#backup-restore","title":"Backup &amp; Restore","text":"<p>Note</p> <p>To effectively resume operations after a failover/relocation, backup of the kubernetes artifacts like deployment, PVC, PV, etc need to be created beforehand by the admin; so that the application can be restored on the peer cluster.</p> <p>Here, we take a backup of PVC and PV object on one site, so that they can be restored later to the peer cluster.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#take-backup-on-cluster-1","title":"Take backup on cluster-1","text":"<ul> <li>Take backup of the PVC <code>rbd-pvc</code></li> </ul> <pre><code>[cluster-1]$ kubectl  get pvc rbd-pvc -oyaml &gt; pvc-backup.yaml\n</code></pre> <ul> <li>Take a backup of the PV, corresponding to the PVC</li> </ul> <pre><code>[cluster-1]$ kubectl get pv/pvc-65dc0aac-5e15-4474-90f4-7a3532c621ec -oyaml &gt; pv_backup.yaml\n</code></pre> <p>Note</p> <p>We can also take backup using external tools like Velero. See velero documentation for more information.</p>"},{"location":"Storage-Configuration/Block-Storage-RBD/rbd-mirroring/#restore-the-backup-on-cluster-2","title":"Restore the backup on cluster-2","text":"<ul> <li>Create storageclass on the secondary cluster</li> </ul> <pre><code>[cluster-2]$ kubectl create -f deploy/examples/csi/rbd/storageclass.yaml\n</code></pre> <ul> <li>Create VolumeReplicationClass on the secondary cluster</li> </ul> <pre><code>[cluster-1]$ kubectl apply -f deploy/examples/volume-replication-class.yaml\nvolumereplicationclass.replication.storage.openshift.io/rbd-volumereplicationclass created\n</code></pre> <ul> <li>If Persistent Volumes and Claims are created manually on the secondary cluster,     remove the <code>claimRef</code> on the backed up PV objects in yaml files; so that the     PV can get bound to the new claim on the secondary cluster.</li> </ul> <pre><code>...\nspec:\n  accessModes:\n  - ReadWriteOnce\n  capacity:\n    storage: 1Gi\n  claimRef:\n    apiVersion: v1\n    kind: PersistentVolumeClaim\n    name: rbd-pvc\n    namespace: default\n    resourceVersion: \"64252\"\n    uid: 65dc0aac-5e15-4474-90f4-7a3532c621ec\n  csi:\n...\n</code></pre> <ul> <li>Apply the Persistent Volume backup from the primary cluster</li> </ul> <pre><code>[cluster-2]$ kubectl create -f pv-backup.yaml\n</code></pre> <ul> <li>Apply the Persistent Volume claim from the restored backup</li> </ul> <pre><code>[cluster-2]$ kubectl create -f pvc-backup.yaml\n</code></pre> <pre><code>[cluster-2]$ kubectl get pvc\nNAME      STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS      AGE\nrbd-pvc   Bound    pvc-65dc0aac-5e15-4474-90f4-7a3532c621ec   1Gi        RWO            rook-ceph-block   44s\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/","title":"Ceph CSI Drivers","text":"<p>There are three CSI drivers integrated with Rook that are used in different scenarios:</p> <ul> <li>RBD: This block storage driver is optimized for RWO pod access where only one pod may access the     storage. More information.</li> <li>CephFS: This file storage driver allows for RWX with one or more pods accessing the same storage.     More information.</li> <li>NFS (experimental): This file storage driver allows creating NFS exports that can be mounted on     pods, or directly via an NFS client from inside or outside the     Kubernetes cluster. More information</li> </ul> <p>The Ceph Filesystem (CephFS) and RADOS Block Device (RBD) drivers are enabled automatically by the Rook operator. The NFS driver is disabled by default. All drivers will be started in the same namespace as the operator when the first CephCluster CR is created.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#supported-versions","title":"Supported Versions","text":"<p>The two most recent Ceph CSI version are supported with Rook. Refer to ceph csi releases for more information.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#static-provisioning","title":"Static Provisioning","text":"<p>The RBD and CephFS drivers support the creation of static PVs and static PVCs from an existing RBD image or CephFS volume/subvolume. Refer to the static PVC documentation for more information.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#configure-csi-drivers-in-non-default-namespace","title":"Configure CSI Drivers in non-default namespace","text":"<p>If you've deployed the Rook operator in a namespace other than <code>rook-ceph</code>, change the prefix in the provisioner to match the namespace you used. For example, if the Rook operator is running in the namespace <code>my-namespace</code> the provisioner value should be <code>my-namespace.rbd.csi.ceph.com</code>. The same provisioner name must be set in both the storageclass and snapshotclass.</p> <p>To find the provisioner name in the example storageclasses and volumesnapshotclass, search for: <code># csi-provisioner-name</code></p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#configure-custom-driver-name-prefix-for-csi-drivers","title":"Configure custom Driver name prefix for CSI Drivers","text":"<p>To use a custom prefix for the CSI drivers instead of the namespace prefix, set the <code>CSI_DRIVER_NAME_PREFIX</code> environment variable in the operator configmap. For instance, to use the prefix <code>my-prefix</code> for the CSI drivers, set the following in the operator configmap:</p> <pre><code>kubectl patch cm rook-ceph-operator-config -n rook-ceph -p $'data:\\n \"CSI_DRIVER_NAME_PREFIX\": \"my-prefix\"'\n</code></pre> <p>Once the configmap is updated, the CSI drivers will be deployed with the <code>my-prefix</code> prefix. The same prefix must be set in both the storageclass and snapshotclass. For example, to use the prefix <code>my-prefix</code> for the CSI drivers, update the provisioner in the storageclass:</p> <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: rook-ceph-block-sc\nprovisioner: my-prefix.rbd.csi.ceph.com\n...\n</code></pre> <p>The same prefix must be set in the volumesnapshotclass as well:</p> <pre><code>apiVersion: snapshot.storage.k8s.io/v1\nkind: VolumeSnapshotClass\nmetadata:\n  name: rook-ceph-block-vsc\ndriver: my-prefix.rbd.csi.ceph.com\n...\n</code></pre> <p>When the prefix is set, the driver names will be:</p> <ul> <li>RBD: <code>my-prefix.rbd.csi.ceph.com</code></li> <li>CephFS: <code>my-prefix.cephfs.csi.ceph.com</code></li> <li>NFS: <code>my-prefix.nfs.csi.ceph.com</code></li> </ul> <p>Note</p> <p>Please be careful when setting the <code>CSI_DRIVER_NAME_PREFIX</code> environment variable. It should be done only in fresh deployments because changing the prefix in an existing cluster will result in unexpected behavior.</p> <p>To find the provisioner name in the example storageclasses and volumesnapshotclass, search for: <code># csi-provisioner-name</code></p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#liveness-sidecar","title":"Liveness Sidecar","text":"<p>All CSI pods are deployed with a sidecar container that provides a Prometheus metric for tracking whether the CSI plugin is alive and running.</p> <p>Check the monitoring documentation to see how to integrate CSI liveness and GRPC metrics into Ceph monitoring.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#dynamically-expand-volume","title":"Dynamically Expand Volume","text":""},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#prerequisites","title":"Prerequisites","text":"<p>To expand the PVC the controlling StorageClass must have <code>allowVolumeExpansion</code> set to <code>true</code>. <code>csi.storage.k8s.io/controller-expand-secret-name</code> and <code>csi.storage.k8s.io/controller-expand-secret-namespace</code> values set in the storageclass. Now expand the PVC by editing the PVC's <code>pvc.spec.resource.requests.storage</code> to a higher values than the current size. Once the PVC is expanded on the back end and the new size is reflected on the application mountpoint, the status capacity <code>pvc.status.capacity.storage</code> of the PVC will be updated to the new size.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#rbd-mirroring","title":"RBD Mirroring","text":"<p>To support RBD Mirroring, the CSI-Addons sidecar will be started in the RBD provisioner pod. CSI-Addons support the <code>VolumeReplication</code> operation. The volume replication controller provides common and reusable APIs for storage disaster recovery. It is based on the csi-addons specification. It follows the controller pattern and provides extended APIs for storage disaster recovery. The extended APIs are provided via Custom Resource Definitions (CRDs).</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#enable-csiaddons-sidecar","title":"Enable CSIAddons Sidecar","text":"<p>To enable the CSIAddons sidecar and deploy the controller, follow the steps below</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#ephemeral-volume-support","title":"Ephemeral volume support","text":"<p>The generic ephemeral volume feature adds support for specifying PVCs in the <code>volumes</code> field to create a Volume as part of the pod spec. This feature requires the <code>GenericEphemeralVolume</code> feature gate to be enabled.</p> <p>For example:</p> <pre><code>kind: Pod\napiVersion: v1\n...\n  volumes:\n    - name: mypvc\n      ephemeral:\n        volumeClaimTemplate:\n          spec:\n            accessModes: [\"ReadWriteOnce\"]\n            storageClassName: \"rook-ceph-block\"\n            resources:\n              requests:\n                storage: 1Gi\n</code></pre> <p>A volume claim template is defined inside the pod spec, and defines a volume to be provisioned and used by the pod within its lifecycle. Volumes are provisioned when a pod is spawned and destroyed when the pod is deleted.</p> <p>Refer to the ephemeral-doc for more info. See example manifests for an RBD ephemeral volume and a CephFS ephemeral volume.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#csi-addons-controller","title":"CSI-Addons Controller","text":"<p>The CSI-Addons Controller handles requests from users. Users create a CR that the controller inspects and forwards to one or more CSI-Addons sidecars for execution.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#deploying-the-controller","title":"Deploying the controller","text":"<p>Deploy the controller by running the following commands:</p> <pre><code>kubectl create -f https://github.com/csi-addons/kubernetes-csi-addons/releases/download/v0.11.0/crds.yaml\nkubectl create -f https://github.com/csi-addons/kubernetes-csi-addons/releases/download/v0.11.0/rbac.yaml\nkubectl create -f https://github.com/csi-addons/kubernetes-csi-addons/releases/download/v0.11.0/setup-controller.yaml\n</code></pre> <p>This creates the required CRDs and configures permissions.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#enable-the-csi-addons-sidecar","title":"Enable the CSI-Addons Sidecar","text":"<p>To use the features provided by the CSI-Addons, the <code>csi-addons</code> containers need to be deployed in the RBD provisioner and nodeplugin pods, which are not enabled by default.</p> <p>Execute the following to enable the CSI-Addons sidecars:</p> <ul> <li> <p>Update the <code>rook-ceph-operator-config</code> configmap and patch the     following configuration:</p> <pre><code>kubectl patch cm rook-ceph-operator-config -nrook-ceph -p $'data:\\n \"CSI_ENABLE_CSIADDONS\": \"true\"'\n</code></pre> </li> <li> <p>After enabling <code>CSI_ENABLE_CSIADDONS</code> in the configmap, a new sidecar container named <code>csi-addons</code>     will start automatically in the RBD CSI provisioner and nodeplugin pods.</p> </li> </ul>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#csi-addons-operations","title":"CSI-Addons Operations","text":"<p>CSI-Addons supports the following operations:</p> <ul> <li>Reclaim Space<ul> <li>Creating a ReclaimSpaceJob</li> <li>Creating a ReclaimSpaceCronJob</li> <li>Annotating PersistentVolumeClaims</li> <li>Annotating Namespace</li> <li>Annotating StorageClass</li> </ul> </li> <li>Network Fencing<ul> <li>Creating a NetworkFence</li> </ul> </li> <li>Volume Replication<ul> <li>Creating VolumeReplicationClass</li> <li>Creating VolumeReplication CR</li> </ul> </li> <li>Key Rotation Job for PV encryption<ul> <li>Creating EncryptionKeyRotationJob</li> <li>Creating EncryptionKeyRotationCronJob</li> <li>Annotating PersistentVolumeClaims</li> <li>Annotating Namespace</li> <li>Annotating StorageClass</li> </ul> </li> </ul>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#enable-rbd-and-cephfs-encryption-support","title":"Enable RBD and CephFS Encryption Support","text":"<p>Ceph-CSI supports encrypting PersistentVolumeClaims (PVCs) for both RBD and CephFS. This can be achieved using LUKS for RBD and fscrypt for CephFS. More details on encrypting RBD PVCs can be found here, which includes a full list of supported encryption configurations. More details on encrypting CephFS PVCs can be found here. A sample KMS configmap can be found here.</p> <p>Note</p> <p>Not all KMS are compatible with fscrypt. Generally, KMS that either store secrets to use directly (like Vault) or allow access to the plain password (like Kubernetes Secrets) are compatible.</p> <p>Note</p> <p>Rook also supports OSD-level encryption (see <code>encryptedDevice</code> option here).</p> <p>Using both RBD PVC encryption and OSD encryption at the same time will lead to double encryption and may reduce read/write performance.</p> <p>Existing Ceph clusters can also enable Ceph-CSI PVC encryption support and multiple kinds of encryption KMS can be used on the same Ceph cluster using different storageclasses.</p> <p>The following steps demonstrate the common process for enabling encryption support for both RBD and CephFS:</p> <ul> <li>Create the <code>rook-ceph-csi-kms-config</code> configmap with required encryption configuration in the same namespace where the Rook operator is deployed. An example is shown below:</li> </ul> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: rook-ceph-csi-kms-config\n  namespace: rook-ceph\ndata:\n  config.json: |-\n    {\n      \"user-secret-metadata\": {\n        \"encryptionKMSType\": \"metadata\",\n        \"secretName\": \"storage-encryption-secret\"\n      }\n    }\n</code></pre> <ul> <li>Update the <code>rook-ceph-operator-config</code> configmap and patch the     following configurations</li> </ul> <pre><code>kubectl patch cm rook-ceph-operator-config -nrook-ceph -p $'data:\\n \"CSI_ENABLE_ENCRYPTION\": \"true\"'\n</code></pre> <ul> <li>Create the resources (secrets, configmaps etc) required by the encryption type. In this case, create <code>storage-encryption-secret</code> secret in the namespace of the PVC as follows:</li> </ul> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: storage-encryption-secret\n  namespace: rook-ceph\nstringData:\n  encryptionPassphrase: test-encryption\n</code></pre> <ul> <li>Create a new RBD storageclass or CephFS storageclass with additional parameters <code>encrypted: \"true\"</code> and <code>encryptionKMSID: \"&lt;key used in configmap&gt;\"</code>. An example is shown below:</li> </ul> <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: rook-ceph-block-encrypted\nparameters:\n  # additional parameters required for encryption\n  encrypted: \"true\"\n  encryptionKMSID: \"user-secret-metadata\"\n# ...\n</code></pre> <ul> <li>PVCs created using the new storageclass will be encrypted.</li> </ul> <p>Note</p> <p>CephFS encryption requires fscrypt support in Linux kernel, kernel version 6.6 or higher.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-drivers/#enable-read-affinity-for-rbd-and-cephfs-volumes","title":"Enable Read affinity for RBD and CephFS volumes","text":"<p>Ceph CSI supports mapping RBD volumes with KRBD options and mounting CephFS volumes with ceph mount options to allow serving reads from an OSD closest to the client, according to OSD locations defined in the CRUSH map and topology labels on nodes.</p> <p>Refer to the krbd-options document for more details.</p> <p>Execute the following step to enable read affinity for a specific ceph cluster:</p> <ul> <li>Patch the ceph cluster CR to enable read affinity:</li> </ul> <pre><code>kubectl patch cephclusters.ceph.rook.io &lt;cluster-name&gt; -n rook-ceph -p '{\"spec\":{\"csi\":{\"readAffinity\":{\"enabled\": true}}}}'\n</code></pre> <pre><code>  csi:\n    readAffinity:\n      enabled: true\n</code></pre> <ul> <li>Add topology labels to the Kubernetes nodes. The same labels may be used as mentioned in the OSD topology topic.</li> </ul> <p>Ceph CSI will extract the CRUSH location from the topology labels found on the node and pass it though krbd options during mapping RBD volumes.</p> <p>Note</p> <p>This requires Linux kernel version 5.8 or higher.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/","title":"Snapshots","text":""},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Install the snapshot controller and snapshot v1 CRD.</p> </li> <li> <p>We also need a <code>VolumeSnapshotClass</code> for volume snapshot to work. The purpose of a <code>VolumeSnapshotClass</code> is defined in the kubernetes documentation. In short, as the documentation describes it:</p> </li> </ul> <p>Info</p> <p>Just like StorageClass provides a way for administrators to describe the \"classes\" of storage they offer when provisioning a volume, VolumeSnapshotClass provides a way to describe the \"classes\" of storage when provisioning a volume snapshot.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#rbd-snapshots","title":"RBD Snapshots","text":""},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#rbd-volumesnapshotclass","title":"RBD VolumeSnapshotClass","text":"<p>In VolumeSnapshotClass, the <code>csi.storage.k8s.io/snapshotter-secret-name</code> parameter should reference the name of the secret created for the rbdplugin and <code>pool</code> to reflect the Ceph pool name.</p> <p>Update the value of the <code>clusterID</code> field to match the namespace that Rook is running in. When Ceph CSI is deployed by Rook, the operator will automatically maintain a configmap whose contents will match this key. By default this is \"rook-ceph\".</p> <pre><code>kubectl create -f deploy/examples/csi/rbd/snapshotclass.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#volumesnapshot","title":"Volumesnapshot","text":"<p>In snapshot, <code>volumeSnapshotClassName</code> should be the name of the <code>VolumeSnapshotClass</code> previously created. The <code>persistentVolumeClaimName</code> should be the name of the PVC which is already created by the RBD CSI driver.</p> <pre><code>kubectl create -f deploy/examples/csi/rbd/snapshot.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#verify-rbd-snapshot-creation","title":"Verify RBD Snapshot Creation","text":"<pre><code>$ kubectl get volumesnapshotclass\nNAME                      DRIVER                       DELETIONPOLICY   AGE\ncsi-rbdplugin-snapclass   rook-ceph.rbd.csi.ceph.com   Delete           3h55m\n</code></pre> <pre><code>$ kubectl get volumesnapshot\nNAME               READYTOUSE   SOURCEPVC   SOURCESNAPSHOTCONTENT   RESTORESIZE   SNAPSHOTCLASS             SNAPSHOTCONTENT                                    CREATIONTIME   AGE\nrbd-pvc-snapshot   true         rbd-pvc                             1Gi           csi-rbdplugin-snapclass   snapcontent-79090db0-7c66-4b18-bf4a-634772c7cac7   3h50m          3h51m\n</code></pre> <p>The snapshot will be ready to restore to a new PVC when the <code>READYTOUSE</code> field of the <code>volumesnapshot</code> is set to true.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#restore-the-rbd-snapshot-to-a-new-pvc","title":"Restore the RBD snapshot to a new PVC","text":"<p>In pvc-restore, <code>dataSource</code> should be the name of the <code>VolumeSnapshot</code> previously created. The <code>dataSource</code> kind should be the <code>VolumeSnapshot</code>. The <code>storageClassName</code> can be any RBD storageclass.</p> <p>Please Note:     * <code>provisioner</code> must be the same for both the Parent PVC and the restored PVC.     * The non-encrypted PVC cannot be restored to an encrypted one and vice-versa.         * encrypted -&gt; encrypted (possible)         * non-encrypted -&gt; non-encrypted (possible)         * encrypted -&gt; non-encrypted (not possible)         * non-encrypted -&gt; encrypted (not possible)</p> <p>Create a new PVC from the snapshot</p> <pre><code>kubectl create -f deploy/examples/csi/rbd/pvc-restore.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#verify-rbd-clone-pvc-creation","title":"Verify RBD Clone PVC Creation","text":"<pre><code>$ kubectl get pvc\nNAME              STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS          AGE\nrbd-pvc           Bound    pvc-84294e34-577a-11e9-b34f-525400581048   1Gi        RWO            rook-ceph-block       34m\nrbd-pvc-restore   Bound    pvc-575537bf-577f-11e9-b34f-525400581048   1Gi        RWO            rook-ceph-block       8s\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#rbd-snapshot-resource-cleanup","title":"RBD snapshot resource Cleanup","text":"<p>To clean your cluster of the resources created by this example, run the following:</p> <pre><code>kubectl delete -f deploy/examples/csi/rbd/pvc-restore.yaml\nkubectl delete -f deploy/examples/csi/rbd/snapshot.yaml\nkubectl delete -f deploy/examples/csi/rbd/snapshotclass.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#cephfs-snapshots","title":"CephFS Snapshots","text":""},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#cephfs-volumesnapshotclass","title":"CephFS VolumeSnapshotClass","text":"<p>In VolumeSnapshotClass, the <code>csi.storage.k8s.io/snapshotter-secret-name</code> parameter should reference the name of the secret created for the cephfsplugin.</p> <p>In the volumesnapshotclass, update the value of the <code>clusterID</code> field to match the namespace that Rook is running in. When Ceph CSI is deployed by Rook, the operator will automatically maintain a configmap whose contents will match this key. By default this is \"rook-ceph\".</p> <pre><code>kubectl create -f deploy/examples/csi/cephfs/snapshotclass.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#volumesnapshot_1","title":"VolumeSnapshot","text":"<p>In snapshot, <code>volumeSnapshotClassName</code> should be the name of the <code>VolumeSnapshotClass</code> previously created. The <code>persistentVolumeClaimName</code> should be the name of the PVC which is already created by the CephFS CSI driver.</p> <pre><code>kubectl create -f deploy/examples/csi/cephfs/snapshot.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#verify-cephfs-snapshot-creation","title":"Verify CephFS Snapshot Creation","text":"<pre><code>$ kubectl get volumesnapshotclass\nNAME                        DRIVER                          DELETIONPOLICY   AGE\ncsi-cephfslugin-snapclass   rook-ceph.cephfs.csi.ceph.com   Delete           3h55m\n</code></pre> <pre><code>$ kubectl get volumesnapshot\nNAME                  READYTOUSE   SOURCEPVC   SOURCESNAPSHOTCONTENT  RESTORESIZE   SNAPSHOTCLASS                SNAPSHOTCONTENT                                   CREATIONTIME   AGE\ncephfs-pvc-snapshot   true         cephfs-pvc                         1Gi           csi-cephfsplugin-snapclass   snapcontent-34476204-a14a-4d59-bfbc-2bbba695652c  3h50m          3h51m\n</code></pre> <p>The snapshot will be ready to restore to a new PVC when <code>READYTOUSE</code> field of the <code>volumesnapshot</code> is set to true.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#restore-the-cephfs-snapshot-to-a-new-pvc","title":"Restore the CephFS snapshot to a new PVC","text":"<p>In pvc-restore, <code>dataSource</code> should be the name of the <code>VolumeSnapshot</code> previously created. The <code>dataSource</code> kind should be the <code>VolumeSnapshot</code>.</p> <p>Create a new PVC from the snapshot</p> <pre><code>kubectl create -f deploy/examples/csi/cephfs/pvc-restore.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#verify-cephfs-restore-pvc-creation","title":"Verify CephFS Restore PVC Creation","text":"<pre><code>$ kubectl get pvc\nNAME                 STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS      AGE\ncephfs-pvc           Bound    pvc-74734901-577a-11e9-b34f-525400581048   1Gi        RWX            rook-cephfs       55m\ncephfs-pvc-restore   Bound    pvc-95308c75-6c93-4928-a551-6b5137192209   1Gi        RWX            rook-cephfs       34s\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-snapshot/#cephfs-snapshot-resource-cleanup","title":"CephFS snapshot resource Cleanup","text":"<p>To clean your cluster of the resources created by this example, run the following:</p> <pre><code>kubectl delete -f deploy/examples/csi/cephfs/pvc-restore.yaml\nkubectl delete -f deploy/examples/csi/cephfs/snapshot.yaml\nkubectl delete -f deploy/examples/csi/cephfs/snapshotclass.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-clone/","title":"Volume clone","text":"<p>The CSI Volume Cloning feature adds support for specifying existing PVCs in the <code>dataSource</code> field to indicate a user would like to clone a Volume.</p> <p>A Clone is defined as a duplicate of an existing Kubernetes Volume that can be consumed as any standard Volume would be. The only difference is that upon provisioning, rather than creating a \"new\" empty Volume, the back end device creates an exact duplicate of the specified Volume.</p> <p>Refer to clone-doc for more info.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-clone/#rbd-volume-cloning","title":"RBD Volume Cloning","text":"<p>In pvc-clone, <code>dataSource</code> should be the name of the <code>PVC</code> which is already created by RBD CSI driver. The <code>dataSource</code> kind should be the <code>PersistentVolumeClaim</code>. The <code>storageClassName</code> can be any RBD storageclass (not necessarily same as Parent PVC)</p> <p>Please note:     * <code>provisioner</code> must be the same for both the Parent PVC and the Clone PVC.     * The non-encrypted PVC cannot be cloned to an encrypted one and vice-versa.         * encrypted -&gt; encrypted (possible)         * non-encrypted -&gt; non-encrypted (possible)         * encrypted -&gt; non-encrypted (not possible)         * non-encrypted -&gt; encrypted (not possible)</p> <p>Create a new PVC Clone from the PVC</p> <pre><code>kubectl create -f deploy/examples/csi/rbd/pvc-clone.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-clone/#verify-rbd-volume-clone-pvc-creation","title":"Verify RBD volume Clone PVC Creation","text":"<pre><code>kubectl get pvc\n</code></pre> <pre><code>NAME              STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS          AGE\nrbd-pvc           Bound    pvc-74734901-577a-11e9-b34f-525400581048   1Gi        RWO            rook-ceph-block       34m\nrbd-pvc-clone     Bound    pvc-70473135-577f-11e9-b34f-525400581048   1Gi        RWO            rook-ceph-block       8s\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-clone/#rbd-clone-resource-cleanup","title":"RBD clone resource Cleanup","text":"<p>To clean your cluster of the resources created by this example, run the following:</p> <pre><code>kubectl delete -f deploy/examples/csi/rbd/pvc-clone.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-clone/#cephfs-volume-cloning","title":"CephFS Volume Cloning","text":""},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-clone/#volume-clone-prerequisites","title":"Volume Clone Prerequisites","text":"<ol> <li>Requires Kubernetes v1.16+ which supports volume clone.</li> <li>Ceph-csi diver v3.1.0+ which supports volume clone.</li> </ol> <p>In pvc-clone, <code>dataSource</code> should be the name of the <code>PVC</code> which is already created by CephFS CSI driver. The <code>dataSource</code> kind should be the <code>PersistentVolumeClaim</code> and also storageclass should be same as the source <code>PVC</code>.</p> <p>Create a new PVC Clone from the PVC</p> <pre><code>kubectl create -f deploy/examples/csi/cephfs/pvc-clone.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-clone/#verify-cephfs-volume-clone-pvc-creation","title":"Verify CephFS volume Clone PVC Creation","text":"<pre><code>kubectl get pvc\n</code></pre> <pre><code>NAME              STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE\ncephfs-pvc        Bound    pvc-1ea51547-a88b-4ab0-8b4a-812caeaf025d   1Gi        RWX            rook-cephfs    39m\ncephfs-pvc-clone  Bound    pvc-b575bc35-d521-4c41-b4f9-1d733cd28fdf   1Gi        RWX            rook-cephfs    8s\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-clone/#cephfs-clone-resource-cleanup","title":"CephFS clone resource Cleanup","text":"<p>To clean your cluster of the resources created by this example, run the following:</p> <pre><code>kubectl delete -f deploy/examples/csi/cephfs/pvc-clone.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-group-snapshot/","title":"Volume Group Snapshots","text":"<p>Ceph provides the ability to create crash-consistent snapshots of multiple volumes. A group snapshot represents \u201ccopies\u201d from multiple volumes that are taken at the same point in time. A group snapshot can be used either to rehydrate new volumes (pre-populated with the snapshot data) or to restore existing volumes to a previous state (represented by the snapshots)</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-group-snapshot/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Install the snapshot controller, volume group snapshot and snapshot CRDs, refer to VolumeGroupSnapshot documentation here for more details.</p> </li> <li> <p>A <code>VolumeGroupSnapshotClass</code> is needed for the volume group snapshot to work. The purpose of a <code>VolumeGroupSnapshotClass</code> is defined in the kubernetes documentation. In short, as the documentation describes it:</p> </li> </ul> <p>Info</p> <p>Created by cluster administrators to describe how volume group snapshots should be created. including the driver information, the deletion policy, etc.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-group-snapshot/#volume-group-snapshots","title":"Volume Group Snapshots","text":""},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-group-snapshot/#cephfs-volumegroupsnapshotclass","title":"CephFS VolumeGroupSnapshotClass","text":"<p>In VolumeGroupSnapshotClass, the <code>csi.storage.k8s.io/group-snapshotter-secret-name</code> parameter should reference the name of the secret created for the cephfs-plugin.</p> <p>In the <code>VolumeGroupSnapshotClass</code>, update the value of the <code>clusterID</code> field to match the namespace that Rook is running in. When Ceph CSI is deployed by Rook, the operator will automatically maintain a configmap whose contents will match this key. By default this is \"rook-ceph\".</p> <pre><code>kubectl create -f deploy/examples/csi/cephfs/groupsnapshotclass.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-group-snapshot/#cephfs-volumegroupsnapshot","title":"CephFS VolumeGroupSnapshot","text":"<p>In VolumeGroupSnapshot, <code>volumeGroupSnapshotClassName</code> should be the name of the <code>VolumeGroupSnapshotClass</code> previously created. The labels inside <code>matchLabels</code> should be present on the PVCs that are already created by the CephFS CSI driver.</p> <pre><code>kubectl create -f deploy/examples/csi/cephfs/groupsnapshot.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-group-snapshot/#verify-cephfs-groupsnapshot-creation","title":"Verify CephFS GroupSnapshot Creation","text":"<pre><code>$ kubectl get volumegroupsnapshotclass\nNAME                              DRIVER                          DELETIONPOLICY   AGE\ncsi-cephfsplugin-groupsnapclass   rook-ceph.cephfs.csi.ceph.com   Delete           21m\n</code></pre> <pre><code>$ kubectl get volumegroupsnapshot\nNAME                       READYTOUSE   VOLUMEGROUPSNAPSHOTCLASS          VOLUMEGROUPSNAPSHOTCONTENT                              CREATIONTIME   AGE\ncephfs-groupsnapshot       true         csi-cephfsplugin-groupsnapclass   groupsnapcontent-d13f4d95-8822-4729-9586-4f222a3f788e   5m37s          5m39s\n</code></pre> <p>The snapshot will be ready to restore to a new PVC when <code>READYTOUSE</code> field of the <code>volumegroupsnapshot</code> is set to true.</p>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-group-snapshot/#restore-the-cephfs-volume-group-snapshot-to-a-new-pvc","title":"Restore the CephFS volume group snapshot to a new PVC","text":"<p>Find the name of the snapshots created by the <code>VolumeGroupSnapshot</code> first by running:</p> <pre><code>$ kubectl get volumegroupsnapshot/cephfs-groupsnapshot -o=jsonpath='{range .status.pvcVolumeSnapshotRefList[*]}PVC: {.persistentVolumeClaimRef.name}, Snapshot: {.volumeSnapshotRef.name}{\"\\n\"}{end}'\nPVC: cephfs-pvc, Snapshot: snapshot-9d21b143904c10f49ddc92664a7e8fe93c23387d0a88549c14337484ebaf1011-2024-09-12-3.49.13\n</code></pre> <p>It will list the PVC's name followed by its snapshot name.</p> <p>In pvc-restore, <code>dataSource</code> should be one of the <code>Snapshot</code> that we just found. The <code>dataSource</code> kind should be the <code>VolumeSnapshot</code>.</p> <p>Create a new PVC from the snapshot</p> <pre><code>kubectl create -f deploy/examples/csi/cephfs/pvc-restore.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-group-snapshot/#verify-cephfs-restore-pvc-creation","title":"Verify CephFS Restore PVC Creation","text":"<pre><code>$ kubectl get pvc\ncephfs-pvc           Bound    pvc-9ae60bf9-4931-4f9a-9de1-7f45f31fe4da   1Gi        RWO            rook-cephfs    &lt;unset&gt;                 171m\ncephfs-pvc-restore   Bound    pvc-b4b73cbb-5061-48c7-9ac8-e1202508cf97   1Gi        RWO            rook-cephfs    &lt;unset&gt;                 46s\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/ceph-csi-volume-group-snapshot/#cephfs-volume-group-snapshot-resource-cleanup","title":"CephFS volume group snapshot resource Cleanup","text":"<p>To clean the resources created by this example, run the following:</p> <pre><code>kubectl delete -f deploy/examples/csi/cephfs/pvc-restore.yaml\nkubectl delete -f deploy/examples/csi/cephfs/groupsnapshot.yaml\nkubectl delete -f deploy/examples/csi/cephfs/groupsnapshotclass.yaml\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/custom-images/","title":"Custom Images","text":"<p>By default, Rook will deploy the latest stable version of the Ceph CSI driver. Commonly, there is no need to change this default version that is deployed. For scenarios that require deploying a custom image (e.g. downstream releases), the defaults can be overridden with the following settings.</p> <p>The CSI configuration variables are found in the <code>rook-ceph-operator-config</code> ConfigMap. These settings can also be specified as environment variables on the operator deployment, though the configmap values will override the env vars if both are specified.</p> <pre><code>kubectl -n $ROOK_OPERATOR_NAMESPACE edit configmap rook-ceph-operator-config\n</code></pre> <p>The default upstream images are included below, which you can change to your desired images.</p> <pre><code>ROOK_CSI_CEPH_IMAGE: \"quay.io/cephcsi/cephcsi:v3.12.3\"\nROOK_CSI_REGISTRAR_IMAGE: \"registry.k8s.io/sig-storage/csi-node-driver-registrar:v2.11.1\"\nROOK_CSI_PROVISIONER_IMAGE: \"registry.k8s.io/sig-storage/csi-provisioner:v5.0.1\"\nROOK_CSI_ATTACHER_IMAGE: \"registry.k8s.io/sig-storage/csi-attacher:v4.6.1\"\nROOK_CSI_RESIZER_IMAGE: \"registry.k8s.io/sig-storage/csi-resizer:v1.11.1\"\nROOK_CSI_SNAPSHOTTER_IMAGE: \"registry.k8s.io/sig-storage/csi-snapshotter:v8.0.1\"\nROOK_CSIADDONS_IMAGE: \"quay.io/csiaddons/k8s-sidecar:v0.11.0\"\n</code></pre>"},{"location":"Storage-Configuration/Ceph-CSI/custom-images/#use-private-repository","title":"Use private repository","text":"<p>If image version is not passed along with the image name in any of the variables above, Rook will add the corresponding default version to that image. Example: if <code>ROOK_CSI_CEPH_IMAGE: \"quay.io/private-repo/cephcsi\"</code> is passed, Rook will add internal default version and consume it as <code>\"quay.io/private-repo/cephcsi:v3.12.0\"</code>.</p>"},{"location":"Storage-Configuration/Ceph-CSI/custom-images/#use-default-images","title":"Use default images","text":"<p>If you would like Rook to use the default upstream images, then you may simply remove all variables matching <code>ROOK_CSI_*_IMAGE</code> from the above ConfigMap and/or the operator deployment.</p>"},{"location":"Storage-Configuration/Ceph-CSI/custom-images/#verifying-updates","title":"Verifying updates","text":"<p>You can use the below command to see the CSI images currently being used in the cluster. Note that not all images (like <code>volumereplication-operator</code>) may be present in every cluster depending on which CSI features are enabled.</p> <pre><code>kubectl --namespace rook-ceph get pod -o jsonpath='{range .items[*]}{range .spec.containers[*]}{.image}{\"\\n\"}' -l 'app in (csi-rbdplugin,csi-rbdplugin-provisioner,csi-cephfsplugin,csi-cephfsplugin-provisioner)' | sort | uniq\n</code></pre> <p>The default images can also be found with each release in the images list</p>"},{"location":"Storage-Configuration/Monitoring/ceph-dashboard/","title":"Ceph Dashboard","text":"<p>The dashboard is a very helpful tool to give you an overview of the status of your Ceph cluster, including overall health, status of the mon quorum, status of the mgr, osd, and other Ceph daemons, view pools and PG status, show logs for the daemons, and more. Rook makes it simple to enable the dashboard.</p> <p></p>"},{"location":"Storage-Configuration/Monitoring/ceph-dashboard/#enable-the-ceph-dashboard","title":"Enable the Ceph Dashboard","text":"<p>The dashboard can be enabled with settings in the CephCluster CRD. The CephCluster CRD must have the dashboard <code>enabled</code> setting set to <code>true</code>. This is the default setting in the example manifests.</p> <pre><code>[...]\nspec:\n  dashboard:\n    enabled: true\n</code></pre> <p>The Rook operator will enable the ceph-mgr dashboard module. A service object will be created to expose that port inside the Kubernetes cluster. Rook will enable port 8443 for https access.</p> <p>This example shows that port 8443 was configured.</p> <pre><code>$ kubectl -n rook-ceph get service\nNAME                         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE\nrook-ceph-mgr                ClusterIP   10.108.111.192   &lt;none&gt;        9283/TCP         3h\nrook-ceph-mgr-dashboard      ClusterIP   10.110.113.240   &lt;none&gt;        8443/TCP         3h\n</code></pre> <p>The first service is for reporting the Prometheus metrics, while the latter service is for the dashboard. If you are on a node in the cluster, you will be able to connect to the dashboard by using either the DNS name of the service at <code>https://rook-ceph-mgr-dashboard-https:8443</code> or by connecting to the cluster IP, in this example at <code>https://10.110.113.240:8443</code>.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-dashboard/#login-credentials","title":"Login Credentials","text":"<p>After you connect to the dashboard you will need to login for secure access. Rook creates a default user named <code>admin</code> and generates a secret called <code>rook-ceph-dashboard-password</code> in the namespace where the Rook Ceph cluster is running. To retrieve the generated password, you can run the following:</p> <pre><code>kubectl -n rook-ceph get secret rook-ceph-dashboard-password -o jsonpath=\"{['data']['password']}\" | base64 --decode &amp;&amp; echo\n</code></pre>"},{"location":"Storage-Configuration/Monitoring/ceph-dashboard/#configure-the-dashboard","title":"Configure the Dashboard","text":"<p>The following dashboard configuration settings are supported:</p> <pre><code>spec:\n  dashboard:\n    urlPrefix: /ceph-dashboard\n    port: 8443\n    ssl: true\n</code></pre> <ul> <li><code>urlPrefix</code> If you are accessing the dashboard via a reverse proxy, you may     wish to serve it under a URL prefix.  To get the dashboard to use hyperlinks     that include your prefix, you can set the <code>urlPrefix</code> setting.</li> <li><code>port</code> The port that the dashboard is served on may be changed from the     default using the <code>port</code> setting. The corresponding K8s service exposing the     port will automatically be updated.</li> <li><code>ssl</code> The dashboard may be served without SSL (useful for when you deploy the     dashboard behind a proxy already served using SSL) by setting the <code>ssl</code> option     to be false.</li> </ul>"},{"location":"Storage-Configuration/Monitoring/ceph-dashboard/#visualization-of-physical-disks-section-in-the-dashboard","title":"Visualization of 'Physical Disks' section in the dashboard","text":"<p>Information about physical disks is available only in Rook host clusters.</p> <p>The Rook manager module is required by the dashboard to obtain the information about physical disks, but it is disabled by default. Before it is enabled, the dashboard 'Physical Disks' section will show an error message.</p> <p>To prepare the Rook manager module to be used in the dashboard, modify your Ceph Cluster CRD:</p> <pre><code>  mgr:\n    modules:\n      - name: rook\n        enabled: true\n</code></pre> <p>And apply the changes:</p> <pre><code>$ kubectl apply -f cluster.yaml\n</code></pre> <p>Once the Rook manager module is enabled as the orchestrator backend, there are two settings required for showing disk information:</p> <ul> <li><code>ROOK_ENABLE_DISCOVERY_DAEMON</code>: Set to <code>true</code> to provide the dashboard the information about physical disks. The default is <code>false</code>.</li> <li><code>ROOK_DISCOVER_DEVICES_INTERVAL</code>: The interval for changes to be refreshed in the set of physical disks in the cluster. The default is <code>60</code> minutes.</li> </ul> <p>Modify the operator.yaml, and apply the changes:</p> <pre><code>$ kubectl apply -f operator.yaml\n</code></pre>"},{"location":"Storage-Configuration/Monitoring/ceph-dashboard/#viewing-the-dashboard-external-to-the-cluster","title":"Viewing the Dashboard External to the Cluster","text":"<p>Commonly you will want to view the dashboard from outside the cluster. For example, on a development machine with the cluster running inside minikube you will want to access the dashboard from the host.</p> <p>There are several ways to expose a service that will depend on the environment you are running in. You can use an Ingress Controller or other methods for exposing services such as NodePort, LoadBalancer, or ExternalIPs.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-dashboard/#node-port","title":"Node Port","text":"<p>The simplest way to expose the service in minikube or similar environment is using the NodePort to open a port on the VM that can be accessed by the host. To create a service with the NodePort, save this yaml as <code>dashboard-external-https.yaml</code>.</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: rook-ceph-mgr-dashboard-external-https\n  namespace: rook-ceph\n  labels:\n    app: rook-ceph-mgr\n    rook_cluster: rook-ceph\nspec:\n  ports:\n  - name: dashboard\n    port: 8443\n    protocol: TCP\n    targetPort: 8443\n  selector:\n    app: rook-ceph-mgr\n    rook_cluster: rook-ceph\n    mgr_role: active\n  sessionAffinity: None\n  type: NodePort\n</code></pre> <p>Now create the service:</p> <pre><code>kubectl create -f dashboard-external-https.yaml\n</code></pre> <p>You will see the new service <code>rook-ceph-mgr-dashboard-external-https</code> created:</p> <pre><code>$ kubectl -n rook-ceph get service\nNAME                                    TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE\nrook-ceph-mgr                           ClusterIP   10.108.111.192   &lt;none&gt;        9283/TCP         4h\nrook-ceph-mgr-dashboard                 ClusterIP   10.110.113.240   &lt;none&gt;        8443/TCP         4h\nrook-ceph-mgr-dashboard-external-https  NodePort    10.101.209.6     &lt;none&gt;        8443:31176/TCP   4h\n</code></pre> <p>In this example, port <code>31176</code> will be opened to expose port <code>8443</code> from the ceph-mgr pod. Find the ip address of the VM. If using minikube, you can run <code>minikube ip</code> to find the ip address. Now you can enter the URL in your browser such as <code>https://192.168.99.110:31176</code> and the dashboard will appear.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-dashboard/#load-balancer","title":"Load Balancer","text":"<p>If you have a cluster on a cloud provider that supports load balancers, you can create a service that is provisioned with a public hostname. The yaml is the same as <code>dashboard-external-https.yaml</code> except for the following property:</p> <pre><code>spec:\n[...]\n  type: LoadBalancer\n</code></pre> <p>Now create the service:</p> <pre><code>kubectl create -f dashboard-loadbalancer.yaml\n</code></pre> <p>You will see the new service <code>rook-ceph-mgr-dashboard-loadbalancer</code> created:</p> <pre><code>$ kubectl -n rook-ceph get service\nNAME                                     TYPE           CLUSTER-IP       EXTERNAL-IP                                                               PORT(S)             AGE\nrook-ceph-mgr                            ClusterIP      172.30.11.40     &lt;none&gt;                                                                    9283/TCP            4h\nrook-ceph-mgr-dashboard                  ClusterIP      172.30.203.185   &lt;none&gt;                                                                    8443/TCP            4h\nrook-ceph-mgr-dashboard-loadbalancer     LoadBalancer   172.30.27.242    a7f23e8e2839511e9b7a5122b08f2038-1251669398.us-east-1.elb.amazonaws.com   8443:32747/TCP      4h\n</code></pre> <p>Now you can enter the URL in your browser such as <code>https://a7f23e8e2839511e9b7a5122b08f2038-1251669398.us-east-1.elb.amazonaws.com:8443</code> and the dashboard will appear.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-dashboard/#ingress-controller","title":"Ingress Controller","text":"<p>If you have a cluster with an nginx Ingress Controller and a Certificate Manager (e.g. cert-manager) then you can create an Ingress like the one below. This example achieves four things:</p> <ol> <li>Exposes the dashboard on the Internet (using a reverse proxy)</li> <li>Issues a valid TLS Certificate for the specified domain name (using ACME)</li> <li>Tells the reverse proxy that the dashboard itself uses HTTPS</li> <li>Tells the reverse proxy that the dashboard itself does not have a valid certificate (it is self-signed)</li> </ol> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: rook-ceph-mgr-dashboard\n  namespace: rook-ceph\n  annotations:\n    kubernetes.io/tls-acme: \"true\"\n    nginx.ingress.kubernetes.io/backend-protocol: \"HTTPS\"\n    nginx.ingress.kubernetes.io/server-snippet: |\n      proxy_ssl_verify off;\nspec:\n  ingressClassName: \"nginx\"\n  tls:\n   - hosts:\n     - rook-ceph.example.com\n     secretName: rook-ceph.example.com\n  rules:\n  - host: rook-ceph.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: rook-ceph-mgr-dashboard\n            port:\n              name: https-dashboard\n</code></pre> <p>Customise the Ingress resource to match your cluster. Replace the example domain name <code>rook-ceph.example.com</code> with a domain name that will resolve to your Ingress Controller (creating the DNS entry if required).</p> <p>Now create the Ingress:</p> <pre><code>kubectl create -f dashboard-ingress-https.yaml\n</code></pre> <p>You will see the new Ingress <code>rook-ceph-mgr-dashboard</code> created:</p> <pre><code>$ kubectl -n rook-ceph get ingress\nNAME                      HOSTS                      ADDRESS   PORTS     AGE\nrook-ceph-mgr-dashboard   rook-ceph.example.com      80, 443   5m\n</code></pre> <p>And the new Secret for the TLS certificate:</p> <pre><code>kubectl -n rook-ceph get secret rook-ceph.example.com\nNAME                       TYPE                DATA      AGE\nrook-ceph.example.com      kubernetes.io/tls   2         4m\n</code></pre> <p>You can now browse to <code>https://rook-ceph.example.com/</code> to log into the dashboard.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/","title":"Prometheus Monitoring","text":"<p>Each Rook Ceph cluster has some built in metrics collectors/exporters for monitoring with Prometheus.</p> <p>If you do not have Prometheus running, follow the steps below to enable monitoring of Rook. If your cluster already contains a Prometheus instance, it will automatically discover Rook's scrape endpoint using the standard <code>prometheus.io/scrape</code> and <code>prometheus.io/port</code> annotations.</p> <p>Attention</p> <p>This assumes that the Prometheus instances is searching all your Kubernetes namespaces for Pods with these annotations. If prometheus is already installed in a cluster, it may not be configured to watch for third-party service monitors such as for Rook. Normally you should be able to add the prometheus annotations <code>prometheus.io/scrape=true</code> and <code>prometheus.io/port={port}</code> and prometheus would automatically configure the scrape points and start gathering metrics. If prometheus isn't configured to do this, see the prometheus operator docs.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#prometheus-operator","title":"Prometheus Operator","text":"<p>First the Prometheus operator needs to be started in the cluster so it can watch for our requests to start monitoring Rook and respond by deploying the correct Prometheus pods and configuration. A full explanation can be found in the Prometheus operator repository on GitHub, but the quick instructions can be found here:</p> <pre><code>kubectl create -f https://raw.githubusercontent.com/coreos/prometheus-operator/v0.71.1/bundle.yaml\n</code></pre> <p>Note</p> <p>If the Prometheus Operator is already present in your cluster, the command provided above may fail. For a detailed explanation of the issue and a workaround, please refer to this issue.</p> <p>This will start the Prometheus operator, but before moving on, wait until the operator is in the <code>Running</code> state:</p> <pre><code>kubectl get pod\n</code></pre> <p>Once the Prometheus operator is in the <code>Running</code> state, proceed to the next section to create a Prometheus instance.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#prometheus-instances","title":"Prometheus Instances","text":"<p>With the Prometheus operator running, we can create service monitors that will watch the Rook cluster.</p> <p>There are two sources for metrics collection:</p> <ul> <li>Prometheus manager module: It is responsible for exposing all metrics other than ceph daemons performance counters.</li> <li>Ceph exporter: It is responsible for exposing only ceph daemons performance counters as prometheus metrics.</li> </ul> <p>From the root of your locally cloned Rook repo, go the monitoring directory:</p> <pre><code>$ git clone --single-branch --branch master https://github.com/rook/rook.git\ncd rook/deploy/examples/monitoring\n</code></pre> <p>Create the service monitor as well as the Prometheus server pod and service:</p> <pre><code>kubectl create -f service-monitor.yaml\nkubectl create -f exporter-service-monitor.yaml\nkubectl create -f prometheus.yaml\nkubectl create -f prometheus-service.yaml\n</code></pre> <p>Ensure that the Prometheus server pod gets created and advances to the <code>Running</code> state before moving on:</p> <pre><code>kubectl -n rook-ceph get pod prometheus-rook-prometheus-0\n</code></pre>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#dashboard-config","title":"Dashboard config","text":"<p>Configure the Prometheus endpoint so the dashboard can retrieve metrics from Prometheus with two settings:</p> <ul> <li><code>prometheusEndpoint</code>: The url of the Prometheus instance</li> <li><code>prometheusEndpointSSLVerify</code>: Whether SSL should be verified if the Prometheus server is using https</li> </ul> <p>The following command can be used to get the Prometheus url:</p> <pre><code>echo \"http://$(kubectl -n rook-ceph -o jsonpath={.status.hostIP} get pod prometheus-rook-prometheus-0):30900\"\n</code></pre> <p>Following is an example to configure the Prometheus endpoint in the CephCluster CR.</p> <pre><code>spec:\n    dashboard:\n    prometheusEndpoint: http://192.168.61.204:30900\n    prometheusEndpointSSLVerify: true\n</code></pre> <p>Note</p> <p>It is not recommended to consume storage from the Ceph cluster for Prometheus. If the Ceph cluster fails, Prometheus would become unresponsive and thus not alert you of the failure.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#prometheus-web-console","title":"Prometheus Web Console","text":"<p>Once the Prometheus server is running, you can open a web browser and go to the URL that is output from this command:</p> <pre><code>echo \"http://$(kubectl -n rook-ceph -o jsonpath={.status.hostIP} get pod prometheus-rook-prometheus-0):30900\"\n</code></pre> <p>You should now see the Prometheus monitoring website.</p> <p></p> <p>Click on <code>Graph</code> in the top navigation bar.</p> <p></p> <p>In the dropdown that says <code>insert metric at cursor</code>, select any metric you would like to see, for example <code>ceph_cluster_total_used_bytes</code></p> <p></p> <p>Click on the <code>Execute</code> button.</p> <p></p> <p>Below the <code>Execute</code> button, ensure the <code>Graph</code> tab is selected and you should now see a graph of your chosen metric over time.</p> <p></p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#prometheus-consoles","title":"Prometheus Consoles","text":"<p>You can find Prometheus Consoles for and from Ceph here: GitHub ceph/cephmetrics - dashboards/current directory.</p> <p>A guide to how you can write your own Prometheus consoles can be found on the official Prometheus site here: Prometheus.io Documentation - Console Templates.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#prometheus-alerts","title":"Prometheus Alerts","text":"<p>To enable the Ceph Prometheus alerts via the helm charts, set the following properties in values.yaml:</p> <ul> <li>rook-ceph chart:<ul> <li><code>monitoring.enabled: true</code></li> </ul> </li> <li>rook-ceph-cluster chart:<ul> <li><code>monitoring.enabled: true</code></li> <li><code>monitoring.createPrometheusRules: true</code></li> </ul> </li> </ul> <p>Alternatively, to enable the Ceph Prometheus alerts with example manifests follow these steps:</p> <ol> <li> <p>Create the RBAC and prometheus rules:</p> <pre><code>kubectl create -f deploy/examples/monitoring/rbac.yaml\nkubectl create -f deploy/examples/monitoring/localrules.yaml\n</code></pre> </li> <li> <p>Make following changes to your CephCluster object (e.g., <code>cluster.yaml</code>).</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephCluster\nmetadata:\n  name: rook-ceph\n  namespace: rook-ceph\n[...]\nspec:\n[...]\n  monitoring:\n    enabled: true\n[...]\n</code></pre> </li> <li> <p>Deploy or update the CephCluster object.</p> <pre><code>kubectl apply -f cluster.yaml\n</code></pre> </li> </ol> <p>Note</p> <p>This expects the Prometheus Operator and a Prometheus instance to be pre-installed by the admin.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#customize-alerts","title":"Customize Alerts","text":"<p>The Prometheus alerts can be customized with a post-processor using tools such as Kustomize. For example, first extract the helm chart:</p> <pre><code>helm template -f values.yaml rook-release/rook-ceph-cluster &gt; cluster-chart.yaml\n</code></pre> <p>Now create the desired customization configuration files. This simple example will show how to update the severity of a rule, add a label to a rule, and change the <code>for</code> time value.</p> <p>Create a file named kustomization.yaml:</p> <pre><code>patches:\n- path: modifications.yaml\n  target:\n    group: monitoring.coreos.com\n    kind: PrometheusRule\n    name: prometheus-ceph-rules\n    version: v1\nresources:\n- cluster-chart.yaml\n</code></pre> <p>Create a file named modifications.yaml</p> <pre><code>- op: add\n  path: /spec/groups/0/rules/0/labels\n  value:\n    my-label: foo\n    severity: none\n- op: add\n  path: /spec/groups/0/rules/0/for\n  value: 15m\n</code></pre> <p>Finally, run kustomize to update the desired prometheus rules:</p> <pre><code>kustomize build . &gt; updated-chart.yaml\nkubectl create -f updated-chart.yaml\n</code></pre>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#grafana-dashboards","title":"Grafana Dashboards","text":"<p>The dashboards have been created by @galexrt. For feedback on the dashboards please reach out to him on the Rook.io Slack.</p> <p>Note</p> <p>The dashboards are only compatible with Grafana 7.2.0 or higher. Also note that the dashboards are updated from time to time, to fix issues and improve them.</p> <p>The following Grafana dashboards are available:</p> <ul> <li>Ceph - Cluster (ID: 2842)</li> <li>Ceph - OSD (Single) (ID: 5336)</li> <li>Ceph - Pools (ID: 5342)</li> </ul> <p>The dashboard JSON files are also available on GitHub here <code>/deploy/examples/monitoring/grafana/</code>.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#updates-and-upgrades","title":"Updates and Upgrades","text":"<p>When updating Rook, there may be updates to RBAC for monitoring. It is easy to apply the changes with each update or upgrade. This should be done at the same time you update Rook common resources like <code>common.yaml</code>.</p> <pre><code>kubectl apply -f deploy/examples/monitoring/rbac.yaml\n</code></pre> <p>Hint</p> <p>This is updated automatically if you are upgrading via the helm chart</p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#teardown","title":"Teardown","text":"<p>To clean up all the artifacts created by the monitoring walk-through, copy/paste the entire block below (note that errors about resources \"not found\" can be ignored):</p> <pre><code>kubectl delete -f service-monitor.yaml\nkubectl delete -f prometheus.yaml\nkubectl delete -f prometheus-service.yaml\nkubectl delete -f https://raw.githubusercontent.com/coreos/prometheus-operator/v0.71.1/bundle.yaml\n</code></pre> <p>Then the rest of the instructions in the Prometheus Operator docs can be followed to finish cleaning up.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#special-cases","title":"Special Cases","text":""},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#tectonic-bare-metal","title":"Tectonic Bare Metal","text":"<p>Tectonic strongly discourages the <code>tectonic-system</code> Prometheus instance to be used outside their intentions, so you need to create a new Prometheus Operator yourself. After this you only need to create the service monitor as stated above.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#csi-liveness","title":"CSI Liveness","text":"<p>To integrate CSI liveness into ceph monitoring we will need to deploy a service and service monitor.</p> <pre><code>kubectl create -f csi-metrics-service-monitor.yaml\n</code></pre> <p>This will create the service monitor to have prometheus monitor CSI</p> <p>Note</p> <p>Please note that the liveness sidecar is disabled by default. To enable it set <code>CSI_ENABLE_LIVENESS</code> to <code>true</code> in the Rook operator settings (operator.yaml).</p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#collecting-rbd-per-image-io-statistics","title":"Collecting RBD per-image IO statistics","text":"<p>RBD per-image IO statistics collection is disabled by default. This can be enabled by setting <code>enableRBDStats: true</code> in the CephBlockPool spec. Prometheus does not need to be restarted after enabling it.</p>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#using-custom-label-selectors-in-prometheus","title":"Using custom label selectors in Prometheus","text":"<p>If Prometheus needs to select specific resources, we can do so by injecting labels into these objects and using it as label selector.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephCluster\nmetadata:\n  name: rook-ceph\n  namespace: rook-ceph\n  [...]\nspec:\n  [...]\n  labels:\n    monitoring:\n      prometheus: k8s\n  [...]\n</code></pre>"},{"location":"Storage-Configuration/Monitoring/ceph-monitoring/#horizontal-pod-scaling-using-kubernetes-event-driven-autoscaling-keda","title":"Horizontal Pod Scaling using Kubernetes Event-driven Autoscaling (KEDA)","text":"<p>Using metrics exported from the Prometheus service, the horizontal pod scaling can use the custom metrics other than CPU and memory consumption. It can be done with help of Prometheus Scaler provided by the KEDA. See the KEDA deployment guide for details.</p> <p>Following is an example to autoscale RGW:</p> <pre><code>apiVersion: keda.sh/v1alpha1\nkind: ScaledObject\nmetadata:\n name: rgw-scale\n namespace: rook-ceph\nspec:\n scaleTargetRef:\n   kind: Deployment\n   name: rook-ceph-rgw-my-store-a # deployment for the autoscaling\n minReplicaCount: 1\n maxReplicaCount: 5\n triggers:\n - type: prometheus\n   metadata:\n     serverAddress: http://rook-prometheus.rook-ceph.svc:9090\n     metricName: collecting_ceph_rgw_put\n     query: |\n       sum(rate(ceph_rgw_put[2m])) # prometheus query used for autoscaling\n     threshold: \"90\"\n</code></pre> <p>Warning</p> <p>During reconciliation of a <code>CephObjectStore</code>, the Rook Operator will reset the replica count for RGW which was set by horizontal pod scaler. The horizontal pod autoscaler will change the again once it re-evaluates the rule. This can result in a performance hiccup of several seconds after a reconciliation. This is briefly discussed (here)[https://github.com/rook/rook/issues/10001]</p>"},{"location":"Storage-Configuration/NFS/nfs-advanced/","title":"Advanced configuration","text":"<p>All CephNFS daemons are configured using shared RADOS objects stored in a Ceph pool named <code>.nfs</code>. Users can modify the configuration object for each CephNFS cluster if they wish to customize the configuration.</p>"},{"location":"Storage-Configuration/NFS/nfs-advanced/#changing-configuration-of-the-nfs-pool","title":"Changing configuration of the .nfs pool","text":"<p>By default, Rook creates the <code>.nfs</code> pool with Ceph's default configuration. If you wish to change the configuration of this pool (for example to change its failure domain or replication factor), you can create a CephBlockPool with the <code>spec.name</code> field set to <code>.nfs</code>. This pool must be replicated and cannot be erasure coded. <code>deploy/examples/nfs.yaml</code> contains a sample for reference.</p>"},{"location":"Storage-Configuration/NFS/nfs-advanced/#adding-custom-nfs-ganesha-config-file-changes","title":"Adding custom NFS-Ganesha config file changes","text":"<p>Ceph uses NFS-Ganesha servers. The config file format for these objects is documented in the NFS-Ganesha project.</p> <p>Use Ceph's <code>rados</code> tool from the toolbox to interact with the configuration object. The below command will get you started by dumping the contents of the config object to stdout. The output will look something like the example shown if you have already created two exports as documented above. It is best not to modify any of the export objects created by Ceph so as not to cause errors with Ceph's export management.</p> <pre><code>$ rados --pool &lt;pool&gt; --namespace &lt;namespace&gt; get conf-nfs.&lt;cephnfs-name&gt; -\n%url \"rados://&lt;pool&gt;/&lt;namespace&gt;/export-1\"\n%url \"rados://&lt;pool&gt;/&lt;namespace&gt;/export-2\"\n</code></pre> <p><code>rados ls</code> and <code>rados put</code> are other commands you will want to work with the other shared configuration objects.</p> <p>Of note, it is possible to pre-populate the NFS configuration and export objects prior to creating CephNFS server clusters.</p>"},{"location":"Storage-Configuration/NFS/nfs-advanced/#creating-nfs-export-over-rgw","title":"Creating NFS export over RGW","text":"<p>Warning</p> <p>RGW NFS export is experimental for the moment. It is not recommended for scenario of modifying existing content.</p> <p>For creating an NFS export over RGW(CephObjectStore) storage backend, the below command can be used. This creates an export for the <code>/testrgw</code> pseudo path on an existing bucket bkt4exp as an example. You could use <code>/testrgw</code> pseudo for nfs mount operation afterwards.</p> <pre><code>ceph nfs export create rgw my-nfs /testrgw bkt4exp\n</code></pre>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/","title":"CSI provisioner and driver","text":"<p>Attention</p> <p>This feature is experimental and will not support upgrades to future versions.</p> <p>For this section, we will refer to Rook's deployment examples in the deploy/examples directory.</p>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#enabling-the-csi-drivers","title":"Enabling the CSI drivers","text":"<p>The Ceph CSI NFS provisioner and driver require additional RBAC to operate. Apply the <code>deploy/examples/csi/nfs/rbac.yaml</code> manifest to deploy the additional resources.</p> <p>Rook will only deploy the Ceph CSI NFS provisioner and driver components when the <code>ROOK_CSI_ENABLE_NFS</code> config is set to <code>\"true\"</code> in the <code>rook-ceph-operator-config</code> configmap. Change the value in your manifest, or patch the resource as below.</p> <pre><code>kubectl --namespace rook-ceph patch configmap rook-ceph-operator-config --type merge --patch '{\"data\":{\"ROOK_CSI_ENABLE_NFS\": \"true\"}}'\n</code></pre> <p>Note</p> <p>The rook-ceph operator Helm chart will deploy the required RBAC and enable the driver components if <code>csi.nfs.enabled</code> is set to <code>true</code>.</p>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#creating-nfs-exports-via-pvc","title":"Creating NFS exports via PVC","text":""},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#prerequisites","title":"Prerequisites","text":"<p>In order to create NFS exports via the CSI driver, you must first create a CephFilesystem to serve as the underlying storage for the exports, and you must create a CephNFS to run an NFS server that will expose the exports. RGWs cannot be used for the CSI driver.</p> <p>From the examples, <code>filesystem.yaml</code> creates a CephFilesystem called <code>myfs</code>, and <code>nfs.yaml</code> creates an NFS server called <code>my-nfs</code>.</p> <p>You may need to enable or disable the Ceph orchestrator.</p> <p>You must also create a storage class. Ceph CSI is designed to support any arbitrary Ceph cluster, but we are focused here only on Ceph clusters deployed by Rook. Let's take a look at a portion of the example storage class found at <code>deploy/examples/csi/nfs/storageclass.yaml</code> and break down how the values are determined.</p> <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: rook-nfs\nprovisioner: rook-ceph.nfs.csi.ceph.com # [1]\nparameters:\n  nfsCluster: my-nfs # [2]\n  server: rook-ceph-nfs-my-nfs-a # [3]\n  clusterID: rook-ceph # [4]\n  fsName: myfs # [5]\n  pool: myfs-replicated # [6]\n\n  # [7] (entire csi.storage.k8s.io/* section immediately below)\n  csi.storage.k8s.io/provisioner-secret-name: rook-csi-cephfs-provisioner\n  csi.storage.k8s.io/provisioner-secret-namespace: rook-ceph\n  csi.storage.k8s.io/controller-expand-secret-name: rook-csi-cephfs-provisioner\n  csi.storage.k8s.io/controller-expand-secret-namespace: rook-ceph\n  csi.storage.k8s.io/node-stage-secret-name: rook-csi-cephfs-node\n  csi.storage.k8s.io/node-stage-secret-namespace: rook-ceph\n\n# ... some fields omitted ...\n</code></pre> <ol> <li><code>provisioner</code>: rook-ceph.nfs.csi.ceph.com because rook-ceph is the namespace where the     CephCluster is installed</li> <li><code>nfsCluster</code>: my-nfs because this is the name of the CephNFS</li> <li><code>server</code>: rook-ceph-nfs-my-nfs-a because Rook creates this Kubernetes Service for the CephNFS     named my-nfs</li> <li><code>clusterID</code>: rook-ceph because this is the namespace where the CephCluster is installed</li> <li><code>fsName</code>: myfs because this is the name of the CephFilesystem used to back the NFS exports</li> <li><code>pool</code>: myfs-replicated because myfs is the name of the CephFilesystem defined in     <code>fsName</code> and because replicated is the name of a data pool defined in the CephFilesystem</li> <li><code>csi.storage.k8s.io/*</code>: note that these values are shared with the Ceph CSI CephFS provisioner</li> </ol>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#creating-a-pvc","title":"Creating a PVC","text":"<p>See <code>deploy/examples/csi/nfs/pvc.yaml</code> for an example of how to create a PVC that will create an NFS export. The export will be created and a PV created for the PVC immediately, even without a Pod to mount the PVC.</p>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#attaching-an-export-to-a-pod","title":"Attaching an export to a pod","text":"<p>See <code>deploy/examples/csi/nfs/pod.yaml</code> for an example of how a PVC can be connected to an application pod.</p>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#connecting-to-an-export-directly","title":"Connecting to an export directly","text":"<p>After a PVC is created successfully, the <code>share</code> parameter set on the resulting PV contains the <code>share</code> path which can be used as the export path when mounting the export manually. In the example below <code>/0001-0009-rook-ceph-0000000000000001-55c910f9-a1af-11ed-9772-1a471870b2f5</code> is the export path.</p> <pre><code>$ kubectl get pv pvc-b559f225-de79-451b-a327-3dbec1f95a1c -o jsonpath='{.spec.csi.volumeAttributes}'\n/0001-0009-rook-ceph-0000000000000001-55c910f9-a1af-11ed-9772-1a471870b2f5\n</code></pre>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#taking-snapshots-of-nfs-exports","title":"Taking snapshots of NFS exports","text":"<p>NFS export PVCs can be snapshotted and later restored to new PVCs.</p>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#creating-snapshots","title":"Creating snapshots","text":"<p>First, create a VolumeSnapshotClass as in the example here. The <code>csi.storage.k8s.io/snapshotter-secret-name</code> parameter should reference the name of the secret created for the cephfsplugin here.</p> <pre><code>kubectl create -f deploy/examples/csi/nfs/snapshotclass.yaml\n</code></pre> <p>In snapshot, <code>volumeSnapshotClassName</code> should be the name of the VolumeSnapshotClass previously created. The <code>persistentVolumeClaimName</code> should be the name of the PVC which is already created by the NFS CSI driver.</p> <pre><code>kubectl create -f deploy/examples/csi/nfs/snapshot.yaml\n</code></pre>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#verifying-snapshots","title":"Verifying snapshots","text":"<pre><code>$ kubectl get volumesnapshotclass\nNAME                        DRIVER                          DELETIONPOLICY   AGE\ncsi-nfslugin-snapclass      rook-ceph.nfs.csi.ceph.com      Delete           3h55m\n</code></pre> <pre><code>$ kubectl get volumesnapshot\nNAME                  READYTOUSE   SOURCEPVC   SOURCESNAPSHOTCONTENT  RESTORESIZE   SNAPSHOTCLASS                SNAPSHOTCONTENT                                   CREATIONTIME   AGE\nnfs-pvc-snapshot      true         nfs-pvc                            1Gi           csi-nfsplugin-snapclass      snapcontent-34476204-a14a-4d59-bfbc-2bbba695652c  3h50m          3h51m\n</code></pre> <p>The snapshot will be ready to restore to a new PVC when <code>READYTOUSE</code> field of the volumesnapshot is set to true.</p>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#restoring-snapshot-to-a-new-pvc","title":"Restoring snapshot to a new PVC","text":"<p>In pvc-restore, <code>dataSource</code> name should be the name of the VolumeSnapshot previously created. The <code>dataSource</code> kind should be \"VolumeSnapshot\".</p> <p>Create a new PVC from the snapshot.</p> <pre><code>kubectl create -f deploy/examples/csi/nfs/pvc-restore.yaml\n</code></pre>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#verifying-restored-pvc-creation","title":"Verifying restored PVC Creation","text":"<pre><code>$ kubectl get pvc\nNAME                 STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS      AGE\nnfs-pvc              Bound    pvc-74734901-577a-11e9-b34f-525400581048   1Gi        RWX            rook-nfs          55m\nnfs-pvc-restore      Bound    pvc-95308c75-6c93-4928-a551-6b5137192209   1Gi        RWX            rook-nfs          34s\n</code></pre>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#cleaning-up-snapshot-resource","title":"Cleaning up snapshot resource","text":"<p>To clean your cluster of the resources created by this example, run the following:</p> <pre><code>kubectl delete -f deploy/examples/csi/nfs/pvc-restore.yaml\nkubectl delete -f deploy/examples/csi/nfs/snapshot.yaml\nkubectl delete -f deploy/examples/csi/nfs/snapshotclass.yaml\n</code></pre>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#cloning-nfs-exports","title":"Cloning NFS exports","text":""},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#creating-clones","title":"Creating clones","text":"<p>In pvc-clone, <code>dataSource</code> should be the name of the PVC which is already created by NFS CSI driver. The <code>dataSource</code> kind should be \"PersistentVolumeClaim\" and also storageclass should be same as the source PVC.</p> <p>Create a new PVC Clone from the PVC as in the example here.</p> <pre><code>kubectl create -f deploy/examples/csi/nfs/pvc-clone.yaml\n</code></pre>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#verifying-a-cloned-pvc","title":"Verifying a cloned PVC","text":"<pre><code>kubectl get pvc\n</code></pre> <pre><code>NAME              STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE\nnfs-pvc           Bound    pvc-1ea51547-a88b-4ab0-8b4a-812caeaf025d   1Gi        RWX            rook-nfs       39m\nnfs-pvc-clone     Bound    pvc-b575bc35-d521-4c41-b4f9-1d733cd28fdf   1Gi        RWX            rook-nfs       8s\n</code></pre>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#cleaning-up-clone-resources","title":"Cleaning up clone resources","text":"<p>To clean your cluster of the resources created by this example, run the following:</p> <pre><code>kubectl delete -f deploy/examples/csi/nfs/pvc-clone.yaml\n</code></pre>"},{"location":"Storage-Configuration/NFS/nfs-csi-driver/#consuming-nfs-from-an-external-source","title":"Consuming NFS from an external source","text":"<p>For consuming NFS services and exports external to the Kubernetes cluster (including those backed by an external standalone Ceph cluster), Rook recommends using Kubernetes regular NFS consumption model. This requires the Ceph admin to create the needed export, while reducing the privileges needed in the client cluster for the NFS volume.</p> <p>Export and get the nfs client to a particular cephFS filesystem:</p> <pre><code>ceph nfs export create cephfs &lt;nfs-client-name&gt; /test &lt;filesystem-name&gt;\nceph nfs export get &lt;service&gt; &lt;export-name&gt;\n</code></pre> <p>Create the PV and PVC using <code>nfs-client-server-ip</code>. It will mount NFS volumes with PersistentVolumes and then mount the PVCs in the user Pod Application to utilize the NFS type storage.</p>"},{"location":"Storage-Configuration/NFS/nfs-security/","title":"Security","text":"<p>Rook provides security for CephNFS server clusters through two high-level features: user ID mapping and user authentication.</p> <p>Attention</p> <p>All features in this document are experimental and may not support upgrades to future versions.</p> <p>Attention</p> <p>Some configurations of these features may break the ability to mount NFS storage to pods via PVCs. The NFS CSI driver may not be able to mount exports for pods when ID mapping is configured.</p>"},{"location":"Storage-Configuration/NFS/nfs-security/#user-id-mapping","title":"User ID mapping","text":"<p>User ID mapping allows the NFS server to map connected NFS client IDs to a different user domain, allowing NFS clients to be associated with a particular user in your organization. For example, users stored in LDAP can be associated with NFS users and vice versa.</p>"},{"location":"Storage-Configuration/NFS/nfs-security/#id-mapping-via-sssd","title":"ID mapping via SSSD","text":"<p>SSSD is the System Security Services Daemon. It can be used to provide user ID mapping from a  number of sources including LDAP, Active Directory, and FreeIPA. Currently, only LDAP has been tested.</p>"},{"location":"Storage-Configuration/NFS/nfs-security/#sssd-configuration","title":"SSSD configuration","text":"<p>SSSD requires a configuration file in order to configure its connection to the user ID mapping system (e.g., LDAP). The file follows the <code>sssd.conf</code> format documented in its man pages.</p> <p>Methods of providing the configuration file are documented in the NFS CRD security section.</p> <p>Recommendations:</p> <ul> <li>The SSSD sidecar only requires the namespace switch (a.k.a. \"nsswitch\" or \"nss\"). We recommend     enabling only the <code>nss</code> service to lower CPU usage.</li> <li>NFS-Ganesha does not require user enumeration. We recommend leaving this option unset or setting     <code>enumerate = false</code> to speed up lookups and reduce RAM usage.</li> <li>NFS exports created via documented methods do not require listing all members of groups. We     recommend setting <code>ignore_group_members = true</code> to speed up LDAP lookups. Only customized exports     that set <code>manage_gids</code> need to consider this option.</li> </ul> <p>A sample <code>sssd.conf</code> file is shown below.</p> <pre><code>[sssd]\n# Only the nss service is required for the SSSD sidecar.\nservices = nss\ndomains = default\nconfig_file_version = 2\n\n[nss]\nfilter_users = root\n\n[domain/default]\nid_provider = ldap\nldap_uri = ldap://server-address.example.net\nldap_search_base = dc=example,dc=net\nldap_default_bind_dn = cn=admin,dc=example,dc=net\nldap_default_authtok_type = password\nldap_default_authtok = my-password\nldap_user_search_base = ou=users,dc=example,dc=net\nldap_group_search_base = ou=groups,dc=example,dc=net\nldap_access_filter = memberOf=cn=rook,ou=groups,dc=example,dc=net\n# recommended options for speeding up LDAP lookups:\nenumerate = false\nignore_group_members = true\n</code></pre> <p>The SSSD configuration file may be omitted from the CephNFS spec if desired. In this case, Rook will not set <code>/etc/sssd/sssd.conf</code> in any way. This allows you to manage the <code>sssd.conf</code> file yourself however you wish. For example, you may build it into your custom Ceph container image, or use the Vault agent injector to securely add the file via annotations on the CephNFS spec (passed to the NFS server pods).</p>"},{"location":"Storage-Configuration/NFS/nfs-security/#user-authentication","title":"User authentication","text":"<p>User authentication allows NFS clients and the Rook CephNFS servers to authenticate with each other to ensure security.</p>"},{"location":"Storage-Configuration/NFS/nfs-security/#authentication-through-kerberos","title":"Authentication through Kerberos","text":"<p>Kerberos is the authentication mechanism natively supported by NFS-Ganesha. With NFSv4, individual users are authenticated and not merely client machines.</p>"},{"location":"Storage-Configuration/NFS/nfs-security/#kerberos-configuration","title":"Kerberos configuration","text":"<p>Kerberos authentication requires configuration files in order for the NFS-Ganesha server to authenticate to the Kerberos server (KDC). The requirements are two-parted:</p> <ol> <li>one or more kerberos configuration files that configures the connection to the Kerberos server.     This file follows the <code>krb5.conf</code> format documented in its     man pages.</li> <li>a keytab file that provides credentials for the     service principal that NFS-Ganesha will use to authenticate with the     Kerberos server.</li> <li>a kerberos domain name which will be used to map kerberos credentials to uid/gid     domain name that NFS-Ganesha will use to authenticate with the</li> </ol> <p>Methods of providing the configuration files are documented in the NFS CRD security section.</p> <p>Recommendations:</p> <ul> <li>Rook configures Kerberos to log to stderr. We suggest removing logging sections from config files     to avoid consuming unnecessary disk space from logging to files.</li> </ul> <p>A sample Kerberos config file is shown below.</p> <pre><code>[libdefaults]\ndefault_realm = EXAMPLE.NET\n\n[realms]\nEXAMPLE.NET = {\nkdc = kdc.example.net:88\nadmin_server = kdc.example.net:749\n}\n\n[domain_realm]\n.example.net = EXAMPLE.NET\nexample.net = EXAMPLE.NET\n</code></pre> <p>The Kerberos config files (<code>configFiles</code>) may be omitted from the Ceph NFS spec if desired. In this case, Rook will not add any config files to <code>/etc/krb5.conf.rook/</code>, but it will still configure Kerberos to load any config files it finds there. This allows you to manage these files yourself however you wish.</p> <p>Similarly, the keytab file (<code>keytabFile</code>) may be  omitted from the CephNFS spec if  desired. In this case, Rook will not set <code>/etc/krb5.keytab</code> in any way. This allows you to manage the <code>krb5.keytab</code> file yourself however you wish.</p> <p>As an example for either of the above cases, you may build files into your custom Ceph container image or use the Vault agent injector to securely add files via annotations on the CephNFS spec (passed to the NFS server pods).</p>"},{"location":"Storage-Configuration/NFS/nfs-security/#nfs-service-principals","title":"NFS service principals","text":"<p>The Kerberos service principal used by Rook's CephNFS servers to authenticate with the Kerberos server is built up from 3 components:</p> <ol> <li>the configured from <code>spec.security.kerberos.principalName</code> that acts as the service name</li> <li>the hostname of the server on which NFS-Ganesha is running which is in turn built up from the     namespace and name of the CephNFS resource, joined by a hyphen. e.g., <code>rooknamespace-nfsname</code></li> <li>the realm as configured by the kerberos config file(s) from <code>spec.security.kerberos.configFiles</code></li> </ol> <p>The full service principal name is constructed as <code>&lt;principalName&gt;/&lt;namespace&gt;-&lt;name&gt;@&lt;realm&gt;</code>. For ease of scaling up or down CephNFS clusters, this principal is used for all servers in the CephNFS cluster.</p> <p>Users must add this service principal to their Kerberos server configuration.</p> <p>Example</p> <p>For a CephNFS named \"fileshare\" in the \"business-unit\" Kubernetes namespace that has a <code>principalName</code> of \"sales-apac\" and where the Kerberos realm is \"EXAMPLE.NET\", the full principal name will be <code>sales-apac/business-unit-fileshare@EXAMPLE.NET</code>.</p> <p>Advanced</p> <p><code>spec.security.kerberos.principalName</code> corresponds directly to NFS-Ganesha's NFS_KRB5:PrincipalName config. See the NFS-Ganesha wiki for more details.</p>"},{"location":"Storage-Configuration/NFS/nfs-security/#kerberos-domain-name","title":"Kerberos domain name","text":"<p>The kerberos domain name is used to setup the domain name in /etc/idmapd.conf. This domain name is used by idmap to map the kerberos credential to the user uid/gid. Without this configured, NFS-Ganesha will be unable to map the Kerberos principal to an uid/gid and will instead use the configured anonuid/anongid (default: -2) when accessing the local filesystem.</p>"},{"location":"Storage-Configuration/NFS/nfs/","title":"NFS Storage Overview","text":"<p>NFS storage can be mounted with read/write permission from multiple pods. NFS storage may be especially useful for leveraging an existing Rook cluster to provide NFS storage for legacy applications that assume an NFS client connection. Such applications may not have been migrated to Kubernetes or might not yet support PVCs. Rook NFS storage can provide access to the same network filesystem storage from within the Kubernetes cluster via PVC while simultaneously providing access via direct client connection from within or outside of the Kubernetes cluster.</p> <p>Warning</p> <p>Simultaneous access to NFS storage from Pods and from external clients complicates NFS user ID mapping significantly. Client IDs mapped from external clients will not be the same as the IDs associated with the NFS CSI driver, which mount exports for Kubernetes pods.</p> <p>Warning</p> <p>Due to a number of Ceph issues and changes, Rook officially only supports Ceph v16.2.7 or higher for CephNFS. If you are using an earlier version, upgrade your Ceph version following the advice given in Rook's v1.9 NFS docs.</p> <p>Note</p> <p>CephNFSes support NFSv4.1+ access only. Serving earlier protocols inhibits responsiveness after a server restart.</p>"},{"location":"Storage-Configuration/NFS/nfs/#prerequisites","title":"Prerequisites","text":"<p>This guide assumes you have created a Rook cluster as explained in the main quickstart guide as well as a Ceph filesystem which will act as the backing storage for NFS.</p> <p>Many samples reference the CephNFS and CephFilesystem example manifests here and here.</p>"},{"location":"Storage-Configuration/NFS/nfs/#creating-an-nfs-cluster","title":"Creating an NFS cluster","text":"<p>Create the NFS cluster by specifying the desired settings documented for the NFS CRD.</p>"},{"location":"Storage-Configuration/NFS/nfs/#creating-exports","title":"Creating Exports","text":"<p>When a CephNFS is first created, all NFS daemons within the CephNFS cluster will share a configuration with no exports defined. When creating an export, it is necessary to specify the CephFilesystem which will act as the backing storage for the NFS export.</p> <p>RADOS Gateways (RGWs), provided by CephObjectStores, can also be used as backing storage for NFS exports if desired.</p>"},{"location":"Storage-Configuration/NFS/nfs/#using-the-ceph-dashboard","title":"Using the Ceph Dashboard","text":"<p>Exports can be created via the Ceph dashboard as well. To enable and use the Ceph dashboard in Rook, see here.</p>"},{"location":"Storage-Configuration/NFS/nfs/#using-the-ceph-cli","title":"Using the Ceph CLI","text":"<p>The Ceph CLI can be used from the Rook toolbox pod to create and manage NFS exports. To do so, first ensure the necessary Ceph mgr modules are enabled, if necessary, and that the Ceph orchestrator backend is set to Rook.</p>"},{"location":"Storage-Configuration/NFS/nfs/#enable-the-ceph-orchestrator-optional","title":"Enable the Ceph orchestrator (optional)","text":"<pre><code>ceph mgr module enable rook\nceph mgr module enable nfs\nceph orch set backend rook\n</code></pre> <p>Ceph's NFS CLI can create NFS exports that are backed by CephFS (a CephFilesystem) or Ceph Object Gateway (a CephObjectStore). <code>cluster_id</code> or <code>cluster-name</code> in the Ceph NFS docs normally refers to the name of the NFS cluster, which is the CephNFS name in the Rook context.</p> <p>For creating an NFS export for the CephNFS and CephFilesystem example manifests, the below command can be used. This creates an export for the <code>/test</code> pseudo path.</p> <pre><code>ceph nfs export create cephfs my-nfs /test myfs\n</code></pre> <p>The below command will list the current NFS exports for the example CephNFS cluster, which will give the output shown for the current example.</p> <pre><code>$ ceph nfs export ls my-nfs\n[\n  \"/test\"\n]\n</code></pre> <p>The simple <code>/test</code> export's info can be listed as well. Notice from the example that only NFS protocol v4 via TCP is supported.</p> <pre><code>$ ceph nfs export info my-nfs /test\n{\n  \"export_id\": 1,\n  \"path\": \"/\",\n  \"cluster_id\": \"my-nfs\",\n  \"pseudo\": \"/test\",\n  \"access_type\": \"RW\",\n  \"squash\": \"none\",\n  \"security_label\": true,\n  \"protocols\": [\n    4\n  ],\n  \"transports\": [\n    \"TCP\"\n  ],\n  \"fsal\": {\n    \"name\": \"CEPH\",\n    \"user_id\": \"nfs.my-nfs.1\",\n    \"fs_name\": \"myfs\"\n  },\n  \"clients\": []\n}\n</code></pre> <p>If you are done managing NFS exports and don't need the Ceph orchestrator module enabled for anything else, it may be preferable to disable the Rook and NFS mgr modules to free up a small amount of RAM in the Ceph mgr Pod.</p> <pre><code>ceph orch set backend \"\"\nceph mgr module disable rook\n</code></pre>"},{"location":"Storage-Configuration/NFS/nfs/#mounting-exports","title":"Mounting exports","text":"<p>Each CephNFS server has a unique Kubernetes Service. This is because NFS clients can't readily handle NFS failover. CephNFS services are named with the pattern <code>rook-ceph-nfs-&lt;cephnfs-name&gt;-&lt;id&gt;</code> <code>&lt;id&gt;</code> is a unique letter ID (e.g., a, b, c, etc.) for a given NFS server. For example, <code>rook-ceph-nfs-my-nfs-a</code>.</p> <p>For each NFS client, choose an NFS service to use for the connection. With NFS v4, you can mount an export by its path using a mount command like below. You can mount all exports at once by omitting the export path and leaving the directory as just <code>/</code>.</p> <pre><code>mount -t nfs4 -o proto=tcp &lt;nfs-service-address&gt;:/&lt;export-path&gt; &lt;mount-location&gt;\n</code></pre>"},{"location":"Storage-Configuration/NFS/nfs/#exposing-the-nfs-server-outside-of-the-kubernetes-cluster","title":"Exposing the NFS server outside of the Kubernetes cluster","text":"<p>Use a LoadBalancer Service to expose an NFS server (and its exports) outside of the Kubernetes cluster. The Service's endpoint can be used as the NFS service address when mounting the export manually. We provide an example Service here: <code>deploy/examples/nfs-load-balancer.yaml</code>.</p>"},{"location":"Storage-Configuration/NFS/nfs/#nfs-security","title":"NFS Security","text":"<p>Security options for NFS are documented here.</p>"},{"location":"Storage-Configuration/NFS/nfs/#ceph-csi-nfs-provisioner-and-nfs-csi-driver","title":"Ceph CSI NFS provisioner and NFS CSI driver","text":"<p>The NFS CSI provisioner and driver are documented here</p>"},{"location":"Storage-Configuration/NFS/nfs/#advanced-configuration","title":"Advanced configuration","text":"<p>Advanced NFS configuration is documented here</p>"},{"location":"Storage-Configuration/NFS/nfs/#known-issues","title":"Known issues","text":"<p>Known issues are documented on the NFS CRD page.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-claim/","title":"Bucket Claim","text":"<p>Rook supports the creation of new buckets and access to existing buckets via two custom resources:</p> <ul> <li>an <code>Object Bucket Claim (OBC)</code> is custom resource which requests a bucket (new or existing) and is described by a Custom Resource Definition (CRD) shown below.</li> <li>an <code>Object Bucket (OB)</code> is a custom resource automatically generated when a bucket is provisioned. It is a global resource, typically not visible to non-admin users, and contains information specific to the bucket. It is described by an OB CRD, also shown below.</li> </ul> <p>An OBC references a storage class which is created by an administrator. The storage class defines whether the bucket requested is a new bucket or an existing bucket. It also defines the bucket retention policy. Users request a new or existing bucket by creating an OBC which is shown below. The ceph provisioner detects the OBC and creates a new bucket or grants access to an existing bucket, depending the storage class referenced in the OBC. It also generates a Secret which provides credentials to access the bucket, and a ConfigMap which contains the bucket's endpoint. Application pods consume the information in the Secret and ConfigMap to access the bucket. Please note that to make provisioner watch the cluster namespace only you need to set <code>ROOK_OBC_WATCH_OPERATOR_NAMESPACE</code> to <code>true</code> in the operator manifest, otherwise it watches all namespaces.</p> <p>The OBC provisioner name found in the storage class by default includes the operator namespace as a prefix. A custom prefix can be applied by the operator setting in the <code>rook-ceph-operator-config</code> configmap: <code>ROOK_OBC_PROVISIONER_NAME_PREFIX</code>.</p> <p>Note</p> <p>Changing the prefix is not supported on existing clusters. This may impact the function of existing OBCs.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-claim/#example","title":"Example","text":""},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-claim/#obc-custom-resource","title":"OBC Custom Resource","text":"<pre><code>apiVersion: objectbucket.io/v1alpha1\nkind: ObjectBucketClaim\nmetadata:\n  name: ceph-bucket [1]\n  namespace: rook-ceph [2]\nspec:\n  bucketName: [3]\n  generateBucketName: photo-booth [4]\n  storageClassName: rook-ceph-bucket [5]\n  additionalConfig: [6]\n    maxObjects: \"1000\"\n    maxSize: \"2G\"\n    bucketMaxObjects: \"3000\"\n    bucketMaxSize: \"4G\"\n</code></pre> <ol> <li><code>name</code> of the <code>ObjectBucketClaim</code>. This name becomes the name of the Secret and ConfigMap.</li> <li><code>namespace</code>(optional) of the <code>ObjectBucketClaim</code>, which is also the namespace of the ConfigMap and Secret.</li> <li><code>bucketName</code> name of the <code>bucket</code>. Not recommended for new buckets since names must be unique within an entire object store.</li> <li><code>generateBucketName</code> value becomes the prefix for a randomly generated name, if supplied then <code>bucketName</code> must be empty. If both <code>bucketName</code> and <code>generateBucketName</code> are supplied then <code>BucketName</code> has precedence and <code>GenerateBucketName</code> is ignored. If both <code>bucketName</code> and <code>generateBucketName</code> are blank or omitted then the storage class is expected to contain the name of an existing bucket. It's an error if all three bucket related names are blank or omitted.</li> <li><code>storageClassName</code> which defines the StorageClass which contains the names of the bucket provisioner, the object-store and specifies the bucket retention policy.</li> <li> <p><code>additionalConfig</code> is an optional list of key-value pairs used to define attributes specific to the bucket being provisioned by this OBC. This information is typically tuned to a particular bucket provisioner and may limit application portability. Options supported:</p> <ul> <li><code>maxObjects</code>: The maximum number of objects in the bucket as a quota on the user account automatically created for the bucket.</li> <li><code>maxSize</code>: The maximum size of the bucket as a quota on the user account automatically created for the bucket. Please note minimum recommended value is 4K.</li> <li><code>bucketMaxObjects</code>: The maximum number of objects in the bucket as an individual bucket quota. This is useful when the bucket is shared among multiple users.</li> <li><code>bucketMaxSize</code>: The maximum size of the bucket as an individual bucket quota.</li> </ul> </li> </ol>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-claim/#obc-custom-resource-after-bucket-provisioning","title":"OBC Custom Resource after Bucket Provisioning","text":"<pre><code>apiVersion: objectbucket.io/v1alpha1\nkind: ObjectBucketClaim\nmetadata:\n  creationTimestamp: \"2019-10-18T09:54:01Z\"\n  generation: 2\n  name: ceph-bucket\n  namespace: default [1]\n  resourceVersion: \"559491\"\nspec:\n  ObjectBucketName: obc-default-ceph-bucket [2]\n  additionalConfig: null\n  bucketName: photo-booth-c1178d61-1517-431f-8408-ec4c9fa50bee [3]\n  storageClassName: rook-ceph-bucket [4]\nstatus:\n  phase: Bound [5]\n</code></pre> <ol> <li><code>namespace</code> where OBC got created.</li> <li><code>ObjectBucketName</code> generated OB name created using name space and OBC name.</li> <li>the generated (in this case), unique <code>bucket name</code> for the new bucket.</li> <li>name of the storage class from OBC got created.</li> <li>phases of bucket creation:<ul> <li>Pending: the operator is processing the request.</li> <li>Bound: the operator finished processing the request and linked the OBC and OB</li> <li>Released: the OB has been deleted, leaving the OBC unclaimed but unavailable.</li> <li>Failed: not currently set.</li> </ul> </li> </ol>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-claim/#app-pod","title":"App Pod","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\n  namespace: dev-user\nspec:\n  containers:\n  - name: mycontainer\n    image: redis\n    envFrom: [1]\n    - configMapRef:\n        name: ceph-bucket [2]\n    - secretRef:\n        name: ceph-bucket [3]\n</code></pre> <ol> <li>use <code>env:</code> if mapping of the defined key names to the env var names used by the app is needed.</li> <li>makes available to the pod as env variables: <code>BUCKET_HOST</code>, <code>BUCKET_PORT</code>, <code>BUCKET_NAME</code></li> <li>makes available to the pod as env variables: <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code></li> </ol>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-claim/#storageclass","title":"StorageClass","text":"<pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: rook-ceph-bucket\n  labels:\n    aws-s3/object [1]\nprovisioner: rook-ceph.ceph.rook.io/bucket [2]\nparameters: [3]\n  objectStoreName: my-store\n  objectStoreNamespace: rook-ceph\n  bucketName: ceph-bucket [4]\nreclaimPolicy: Delete [5]\n</code></pre> <ol> <li><code>label</code>(optional) here associates this <code>StorageClass</code> to a specific provisioner.</li> <li><code>provisioner</code> responsible for handling <code>OBCs</code> referencing this <code>StorageClass</code>.</li> <li>all <code>parameter</code> required.</li> <li><code>bucketName</code> is required for access to existing buckets but is omitted when provisioning new buckets.     Unlike greenfield provisioning, the brownfield bucket name appears in the <code>StorageClass</code>, not the <code>OBC</code>.</li> <li> <p>rook-ceph provisioner decides how to treat the <code>reclaimPolicy</code> when an <code>OBC</code> is deleted for the bucket. See explanation as specified in Kubernetes</p> <ul> <li>Delete = physically delete the bucket.</li> <li>Retain = do not physically delete the bucket.</li> </ul> </li> </ol>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-notifications/","title":"Object Bucket Notifications","text":"<p>Rook supports the creation of bucket notifications via two custom resources:</p> <ul> <li>a <code>CephBucketNotification</code> is a custom resource the defines: topic, events and filters of a bucket notification, and is described by a Custom Resource Definition (CRD) shown below. Bucket notifications are associated with a bucket by setting labels on the Object Bucket claim (OBC). See the Ceph documentation for detailed information: Bucket Notifications - Ceph Object Gateway - Ceph Documentation.</li> <li>a <code>CephBucketTopic</code> is custom resource which represents a bucket notification topic and is described by a CRD shown below. A bucket notification topic represents an endpoint (or a \"topic\" inside this endpoint) to which bucket notifications could be sent.</li> </ul>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-notifications/#notifications","title":"Notifications","text":"<p>A CephBucketNotification defines what bucket actions trigger the notification and which topic to send notifications to. A CephBucketNotification may also define a filter, based on the object's name and other object attributes. Notifications can be associated with buckets created via ObjectBucketClaims by adding labels to an ObjectBucketClaim with the following format:</p> <pre><code>bucket-notification-&lt;notification name&gt;: &lt;notification name&gt;\n</code></pre> <p>The CephBucketTopic, CephBucketNotification and ObjectBucketClaim must all belong to the same namespace. If a bucket was created manually (not via an ObjectBucketClaim), notifications on this bucket should also be created manually. However, topics in these notifications may reference topics that were created via CephBucketTopic resources.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-notifications/#topics","title":"Topics","text":"<p>A CephBucketTopic represents an endpoint (of types: Kafka, AMQP0.9.1 or HTTP), or a specific resource inside this endpoint (e.g a Kafka or an AMQP topic, or a specific URI in an HTTP server). The CephBucketTopic also holds any additional info needed for a CephObjectStore's RADOS Gateways (RGW) to connect to the endpoint. Topics don't belong to a specific bucket or notification. Notifications from multiple buckets may be sent to the same topic, and one bucket (via multiple CephBucketNotifications) may send notifications to multiple topics.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-notifications/#notification-reliability-and-delivery","title":"Notification Reliability and Delivery","text":"<p>Notifications may be sent synchronously, as part of the operation that triggered them. In this mode, the operation is acknowledged only after the notification is sent to the topic\u2019s configured endpoint, which means that the round trip time of the notification is added to the latency of the operation itself. The original triggering operation will still be considered as successful even if the notification fail with an error, cannot be delivered or times out.</p> <p>Notifications may also be sent asynchronously. They will be committed into persistent storage and then asynchronously sent to the topic\u2019s configured endpoint. In this case, the only latency added to the original operation is of committing the notification to persistent storage. If the notification fail with an error, cannot be delivered or times out, it will be retried until successfully acknowledged.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-notifications/#example","title":"Example","text":""},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-notifications/#cephbuckettopic-custom-resource","title":"CephBucketTopic Custom Resource","text":"<pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBucketTopic\nmetadata:\n  name: my-topic [1]\n  namespace: my-app-space [2]\nspec:\n  objectStoreName: my-store [3]\n  objectStoreNamespace: rook-ceph [4]\n  opaqueData: my@email.com [5]\n  persistent: false [6]\n  endpoint: [7]\n    http: [8]\n      uri: http://my-notification-endpoint:8080\n#     uri: http://my-notification-endpoint:8080/my-topic\n#     uri: https://my-notification-endpoint:8443\n      disableVerifySSL: true [9]\n      sendCloudEvents: false [10]\n#   amqp: [11]\n#     uri: amqp://my-rabbitmq-service:5672\n#     uri: amqp://my-rabbitmq-service:5672/vhost1\n#     uri: amqps://user@password:my-rabbitmq-service:5672\n#     disableVerifySSL: true [12]\n#     ackLevel: broker [13]\n#     exchange: my-exchange [14]\n#   kafka: [15]\n#     uri: kafka://my-kafka-service:9092\n#     disableVerifySSL: true [16]\n#     ackLevel: broker [17]\n#     useSSL: false [18]\n</code></pre> <ol> <li><code>name</code> of the <code>CephBucketTopic</code><ul> <li>In case of AMQP endpoint, the name is used for the AMQP topic (\u201crouting key\u201d for a topic exchange)</li> <li>In case of Kafka endpoint, the name is used as the Kafka topic</li> </ul> </li> <li><code>namespace</code>(optional) of the <code>CephBucketTopic</code>. Should match the namespace of the CephBucketNotification associated with this CephBucketTopic, and the OBC with the label referencing the CephBucketNotification</li> <li><code>objectStoreName</code> is the name of the object store in which the topic should be created. This must be the same object store used for the buckets associated with the notifications referencing this topic.</li> <li><code>objectStoreNamespace</code> is the namespace of the object store in which the topic should be created</li> <li><code>opaqueData</code> (optional) is added to all notifications triggered by a notifications associated with the topic</li> <li><code>persistent</code> (optional) indicates whether notifications to this endpoint are persistent (=asynchronous) or sent synchronously (\u201cfalse\u201d by default)</li> <li><code>endpoint</code> to which to send the notifications to. Exactly one of the endpoints must be defined: <code>http</code>, <code>amqp</code>, <code>kafka</code></li> <li><code>http</code> (optional) hold the spec for an HTTP endpoint. The format of the URI would be: <code>http[s]://&lt;fqdn&gt;[:&lt;port&gt;][/&lt;resource&gt;]</code><ul> <li>port defaults to: 80/443 for HTTP/S accordingly</li> </ul> </li> <li><code>disableVerifySSL</code> indicates whether the RGW is going to verify the SSL certificate of the HTTP server in case HTTPS is used (\"false\" by default)</li> <li><code>sendCloudEvents</code>: (optional) send the notifications with the CloudEvents header. (\"false\" by default)</li> <li><code>amqp</code> (optional) hold the spec for an AMQP endpoint. The format of the URI would be: <code>amqp[s]://[&lt;user&gt;:&lt;password&gt;@]&lt;fqdn&gt;[:&lt;port&gt;][/&lt;vhost&gt;]</code><ul> <li>port defaults to: 5672/5671 for AMQP/S accordingly</li> <li>user/password defaults to: guest/guest</li> <li>user/password may only be provided if HTTPS is used with the RGW. If not, topic creation request will be rejected</li> <li>vhost defaults to: \u201c/\u201d</li> </ul> </li> <li><code>disableVerifySSL</code> (optional) indicates whether the RGW is going to verify the SSL certificate of the AMQP server in case AMQPS is used (\"false\" by default)</li> <li><code>ackLevel</code> (optional) indicates what kind of ack the RGW is waiting for after sending the notifications:<ul> <li>\u201cnone\u201d: message is considered \u201cdelivered\u201d if sent to broker</li> <li>\u201cbroker\u201d: message is considered \u201cdelivered\u201d if acked by broker (default)</li> <li>\u201croutable\u201d: message is considered \u201cdelivered\u201d if broker can route to a consumer</li> </ul> </li> <li><code>exchange</code> in the AMQP broker that would route the notifications. Different topics pointing to the same endpoint must use the same exchange</li> <li><code>kafka</code> (optional) hold the spec for a Kafka endpoint. The format of the URI would be: <code>kafka://[&lt;user&gt;:&lt;password&gt;@]&lt;fqdn&gt;[:&lt;port]</code><ul> <li>port defaults to: 9092</li> <li>user/password may only be provided if HTTPS is used with the RGW. If not, topic creation request will be rejected</li> <li>user/password may only be provided together with <code>useSSL</code>, if not, the connection to the broker would fail</li> </ul> </li> <li><code>disableVerifySSL</code> (optional) indicates whether the RGW is going to verify the SSL certificate of the Kafka server in case <code>useSSL</code> flag is used (\"false\" by default)</li> <li><code>ackLevel</code> (optional) indicates what kind of ack the RGW is waiting for after sending the notifications:<ul> <li>\u201cnone\u201d: message is considered \u201cdelivered\u201d if sent to broker</li> <li>\u201cbroker\u201d: message is considered \u201cdelivered\u201d if acked by broker (default)</li> </ul> </li> <li><code>useSSL</code> (optional) indicates that secure connection will be used for connecting with the broker (\u201cfalse\u201d by default)</li> </ol> <p>Note</p> <p>In case of Kafka and AMQP, the consumer of the notifications is not required to ack the notifications, since the broker persists the messages before delivering them to their final destinations.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-notifications/#cephbucketnotification-custom-resource","title":"CephBucketNotification Custom Resource","text":"<pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBucketNotification\nmetadata:\n  name: my-notification [1]\n  namespace: my-app-space [2]\nspec:\n  topic: my-topic [3]\n  filter: [4]\n    keyFilters: [5]\n      # match objects with keys that start with \"hello\"\n      - name: prefix\n        value: hello\n      # match objects with keys that end with \".png\"\n      - name: suffix\n        value: .png\n      # match objects with keys with only lowercase characters\n      - name: regex\n        value: \"[a-z]*\\\\.*\"\n    metadataFilters: [6]\n      - name: x-amz-meta-color\n        value: blue\n      - name: x-amz-meta-user-type\n        value: free\n    tagFilters: [7]\n      - name: project\n        value: brown\n  # notification apply for any of the events\n  # full list of supported events is here:\n  # https://docs.ceph.com/en/latest/radosgw/s3-notification-compatibility/#event-types\n  events: [8]\n    - s3:ObjectCreated:Put\n    - s3:ObjectCreated:Copy\n</code></pre> <ol> <li><code>name</code> of the <code>CephBucketNotification</code></li> <li><code>namespace</code>(optional) of the <code>CephBucketNotification</code>. Should match the namespace of the CephBucketTopic referenced in [3], and the OBC with the label referencing the CephBucketNotification</li> <li><code>topic</code> to which the notifications should be sent</li> <li><code>filter</code> (optional) holds a list of filtering rules of different types. Only objects that match all the filters will trigger notification sending</li> <li><code>keyFilter</code> (optional) are filters based on the object key. There could be up to 3 key filters defined: <code>prefix</code>, <code>suffix</code> and <code>regex</code></li> <li><code>metadataFilters</code> (optional) are filters based on the object metadata. All metadata fields defined as filters must exists in the object, with the values defined in the filter. Other metadata fields may exist in the object</li> <li><code>tagFilters</code> (optional) are filters based on object tags. All tags defined as filters must exists in the object, with the values defined in the filter. Other tags may exist in the object</li> <li><code>events</code> (optional) is a list of events that should trigger the notifications. By default all events should trigger notifications. Valid Events are:<ul> <li>s3:ObjectCreated:*</li> <li>s3:ObjectCreated:Put</li> <li>s3:ObjectCreated:Post</li> <li>s3:ObjectCreated:Copy</li> <li>s3:ObjectCreated:CompleteMultipartUpload</li> <li>s3:ObjectRemoved:*</li> <li>s3:ObjectRemoved:Delete</li> <li>s3:ObjectRemoved:DeleteMarkerCreated</li> </ul> </li> </ol>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-bucket-notifications/#obc-custom-resource","title":"OBC Custom Resource","text":"<p>For a notifications to be associated with a bucket, a labels must be added to the OBC, indicating the name of the notification. To delete a notification from a bucket the matching label must be removed. When an OBC is deleted, all of the notifications associated with the bucket will be deleted as well.</p> <pre><code>apiVersion: objectbucket.io/v1alpha1\nkind: ObjectBucketClaim\nmetadata:\n  name: ceph-notification-bucket\n  labels:\n    # labels that don't have this structure: bucket-notification-&lt;name&gt; : &lt;name&gt;\n    # are ignored by the operator's bucket notifications provisioning mechanism\n    some-label: some-value\n    # the following label adds notifications to this bucket\n    bucket-notification-my-notification: my-notification\n    bucket-notification-another-notification: another-notification\nspec:\n  generateBucketName: ceph-bkt\n  storageClassName: rook-ceph-delete-bucket\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/","title":"Object Store Multisite","text":"<p>Multisite is a feature of Ceph that allows object stores to replicate their data over multiple Ceph clusters.</p> <p>Multisite also allows object stores to be independent and isolated from other object stores in a cluster.</p> <p>When a ceph-object-store is created without the <code>zone</code> section; a realm, zone group, and zone is created with the same name as the ceph-object-store.</p> <p>Since it is the only ceph-object-store in the realm, the data in the ceph-object-store remain independent and isolated from others on the same cluster.</p> <p>When a ceph-object-store is created with the <code>zone</code> section, the ceph-object-store will join a custom created zone, zone group, and realm each with a different names than its own.</p> <p>This allows the ceph-object-store to replicate its data over multiple Ceph clusters.</p> <p>To review core multisite concepts please read the ceph-multisite design overview.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#prerequisites","title":"Prerequisites","text":"<p>This guide assumes a Rook cluster as explained in the Quickstart.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#creating-object-multisite","title":"Creating Object Multisite","text":"<p>If an admin wants to set up multisite on a Rook Ceph cluster, the following resources must be created:</p> <ol> <li>A realm</li> <li>A zonegroup</li> <li>A zone</li> <li>A ceph object store with the <code>zone</code> section</li> </ol> <p>object-multisite.yaml in the examples directory can be used to create the multisite CRDs.</p> <pre><code>kubectl create -f object-multisite.yaml\n</code></pre> <p>The first zone group created in a realm is the master zone group. The first zone created in a zone group is the master zone.</p> <p>When a non-master zone or non-master zone group is created, the zone group or zone is not in the Ceph Radosgw Multisite Period until an object-store is created in that zone (and zone group).</p> <p>The zone will create the pools for the object-store(s) that are in the zone to use.</p> <p>When one of the multisite CRs (realm, zone group, zone) is deleted the underlying ceph realm/zone group/zone is not deleted, neither are the pools created by the zone. See the \"Multisite Cleanup\" section for more information.</p> <p>For more information on the multisite CRDs, see the related CRDs:</p> <ul> <li>CephObjectRealm</li> <li>CephObjectZoneGroup</li> <li>CephObjectZone</li> </ul>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#pulling-a-realm","title":"Pulling a Realm","text":"<p>If an admin wants to sync data from another cluster, the admin needs to pull a realm on a Rook Ceph cluster from another Rook Ceph (or Ceph) cluster.</p> <p>To begin doing this, the admin needs 2 pieces of information:</p> <ol> <li>An endpoint from the realm being pulled from</li> <li>The access key and the system key of the system user from the realm being pulled from.</li> </ol>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#getting-the-pull-endpoint","title":"Getting the Pull Endpoint","text":"<p>To pull a Ceph realm from a remote Ceph cluster, an <code>endpoint</code> must be added to the CephObjectRealm's <code>pull</code> section in the <code>spec</code>. This endpoint must be from the master zone in the master zone group of that realm.</p> <p>If an admin does not know of an endpoint that fits this criteria, the admin can find such an endpoint on the remote Ceph cluster (via the tool box if it is a Rook Ceph Cluster) by running:</p> <pre><code>$ radosgw-admin zonegroup get --rgw-realm=$REALM_NAME --rgw-zonegroup=$MASTER_ZONEGROUP_NAME\n{\n    ...\n    \"endpoints\": [http://10.17.159.77:80],\n    ...\n}\n</code></pre> <p>A list of endpoints in the master zone group in the master zone is in the <code>endpoints</code> section of the JSON output of the <code>zonegoup get</code> command.</p> <p>This endpoint must also be resolvable from the new Rook Ceph cluster. To test this run the <code>curl</code> command on the endpoint:</p> <pre><code>$ curl -L http://10.17.159.77:80\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ListAllMyBucketsResult xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\"&gt;&lt;Owner&gt;&lt;ID&gt;anonymous&lt;/ID&gt;&lt;DisplayName&gt;&lt;/DisplayName&gt;&lt;/Owner&gt;&lt;Buckets&gt;&lt;/Buckets&gt;&lt;/ListAllMyBucketsResult&gt;\n</code></pre> <p>Finally add the endpoint to the <code>pull</code> section of the CephObjectRealm's spec. The CephObjectRealm should have the same name as the CephObjectRealm/Ceph realm it is pulling from.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectRealm\nmetadata:\n  name: realm-a\n  namespace: rook-ceph\nspec:\n  pull:\n    endpoint: http://10.17.159.77:80\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#getting-realm-access-key-and-secret-key","title":"Getting Realm Access Key and Secret Key","text":"<p>The access key and secret key of the system user are keys that allow other Ceph clusters to pull the realm of the system user.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#getting-the-realm-access-key-and-secret-key-from-the-rook-ceph-cluster","title":"Getting the Realm Access Key and Secret Key from the Rook Ceph Cluster","text":""},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#system-user-for-multisite","title":"System User for Multisite","text":"<p>When an admin creates a ceph-object-realm a system user automatically gets created for the realm with an access key and a secret key.</p> <p>This system user has the name \"$REALM_NAME-system-user\". For the example if realm name is <code>realm-a</code>, then uid for the system user is \"realm-a-system-user\".</p> <p>These keys for the user are exported as a kubernetes secret called \"$REALM_NAME-keys\" (ex: realm-a-keys).</p> <p>This system user used by RGW internally for the data replication.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#getting-keys-from-k8s-secret","title":"Getting keys from k8s secret","text":"<p>To get these keys from the cluster the realm was originally created on, run:</p> <pre><code>kubectl -n $ORIGINAL_CLUSTER_NAMESPACE get secrets realm-a-keys -o yaml &gt; realm-a-keys.yaml\n</code></pre> <p>Edit the <code>realm-a-keys.yaml</code> file, and change the <code>namespace</code> with the namespace that the new Rook Ceph cluster exists in.</p> <p>Then create a kubernetes secret on the pulling Rook Ceph cluster with the same secrets yaml file.</p> <pre><code>kubectl create -f realm-a-keys.yaml\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#getting-the-realm-access-key-and-secret-key-from-a-non-rook-ceph-cluster","title":"Getting the Realm Access Key and Secret Key from a Non Rook Ceph Cluster","text":"<p>The access key and the secret key of the system user can be found in the output of running the following command on a non-rook ceph cluster:</p> <pre><code>radosgw-admin user info --uid=\"realm-a-system-user\"\n</code></pre> <pre><code>{\n    ...\n    \"keys\": [\n        {\n            \"user\": \"realm-a-system-user\"\n            \"access_key\": \"aSw4blZIKV9nKEU5VC0=\"\n            \"secret_key\": \"JSlDXFt5TlgjSV9QOE9XUndrLiI5JEo9YDBsJg==\",\n        }\n    ],\n    ...\n}\n</code></pre> <p>Then base64 encode the each of the keys and create a <code>.yaml</code> file for the Kubernetes secret from the following template.</p> <p>Only the <code>access-key</code>, <code>secret-key</code>, and <code>namespace</code> sections need to be replaced.</p> <pre><code>apiVersion: v1\ndata:\n  access-key: YVN3NGJsWklLVjluS0VVNVZDMD0=\n  secret-key: SlNsRFhGdDVUbGdqU1Y5UU9FOVhVbmRyTGlJNUpFbzlZREJzSmc9PQ==\nkind: Secret\nmetadata:\n  name: realm-a-keys\n  namespace: $NEW_ROOK_CLUSTER_NAMESPACE\ntype: kubernetes.io/rook\n</code></pre> <p>Finally, create a kubernetes secret on the pulling Rook Ceph cluster with the new secrets yaml file.</p> <pre><code>kubectl create -f realm-a-keys.yaml\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#pulling-a-realm-on-a-new-rook-ceph-cluster","title":"Pulling a Realm on a New Rook Ceph Cluster","text":"<p>Once the admin knows the endpoint and the secret for the keys has been created, the admin should create:</p> <ol> <li>A CephObjectRealm matching to the realm on the other Ceph cluster, with an endpoint as described above.</li> <li>A CephObjectZoneGroup matching the master zone group name or the master CephObjectZoneGroup from the cluster the realm was pulled from.</li> <li>A CephObjectZone referring to the CephObjectZoneGroup created above.</li> <li>A CephObjectStore referring to the new CephObjectZone resource.</li> </ol> <p>object-multisite-pull-realm.yaml (with changes) in the examples directory can be used to create the multisite CRDs.</p> <pre><code>kubectl create -f object-multisite-pull-realm.yaml\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#scaling-a-multisite","title":"Scaling a Multisite","text":"<p>Scaling the number of gateways that run the synchronization thread to 2 or more can increase the latency of the replication of each S3 object. The recommended way to scale a multisite configuration is to dissociate the gateway dedicated to the synchronization from gateways that serve clients.</p> <p>The two types of gateways can be deployed by creating two CephObjectStores associated with the same CephObjectZone. The objectstore that deploys the gateway dedicated to the synchronization must have <code>spec.gateway.instances</code> set to <code>1</code>, while the objectstore that deploys the client gateways have multiple replicas and should disable the synchronization thread on the gateways by setting <code>spec.gateway.disableMultisiteSyncTraffic</code> to <code>true</code>.</p> <pre><code>---\napiVersion: ceph.rook.io/v1\nkind: CephObjectStore\nmetadata:\n  name: replication\n  namespace: rook-ceph\nspec:\n  gateway:\n    port: 80\n    instances: 1\n    disableMultisiteSyncTraffic: false\n  zone:\n    name: zone-a\n---\napiVersion: ceph.rook.io/v1\nkind: CephObjectStore\nmetadata:\n  name: clients\n  namespace: rook-ceph\nspec:\n  gateway:\n    port: 80\n    instances: 5\n    disableMultisiteSyncTraffic: true\n  zone:\n    name: zone-a\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#multisite-cleanup","title":"Multisite Cleanup","text":"<p>Multisite configuration must be cleaned up by hand. Deleting a realm/zone group/zone CR will not delete the underlying Ceph realm, zone group, zone, or the pools associated with a zone.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#deleting-and-reconfiguring-the-ceph-object-zone","title":"Deleting and Reconfiguring the Ceph Object Zone","text":"<p>Changes made to the resource's configuration or deletion of the resource are not reflected on the Ceph cluster.</p> <p>When the ceph-object-zone resource is deleted or modified, the zone is not deleted from the Ceph cluster. Zone deletion must be done through the toolbox.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#changing-the-master-zone","title":"Changing the Master Zone","text":"<p>The Rook toolbox can change the master zone in a zone group.</p> <pre><code>radosgw-admin zone modify --rgw-realm=realm-a --rgw-zonegroup=zonegroup-a --rgw-zone=zone-a --master\nradosgw-admin zonegroup modify --rgw-realm=realm-a --rgw-zonegroup=zonegroup-a --master\nradosgw-admin period update --commit --rgw-realm=realm-a --rgw-zonegroup=zonegroup-a --rgw-zone=zone-a\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#deleting-zone","title":"Deleting Zone","text":"<p>The Rook toolbox can modify the Ceph Multisite state via the radosgw-admin command.</p> <p>There are two scenarios possible when deleting a zone. The following commands, run via the toolbox, deletes the zone if there is only one zone in the zone group.</p> <pre><code>radosgw-admin zone delete --rgw-realm=realm-a --rgw-zonegroup=zonegroup-a --rgw-zone=zone-a\nradosgw-admin period update --commit --rgw-realm=realm-a --rgw-zonegroup=zonegroup-a --rgw-zone=zone-a\n</code></pre> <p>In the other scenario, there are more than one zones in a zone group.</p> <p>Care must be taken when changing which zone is the master zone.</p> <p>Please read the following documentation before running the below commands:</p> <p>The following commands, run via toolboxes, remove the zone from the zone group first, then delete the zone.</p> <pre><code>radosgw-admin zonegroup rm --rgw-realm=realm-a --rgw-zonegroup=zonegroup-a --rgw-zone=zone-a\nradosgw-admin period update --commit --rgw-realm=realm-a --rgw-zonegroup=zonegroup-a --rgw-zone=zone-a\nradosgw-admin zone delete --rgw-realm=realm-a --rgw-zonegroup=zonegroup-a --rgw-zone=zone-a\nradosgw-admin period update --commit --rgw-realm=realm-a --rgw-zonegroup=zonegroup-a --rgw-zone=zone-a\n</code></pre> <p>When a zone is deleted, the pools for that zone are not deleted.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#deleting-pools-for-a-zone","title":"Deleting Pools for a Zone","text":"<p>The Rook toolbox can delete pools. Deleting pools should be done with caution.</p> <p>The following documentation on pools should be read before deleting any pools.</p> <p>When a zone is created the following pools are created for each zone:</p> <pre><code>$ZONE_NAME.rgw.control\n$ZONE_NAME.rgw.meta\n$ZONE_NAME.rgw.log\n$ZONE_NAME.rgw.buckets.index\n$ZONE_NAME.rgw.buckets.non-ec\n$ZONE_NAME.rgw.buckets.data\n</code></pre> <p>Here is an example command to delete the .rgw.buckets.data pool for zone-a.</p> <pre><code>ceph osd pool rm zone-a.rgw.buckets.data zone-a.rgw.buckets.data --yes-i-really-really-mean-it\n</code></pre> <p>In this command the pool name must be mentioned twice for the pool to be removed.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#removing-an-object-store-from-a-zone","title":"Removing an Object Store from a Zone","text":"<p>When an object-store (created in a zone) is deleted, the endpoint for that object store is removed from that zone, via</p> <pre><code>kubectl delete -f object-store.yaml\n</code></pre> <p>Removing object store(s) from the master zone of the master zone group should be done with caution. When all of these object-stores are deleted the period cannot be updated and that realm cannot be pulled.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#zone-group-deletion","title":"Zone Group Deletion","text":"<p>Changes made to the resource's configuration or deletion of the resource are not reflected on the Ceph cluster.</p> <p>When the ceph-object-zone group resource is deleted or modified, the zone group is not deleted from the Ceph cluster. Zone Group deletion must be done through the toolbox.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#deleting-a-zone-group","title":"Deleting a Zone Group","text":"<p>The Rook toolbox can modify the Ceph Multisite state via the radosgw-admin command.</p> <p>The following command, run via the toolbox, deletes the zone group.</p> <pre><code>radosgw-admin zonegroup delete --rgw-realm=realm-a --rgw-zonegroup=zonegroup-a\nradosgw-admin period update --commit --rgw-realm=realm-a --rgw-zonegroup=zonegroup-a\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#realm-deletion","title":"Realm Deletion","text":"<p>Changes made to the resource's configuration or deletion of the resource are not reflected on the Ceph cluster.</p> <p>When the ceph-object-realm resource is deleted or modified, the realm is not deleted from the Ceph cluster. Realm deletion must be done via the toolbox.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#deleting-a-realm","title":"Deleting a Realm","text":"<p>The Rook toolbox can modify the Ceph Multisite state via the radosgw-admin command.</p> <p>The following command, run via the toolbox, deletes the realm.</p> <pre><code>radosgw-admin realm rm --rgw-realm=realm-a\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#configure-an-existing-object-store-for-multisite","title":"Configure an Existing Object Store for Multisite","text":"<p>When an object store is configured by Rook, it internally creates a zone, zone group, and realm with the same name as the object store. To enable multisite, you will need to create the corresponding zone, zone group, and realm CRs with the same name as the object store. For example, to create multisite CRs for an object store named <code>my-store</code>:</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectRealm\nmetadata:\n  name: my-store\n  namespace: rook-ceph # namespace:cluster\n---\napiVersion: ceph.rook.io/v1\nkind: CephObjectZoneGroup\nmetadata:\n  name: my-store\n  namespace: rook-ceph # namespace:cluster\nspec:\n  realm: my-store\n---\napiVersion: ceph.rook.io/v1\nkind: CephObjectZone\nmetadata:\n  name: my-store\n  namespace: rook-ceph # namespace:cluster\nspec:\n  zoneGroup: my-store\n  metadataPool:\n    replicated:\n      size: 3\n  dataPool:\n    replicated:\n      size: 3\n  preservePoolsOnDelete: false\n  # recommended to set this value if ingress used for exposing rgw endpoints\n  # customEndpoints:\n  #   - \"http://rgw-a.fqdn\"\n</code></pre> <p>Now modify the existing <code>CephObjectStore</code> CR to exclude pool settings and add a reference to the zone.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectStore\nmetadata:\n  name: my-store\n  namespace: rook-ceph # namespace:cluster\nspec:\n  gateway:\n    port: 80\n    instances: 1\n  zone:\n    name: my-store\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-multisite/#using-custom-names","title":"Using custom names","text":"<p>If names different from the object store need to be set for the realm, zone, or zone group, first rename them in the backend via toolbox pod, then following the procedure above.</p> <pre><code>radosgw-admin realm rename --rgw-realm=my-store --realm-new-name=&lt;new-realm-name&gt;\nradosgw-admin zonegroup rename --rgw-zonegroup=my-store --zonegroup-new-name=&lt;new-zonegroup-name&gt; --rgw-realm=&lt;new-realm-name&gt;\nradosgw-admin zone rename --rgw-zone=my-store --zone-new-name=&lt;new-zone-name&gt;  --rgw-zonegroup=&lt;new-zonegroup-name&gt; --rgw-realm=&lt;new-realm-name&gt;\nradosgw-admin period update --commit\n</code></pre> <p>Important</p> <p>Renaming in the toolbox must be performed before creating the multisite CRs</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-swift/","title":"Object Store with Keystone and Swift","text":"<p>Note</p> <p>The Object Store with Keystone and Swift is currently in experimental mode.</p> <p>Ceph RGW can integrate natively with the Swift API and Keystone via the CephObjectStore CRD. This allows native integration of Rook-operated Ceph RGWs into OpenStack clouds.</p> <p>Note</p> <p>Authentication via the OBC and COSI features is not affected by this configuration.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-swift/#create-a-local-object-store-with-keystone-and-swift","title":"Create a Local Object Store with Keystone and Swift","text":"<p>This example will create a <code>CephObjectStore</code> that starts the RGW service in the cluster providing a Swift API. Using Swift requires the use of OpenStack Keystone as an authentication provider.</p> <p>The OSDs must be located on different nodes, because the <code>failureDomain</code> is set to <code>host</code> and the <code>erasureCoded</code> chunk settings require at least 3 different OSDs (2 <code>dataChunks</code> + 1 <code>codingChunks</code>).</p> <p>More details on the settings available for a <code>CephObjectStore</code> (including the <code>Auth</code> section) can be found in the Object Store CRD document.</p> <p>Set the url in the auth section to point to the keystone service url.</p> <p>Prior to using keystone as authentication provider an admin user for rook to access and configure the keystone admin api is required.</p> <p>The user credentials for this admin user are provided by a secret in the same namespace which is referenced via the <code>serviceUserSecretName</code> property. The secret contains the credentials with names analogue to the environment variables used in an OpenStack <code>openrc</code> file.</p> <p>Note</p> <p>This example requires at least 3 bluestore OSDs, with each OSD located on a different node. This example assumes an existing OpenStack Keystone instance ready to use for authentication.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: usersecret\ndata:\n  OS_AUTH_TYPE: cGFzc3dvcmQ=\n  OS_IDENTITY_API_VERSION: Mw==\n  OS_PASSWORD: c2VjcmV0\n  OS_PROJECT_DOMAIN_NAME: RGVmYXVsdA==\n  OS_PROJECT_NAME: YWRtaW4=\n  OS_USER_DOMAIN_NAME: RGVmYXVsdA==\n  OS_USERNAME: YWRtaW4=\ntype: Opaque\n</code></pre> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectStore\nmetadata:\n  name: my-store\n  namespace: rook-ceph\nspec:\n  metadataPool:\n    failureDomain: host\n    replicated:\n      size: 3\n  dataPool:\n    failureDomain: host\n    erasureCoded:\n      dataChunks: 2\n      codingChunks: 1\n  auth:\n    keystone:\n      acceptedRoles:\n        - admin\n        - member\n        - service\n      implicitTenants: \"swift\"\n      revocationInterval: 1200\n      serviceUserSecretName: usersecret\n      tokenCacheSize: 1000\n      url: https://keystone.rook-ceph.svc/\n  protocols:\n    swift:\n      accountInUrl: true\n      urlPrefix: /swift\n    # note that s3 is enabled by default if protocols.s3.enabled is not explicitly set to false\n  preservePoolsOnDelete: true\n  gateway:\n    sslCertificateRef:\n    port: 80\n    # securePort: 443\n    instances: 1\n</code></pre> <p>After the <code>CephObjectStore</code> is created, the Rook operator will create all the pools and other resources necessary to start the service. This may take a minute to complete.</p> <pre><code>kubectl create -f object.yaml\n</code></pre> <p>The start of the RGW pod(s) confirms that the object store is configured.</p> <pre><code>kubectl -n rook-ceph get pod -l app=rook-ceph-rgw\n</code></pre> <p>The swift service endpoint in OpenStack/Keystone must be created, in order to use the object store in Swift using for example the OpenStack CLI. The endpoint url should be set to the service endpoint of the created rgw instance.</p> <pre><code>openstack service create --name swift object-store\nopenstack endpoint create --region default --enable swift admin https://rook-ceph-rgw-default.rook-ceph.svc/swift/v1\nopenstack endpoint create --region default --enable swift internal https://rook-ceph-rgw-default.rook-ceph.svc/swift/v1\n</code></pre> <p>Afterwards any user which has the rights to access the projects resources (as defined in the OpenStack Keystone instance) can access the object store and create container and objects. Here the username and project are explicitly set to reflect use of the (non-admin) user.</p> <pre><code>export OS_USERNAME=alice\nexport OS_PROJECT=exampleProject\nopenstack container create exampleContainer\n# put /etc/hosts in the new created container\nopenstack object create exampleContainer /etc/hosts\n# retrieve and save the file\nopenstack object save --file /tmp/hosts.saved exampleContainer /etc/hosts\nopenstack object delete exampleContainer /etc/hosts\nopenstack container delete exampleContainer\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-swift/#basic-concepts","title":"Basic concepts","text":"<p>When using Keystone as an authentication provider, Ceph uses the credentials of an admin user (provided in the secret references by <code>serviceUserSecretName</code>) to access Keystone.</p> <p>For each user accessing the object store using Swift, Ceph implicitly creates a user which must be represented in Keystone with an authorized counterpart. Keystone checks for a user of the same name. Based on the name and other parameters ((OpenStack Keystone) project, (OpenStack Keystone) role) Keystone allows or disallows access to a swift container or object. Note that the implicitly created users are creaded in addition to any users that are created through other means, so Keystone authentication is not exclusive.</p> <p>It is not necessary to create any users in OpenStack Keystone (except for the admin user provided in the <code>serviceUserSecretName</code>).</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-swift/#keystone-setup","title":"Keystone setup","text":"<p>Keystone must support the v3-API-Version to be used with Rook. Other API versions are not supported.</p> <p>The admin user and all users accessing the Object store must exist and their authorizations configured accordingly in Keystone.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/ceph-object-swift/#openstack-setup","title":"Openstack setup","text":"<p>To use the Object Store in OpenStack using Swift the Swift service must be set and the endpoint urls for the Swift service created. The example configuration \"Create a Local Object Store with Keystone and Swift\" above contains more details and the corresponding CLI calls.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/cosi/","title":"Container Object Storage Interface (COSI)","text":"<p>The Ceph COSI driver provisions buckets for object storage. This document instructs on enabling the driver and consuming a bucket from a sample application.</p> <p>Note</p> <p>The Ceph COSI driver is currently in experimental mode.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/cosi/#prerequisites","title":"Prerequisites","text":"<p>COSI requires:</p> <ol> <li>A running Rook object store</li> <li>COSI controller</li> </ol> <p>Deploy the COSI controller with these commands:</p> <pre><code>kubectl apply -k github.com/kubernetes-sigs/container-object-storage-interface-api\nkubectl apply -k github.com/kubernetes-sigs/container-object-storage-interface-controller\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/cosi/#ceph-cosi-driver","title":"Ceph COSI Driver","text":"<p>The Ceph COSI driver will be started when the CephCOSIDriver CR is created and when the first CephObjectStore is created.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephCOSIDriver\nmetadata:\n  name: ceph-cosi-driver\n  namespace: rook-ceph\nspec:\n  deploymentStrategy: \"Auto\"\n---\n# The Ceph-COSI driver needs a privileged user for each CephObjectStore\n# in order to provision buckets and users\napiVersion: ceph.rook.io/v1\nkind: CephObjectStoreUser\nmetadata:\n  name: cosi\n  namespace: rook-ceph # rook operator namespace\nspec:\n  displayName: \"cosi user\"\n  store: my-store # name of the CephObjectStore\n  capabilities:\n    bucket: \"*\"\n    user: \"*\"\n</code></pre> <pre><code>cd deploy/examples/cosi\nkubectl create -f cephcosidriver.yaml\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/cosi/#admin-operations","title":"Admin Operations","text":""},{"location":"Storage-Configuration/Object-Storage-RGW/cosi/#create-a-bucketclass-and-bucketaccessclass","title":"Create a BucketClass and BucketAccessClass","text":"<p>The BucketClass and BucketAccessClass are CRDs defined by COSI. The BucketClass defines the storage class for the bucket. The BucketAccessClass defines the access class for the bucket. The BucketClass and BucketAccessClass are defined as below:</p> <pre><code>kind: BucketClass\napiVersion: objectstorage.k8s.io/v1alpha1\nmetadata:\n  name: sample-bcc\ndriverName: rook-ceph.ceph.objectstorage.k8s.io\ndeletionPolicy: Delete\nparameters:\n  objectStoreUserSecretName: rook-ceph-object-user-my-store-cosi\n  objectStoreUserSecretNamespace: rook-ceph\n</code></pre> <pre><code>kind: BucketAccessClass\napiVersion: objectstorage.k8s.io/v1alpha1\nmetadata:\n  name: sample-bac\ndriverName: rook-ceph.ceph.objectstorage.k8s.io\nauthenticationType: KEY\nparameters:\n  objectStoreUserSecretName: rook-ceph-object-user-my-store-cosi\n  objectStoreUserSecretNamespace: rook-ceph\n</code></pre> <pre><code>kubectl create -f bucketclass.yaml -f bucketaccessclass.yaml\n</code></pre> <p>The <code>objectStoreUserSecretName</code> and <code>objectStoreUserSecretNamespace</code> are the name and namespace of the CephObjectStoreUser created in the previous step.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/cosi/#user-operations","title":"User Operations","text":""},{"location":"Storage-Configuration/Object-Storage-RGW/cosi/#create-a-bucket","title":"Create a Bucket","text":"<p>To create a bucket, use the BucketClass to pointing the required object store and then define BucketClaim request as below:</p> <pre><code>kind: BucketClaim\napiVersion: objectstorage.k8s.io/v1alpha1\nmetadata:\n  name: sample-bc\n  namespace: default # any namespace can be used\nspec:\n  bucketClassName: sample-bcc\n  protocols:\n    - s3\n</code></pre> <pre><code>kubectl create -f bucketclaim.yaml\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/cosi/#bucket-access","title":"Bucket Access","text":"<p>Define access to the bucket by creating the BucketAccess resource:</p> <pre><code>kind: BucketAccess\napiVersion: objectstorage.k8s.io/v1alpha1\nmetadata:\n  name: sample-access\n  namespace: default # any namespace can be used\nspec:\n  bucketAccessClassName: sample-bac\n  bucketClaimName: sample-bc\n  protocol: s3\n  # Change to the name of the secret where access details are stored\n  credentialsSecretName: sample-secret-name\n</code></pre> <pre><code>kubectl create -f bucketaccess.yaml\n</code></pre> <p>The secret will be created which contains the access details for the bucket in JSON format in the namespace of BucketAccess:</p> <pre><code>kubectl get secret sample-secret-name -o jsonpath='{.data.BucketInfo}' | base64 -d\n</code></pre> <pre><code>{\n  \"metadata\": {\n    \"name\": \"bc-81733d1a-ac7a-4759-96f3-fbcc07c0cee9\",\n    \"creationTimestamp\": null\n  },\n  \"spec\": {\n    \"bucketName\": \"sample-bcc1fc94b04-6011-45e0-a3d8-b6a093055783\",\n    \"authenticationType\": \"KEY\",\n    \"secretS3\": {\n      \"endpoint\": \"http://rook-ceph-rgw-my-store.rook-ceph.svc:80\",\n      \"region\": \"us-east\",\n      \"accessKeyID\": \"LI2LES8QMR9GB5SZLB02\",\n      \"accessSecretKey\": \"s0WAmcn8N1eIBgNV0mjCwZWQmJiCF4B0SAzbhYCL\"\n    },\n    \"secretAzure\": null,\n    \"protocols\": [\n      \"s3\"\n    ]\n  }\n}\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/cosi/#consuming-the-bucket-via-secret","title":"Consuming the Bucket via secret","text":"<p>To access the bucket from an application pod, mount the secret for accessing the bucket:</p> <pre><code>  volumes:\n  - name: cosi-secrets\n    secret:\n      #  Set the name of the secret from the BucketAccess\n      secretName: sample-secret-name\n  spec:\n    containers:\n    - name: sample-app\n      volumeMounts:\n      - name: cosi-secrets\n        mountPath: /data/cosi\n</code></pre> <p>The Secret will be mounted in the pod in the path: <code>/data/cosi/BucketInfo</code>. The app must parse the JSON object to load the bucket connection details.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/","title":"Object Storage Overview","text":"<p>Object storage exposes an S3 API and or a Swift API to the storage cluster for applications to put and get data.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#prerequisites","title":"Prerequisites","text":"<p>This guide assumes a Rook cluster as explained in the Quickstart.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#configure-an-object-store","title":"Configure an Object Store","text":"<p>Rook can configure the Ceph Object Store for several different scenarios. See each linked section for the configuration details.</p> <ol> <li>Create a local object store with dedicated Ceph pools. This option is recommended if a single object store is required, and is the simplest to get started.</li> <li>Create one or more object stores with shared Ceph pools. This option is recommended when multiple object stores are required.</li> <li>Create one or more object stores with pool placement targets and storage classes. This configuration allows Rook to provide different object placement options to object store clients.</li> <li>Connect to an RGW service in an external Ceph cluster, rather than create a local object store.</li> <li>Configure RGW Multisite to synchronize buckets between object stores in different clusters.</li> </ol> <p>Note</p> <p>Updating the configuration of an object store between these types is not supported.</p> <p>Rook has the ability to either deploy an object store in Kubernetes or to connect to an external RGW service. Most commonly, the object store will be configured in Kubernetes by Rook. Alternatively see the external section to consume an existing Ceph cluster with Rados Gateways from Rook.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#create-a-local-object-store-with-s3","title":"Create a Local Object Store with S3","text":"<p>The below sample will create a <code>CephObjectStore</code> that starts the RGW service in the cluster with an S3 API.</p> <p>Note</p> <p>This sample requires at least 3 OSDs, with each OSD located on a different node.</p> <p>The OSDs must be located on different nodes, because the <code>failureDomain</code> is set to <code>host</code> and the <code>erasureCoded</code> chunk settings require at least 3 different OSDs (2 <code>dataChunks</code> + 1 <code>codingChunks</code>).</p> <p>See the Object Store CRD, for more detail on the settings available for a <code>CephObjectStore</code>.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectStore\nmetadata:\n  name: my-store\n  namespace: rook-ceph\nspec:\n  metadataPool:\n    failureDomain: host\n    replicated:\n      size: 3\n  dataPool:\n    failureDomain: host\n    # For production it is recommended to use more chunks, such as 4+2 or 8+4\n    erasureCoded:\n      dataChunks: 2\n      codingChunks: 1\n  preservePoolsOnDelete: true\n  gateway:\n    # sslCertificateRef:\n    port: 80\n    # securePort: 443\n    instances: 1\n</code></pre> <p>After the <code>CephObjectStore</code> is created, the Rook operator will then create all the pools and other resources necessary to start the service. This may take a minute to complete.</p> <p>Create an object store:</p> <pre><code>kubectl create -f object.yaml\n</code></pre> <p>To confirm the object store is configured, wait for the RGW pod(s) to start:</p> <pre><code>kubectl -n rook-ceph get pod -l app=rook-ceph-rgw\n</code></pre> <p>To consume the object store, continue below in the section to Create a bucket.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#create-local-object-stores-with-shared-pools","title":"Create Local Object Store(s) with Shared Pools","text":"<p>The below sample will create one or more object stores. Shared Ceph pools will be created, which reduces the overhead of additional Ceph pools for each additional object store.</p> <p>Data isolation is enforced between the object stores with the use of Ceph RADOS namespaces. The separate RADOS namespaces do not allow access of the data across object stores.</p> <p>Note</p> <p>This sample requires at least 3 OSDs, with each OSD located on a different node.</p> <p>The OSDs must be located on different nodes, because the <code>failureDomain</code> is set to <code>host</code> and the <code>erasureCoded</code> chunk settings require at least 3 different OSDs (2 <code>dataChunks</code> + 1 <code>codingChunks</code>).</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#shared-pools","title":"Shared Pools","text":"<p>Create the shared pools that will be used by each of the object stores.</p> <p>Note</p> <p>If object stores have been previously created, the first pool below (<code>.rgw.root</code>) does not need to be defined again as it would have already been created with an existing object store. There is only one <code>.rgw.root</code> pool existing to store metadata for all object stores.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\n  name: rgw-root\n  namespace: rook-ceph # namespace:cluster\nspec:\n  name: .rgw.root\n  failureDomain: host\n  replicated:\n    size: 3\n    requireSafeReplicaSize: false\n  parameters:\n    pg_num: \"8\"\n  application: rgw\n---\napiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\n  name: rgw-meta-pool\n  namespace: rook-ceph # namespace:cluster\nspec:\n  failureDomain: host\n  replicated:\n    size: 3\n    requireSafeReplicaSize: false\n  parameters:\n    pg_num: \"8\"\n  application: rgw\n---\napiVersion: ceph.rook.io/v1\nkind: CephBlockPool\nmetadata:\n  name: rgw-data-pool\n  namespace: rook-ceph # namespace:cluster\nspec:\n  failureDomain: osd\n  erasureCoded:\n    # For production it is recommended to use more chunks, such as 4+2 or 8+4\n    dataChunks: 2\n    codingChunks: 1\n  application: rgw\n</code></pre> <p>Create the shared pools:</p> <pre><code>kubectl create -f object-shared-pools.yaml\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#create-each-object-store","title":"Create Each Object Store","text":"<p>After the pools have been created above, create each object store to consume the shared pools.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectStore\nmetadata:\n  name: store-a\n  namespace: rook-ceph # namespace:cluster\nspec:\n  sharedPools:\n    metadataPoolName: rgw-meta-pool\n    dataPoolName: rgw-data-pool\n    preserveRadosNamespaceDataOnDelete: true\n  gateway:\n    # sslCertificateRef:\n    port: 80\n    instances: 1\n</code></pre> <p>Create the object store:</p> <pre><code>kubectl create -f object-a.yaml\n</code></pre> <p>To confirm the object store is configured, wait for the RGW pod(s) to start:</p> <pre><code>kubectl -n rook-ceph get pod -l rgw=store-a\n</code></pre> <p>Additional object stores can be created based on the same shared pools by simply changing the <code>name</code> of the CephObjectStore. In the example manifests folder, two object store examples are provided: <code>object-a.yaml</code> and <code>object-b.yaml</code>.</p> <p>To consume the object store, continue below in the section to Create a bucket. Modify the default example object store name from <code>my-store</code> to the alternate name of the object store such as <code>store-a</code> in this example.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#create-local-object-stores-with-pool-placements","title":"Create Local Object Store(s) with pool placements","text":"<p>Attention</p> <p>This feature is experimental.</p> <p>This section contains a guide on how to configure RGW's pool placement and storage classes with Rook.</p> <p>Object Storage API allows users to override where bucket data will be stored during bucket creation. With <code>&lt;LocationConstraint&gt;</code> parameter in S3 API and <code>X-Storage-Policy</code> header in SWIFT. Similarly, users can override where object data will be stored by setting <code>X-Amz-Storage-Class</code> and <code>X-Object-Storage-Class</code> during object creation.</p> <p>To enable this feature, configure <code>poolPlacements</code> representing a list of possible bucket data locations. Each <code>poolPlacement</code> must have:</p> <ul> <li>a unique <code>name</code> to refer to it in <code>&lt;LocationConstraint&gt;</code> or <code>X-Storage-Policy</code>. Name <code>default-placement</code> is reserved and can be used only if placement also marked as <code>default</code>.</li> <li>optional <code>default</code> flag to use given placement by default, meaning that it will be used if no location constraint is provided. Only one placement in the list can be marked as default.</li> <li><code>dataPoolName</code> and <code>metadataPoolName</code> representing object data and metadata locations. In Rook, these data locations are backed by <code>CephBlockPool</code>. <code>poolPlacements</code> and <code>storageClasses</code> specs refer pools by name. This means that all pools should be defined in advance. Similarly to sharedPools, the same pool can be reused across multiple ObjectStores and/or poolPlacements/storageClasses because of RADOS namespaces. Here, each pool will be namespaced with <code>&lt;object store name&gt;.&lt;placement name&gt;.&lt;pool type&gt;</code> key.</li> <li>optional <code>dataNonECPoolName</code> - extra pool for data that cannot use erasure coding (ex: multi-part uploads). If not set, <code>metadataPoolName</code> will be used.</li> <li>optional list of placement <code>storageClasses</code>. Classes defined per placement, which means that even classes of <code>default</code> placement will be available only within this placement and not others. Each placement will automatically have default storage class named <code>STANDARD</code>. <code>STANDARD</code> class always points to placement <code>dataPoolName</code> and cannot be removed or redefined. Each storage class must have:<ul> <li><code>name</code> (unique within placement). RGW allows arbitrary name for StorageClasses, however some clients/libs insist on AWS names so it is recommended to use one of the valid <code>x-amz-storage-class</code> values for better compatibility: <code>STANDARD | REDUCED_REDUNDANCY | STANDARD_IA | ONEZONE_IA | INTELLIGENT_TIERING | GLACIER | DEEP_ARCHIVE | OUTPOSTS | GLACIER_IR | SNOW | EXPRESS_ONEZONE</code>. See AWS docs.</li> <li><code>dataPoolName</code> - overrides placement data pool when this class is selected by user.</li> </ul> </li> </ul> <p>Example: Configure <code>CephObjectStore</code> with <code>default</code> placement <code>us</code> pools and placement <code>europe</code> pointing to pools in corresponding geographies. These geographical locations are only an example. Placement name can be arbitrary and could reflect the backing pool's replication factor, device class, or failure domain. This example also  defines storage class <code>REDUCED_REDUNDANCY</code> for each placement.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectStore\nmetadata:\n  name: my-store\n  namespace: rook-ceph\nspec:\n  gateway:\n    port: 80\n    instances: 1\n  sharedPools:\n    poolPlacements:\n    - name: us\n      default: true\n      metadataPoolName: \"us-data-pool\"\n      dataPoolName: \"us-meta-pool\"\n      storageClasses:\n      - name: REDUCED_REDUNDANCY\n        dataPoolName: \"us-reduced-pool\"\n    - name: europe\n      metadataPoolName: \"eu-meta-pool\"\n      dataPoolName: \"eu-data-pool\"\n      storageClasses:\n      - name: REDUCED_REDUNDANCY\n        dataPoolName: \"eu-reduced-pool\"\n</code></pre> <p>S3 clients can direct objects into the pools defined in the above. The example below uses the s5cmd CLI tool which is pre-installed in the toolbox pod:</p> <pre><code># make bucket without location constraint -&gt; will use \"us\"\ns5cmd mb s3://bucket1\n\n# put object to bucket1 without storage class -&gt; end up in \"us-data-pool\"\ns5cmd put obj s3://bucket1/obj\n\n# put object to bucket1 with  \"STANDARD\" storage class -&gt; end up in \"us-data-pool\"\ns5cmd put obj s3://bucket1/obj --storage-class=STANDARD\n\n# put object to bucket1 with \"REDUCED_REDUNDANCY\" storage class -&gt; end up in \"us-reduced-pool\"\ns5cmd put obj s3://bucket1/obj --storage-class=REDUCED_REDUNDANCY\n\n\n# make bucket with location constraint europe\ns5cmd mb s3://bucket2 --region=my-store:europe\n\n# put object to bucket2 without storage class -&gt; end up in \"eu-data-pool\"\ns5cmd put obj s3://bucket2/obj\n\n# put object to bucket2 with  \"STANDARD\" storage class -&gt; end up in \"eu-data-pool\"\ns5cmd put obj s3://bucket2/obj --storage-class=STANDARD\n\n# put object to bucket2 with \"REDUCED_REDUNDANCY\" storage class -&gt; end up in \"eu-reduced-pool\"\ns5cmd put obj s3://bucket2/obj --storage-class=REDUCED_REDUNDANCY\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#connect-to-an-external-object-store","title":"Connect to an External Object Store","text":"<p>Rook can connect to existing RGW gateways to work in conjunction with the external mode of the <code>CephCluster</code> CRD. First, create a <code>rgw-admin-ops-user</code> user in the Ceph cluster with the necessary caps:</p> <pre><code>radosgw-admin user create --uid=rgw-admin-ops-user --display-name=\"RGW Admin Ops User\" --caps=\"buckets=*;users=*;usage=read;metadata=read;zone=read\" --rgw-realm=&lt;realm-name&gt; --rgw-zonegroup=&lt;zonegroup-name&gt; --rgw-zone=&lt;zone-name&gt;\n</code></pre> <p>The <code>rgw-admin-ops-user</code> user is required by the Rook operator to manage buckets and users via the admin ops and s3 api. The multisite configuration needs to be specified only if the admin sets up multisite for RGW.</p> <p>Then create a secret with the user credentials:</p> <pre><code>kubectl -n rook-ceph create secret generic --type=\"kubernetes.io/rook\" rgw-admin-ops-user --from-literal=accessKey=&lt;access key of the user&gt; --from-literal=secretKey=&lt;secret key of the user&gt;\n</code></pre> <p>For an external CephCluster, configure Rook to consume external RGW servers with the following:</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectStore\nmetadata:\n  name: external-store\n  namespace: rook-ceph\nspec:\n  gateway:\n    port: 8080\n    externalRgwEndpoints:\n      - ip: 192.168.39.182\n        # hostname: example.com\n</code></pre> <p>See <code>object-external.yaml</code> for a more detailed example.</p> <p>Even though multiple <code>externalRgwEndpoints</code> can be specified, it is best to use a single endpoint. Only the first endpoint in the list will be advertised to any consuming resources like CephObjectStoreUsers, ObjectBucketClaims, or COSI resources. If there are multiple external RGW endpoints, add load balancer in front of them, then use the single load balancer endpoint in the <code>externalRgwEndpoints</code> list.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#object-store-endpoint","title":"Object store endpoint","text":"<p>The CephObjectStore resource <code>status.info</code> contains <code>endpoint</code> (and <code>secureEndpoint</code>) fields, which report the endpoint that can be used to access the object store as a client. This endpoint is also advertised as the default endpoint for CephObjectStoreUsers, ObjectBucketClaims, and Container Object Store Interface (COSI) resources.</p> <p>Each object store also creates a Kubernetes service that can be used as a client endpoint from within the Kubernetes cluster. The DNS name of the service is <code>rook-ceph-rgw-&lt;objectStoreName&gt;.&lt;objectStoreNamespace&gt;.svc</code>. This service DNS name is the default <code>endpoint</code> (and <code>secureEndpoint</code>).</p> <p>For external clusters, the default endpoint is the first <code>spec.gateway.externalRgwEndpoint</code> instead of the service DNS name.</p> <p>The advertised endpoint can be overridden using <code>advertiseEndpoint</code> in the <code>spec.hosting</code> config.</p> <p>Rook always uses the advertised endpoint to perform management operations against the object store. When TLS is enabled, the TLS certificate must always specify the endpoint DNS name to allow secure management operations.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#create-a-bucket","title":"Create a Bucket","text":"<p>Info</p> <p>This document is a guide for creating bucket with an Object Bucket Claim (OBC). To create a bucket with the experimental COSI Driver, see the COSI documentation.</p> <p>Now that the object store is configured, next we need to create a bucket where a client can read and write objects. A bucket can be created by defining a storage class, similar to the pattern used by block and file storage. First, define the storage class that will allow object clients to create a bucket. The storage class defines the object storage system, the bucket retention policy, and other properties required by the administrator. Save the following as <code>storageclass-bucket-delete.yaml</code> (the example is named as such due to the <code>Delete</code> reclaim policy).</p> <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n   name: rook-ceph-bucket\n# Change \"rook-ceph\" provisioner prefix to match the operator namespace if needed\nprovisioner: rook-ceph.ceph.rook.io/bucket\nreclaimPolicy: Delete\nparameters:\n  objectStoreName: my-store\n  objectStoreNamespace: rook-ceph\n</code></pre> <p>If you\u2019ve deployed the Rook operator in a namespace other than <code>rook-ceph</code>, change the prefix in the provisioner to match the namespace you used. For example, if the Rook operator is running in the namespace <code>my-namespace</code> the provisioner value should be <code>my-namespace.ceph.rook.io/bucket</code>.</p> <pre><code>kubectl create -f storageclass-bucket-delete.yaml\n</code></pre> <p>Based on this storage class, an object client can now request a bucket by creating an Object Bucket Claim (OBC). When the OBC is created, the Rook bucket provisioner will create a new bucket. Notice that the OBC references the storage class that was created above. Save the following as <code>object-bucket-claim-delete.yaml</code> (the example is named as such due to the <code>Delete</code> reclaim policy):</p> <pre><code>apiVersion: objectbucket.io/v1alpha1\nkind: ObjectBucketClaim\nmetadata:\n  name: ceph-bucket\nspec:\n  generateBucketName: ceph-bkt\n  storageClassName: rook-ceph-bucket\n</code></pre> <pre><code>kubectl create -f object-bucket-claim-delete.yaml\n</code></pre> <p>Now that the claim is created, the operator will create the bucket as well as generate other artifacts to enable access to the bucket. A secret and ConfigMap are created with the same name as the OBC and in the same namespace. The secret contains credentials used by the application pod to access the bucket. The ConfigMap contains bucket endpoint information and is also consumed by the pod. See the Object Bucket Claim Documentation for more details on the <code>CephObjectBucketClaims</code>.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#client-connections","title":"Client Connections","text":"<p>The following commands extract key pieces of information from the secret and configmap:\"</p> <pre><code>#config-map, secret, OBC will part of default if no specific name space mentioned\nexport AWS_HOST=$(kubectl -n default get cm ceph-bucket -o jsonpath='{.data.BUCKET_HOST}')\nexport PORT=$(kubectl -n default get cm ceph-bucket -o jsonpath='{.data.BUCKET_PORT}')\nexport BUCKET_NAME=$(kubectl -n default get cm ceph-bucket -o jsonpath='{.data.BUCKET_NAME}')\nexport AWS_ACCESS_KEY_ID=$(kubectl -n default get secret ceph-bucket -o jsonpath='{.data.AWS_ACCESS_KEY_ID}' | base64 --decode)\nexport AWS_SECRET_ACCESS_KEY=$(kubectl -n default get secret ceph-bucket -o jsonpath='{.data.AWS_SECRET_ACCESS_KEY}' | base64 --decode)\n</code></pre> <p>If any <code>hosting.dnsNames</code> are set in the <code>CephObjectStore</code> CRD, S3 clients can access buckets in virtual-host-style. Otherwise, S3 clients must be configured to use path-style access.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#consume-the-object-storage","title":"Consume the Object Storage","text":"<p>Now that you have the object store configured and a bucket created, you can consume the object storage from an S3 client.</p> <p>This section will guide you through testing the connection to the <code>CephObjectStore</code> and uploading and downloading from it. Run the following commands after you have connected to the Rook toolbox.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#connection-environment-variables","title":"Connection Environment Variables","text":"<p>To simplify the s3 client commands, you will want to set the four environment variables for use by your client (ie. inside the toolbox). See above for retrieving the variables for a bucket created by an <code>ObjectBucketClaim</code>.</p> <pre><code>export AWS_HOST=&lt;host&gt;\nexport PORT=&lt;port&gt;\nexport AWS_ACCESS_KEY_ID=&lt;accessKey&gt;\nexport AWS_SECRET_ACCESS_KEY=&lt;secretKey&gt;\n</code></pre> <ul> <li><code>Host</code>: The DNS host name where the rgw service is found in the cluster. Assuming you are using the default <code>rook-ceph</code> cluster, it will be <code>rook-ceph-rgw-my-store.rook-ceph.svc</code>.</li> <li><code>Port</code>: The endpoint where the rgw service is listening. Run <code>kubectl -n rook-ceph get svc rook-ceph-rgw-my-store</code>, to get the port.</li> <li><code>Access key</code>: The user's <code>access_key</code> as printed above</li> <li><code>Secret key</code>: The user's <code>secret_key</code> as printed above</li> </ul> <p>The variables for the user generated in this example might be:</p> <pre><code>export AWS_HOST=rook-ceph-rgw-my-store.rook-ceph.svc\nexport PORT=80\nexport AWS_ACCESS_KEY_ID=XEZDB3UJ6X7HVBE7X7MA\nexport AWS_SECRET_ACCESS_KEY=7yGIZON7EhFORz0I40BFniML36D2rl8CQQ5kXU6l\n</code></pre> <p>The access key and secret key can be retrieved as described in the section above on client connections or below in the section creating a user if you are not creating the buckets with an <code>ObjectBucketClaim</code>.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#configure-s5cmd","title":"Configure s5cmd","text":"<p>To test the <code>CephObjectStore</code>, set the object store credentials in the toolbox pod that contains the <code>s5cmd</code> tool.</p> <p>Important</p> <p>The default toolbox.yaml does not contain the s5cmd. The toolbox must be started with the rook operator image (toolbox-operator-image), which does contain s5cmd.</p> <pre><code>kubectl create -f deploy/examples/toolbox-operator-image.yaml\nmkdir ~/.aws\ncat &gt; ~/.aws/credentials &lt;&lt; EOF\n[default]\naws_access_key_id = ${AWS_ACCESS_KEY_ID}\naws_secret_access_key = ${AWS_SECRET_ACCESS_KEY}\nEOF\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#put-or-get-an-object","title":"PUT or GET an object","text":"<p>Upload a file to the newly created bucket</p> <pre><code>echo \"Hello Rook\" &gt; /tmp/rookObj\ns5cmd --endpoint-url http://$AWS_HOST:$PORT cp /tmp/rookObj s3://$BUCKET_NAME\n</code></pre> <p>Download and verify the file from the bucket</p> <pre><code>s5cmd --endpoint-url http://$AWS_HOST:$PORT cp s3://$BUCKET_NAME/rookObj /tmp/rookObj-download\ncat /tmp/rookObj-download\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#monitoring-health","title":"Monitoring health","text":"<p>Rook configures health probes on the deployment created for CephObjectStore gateways. Refer to the CRD document for information about configuring the probes and monitoring the deployment status.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#access-external-to-the-cluster","title":"Access External to the Cluster","text":"<p>Rook sets up the object storage so pods will have access internal to the cluster. If your applications are running outside the cluster, you will need to setup an external service through a <code>NodePort</code>.</p> <p>First, note the service that exposes RGW internal to the cluster. We will leave this service intact and create a new service for external access.</p> <pre><code>$ kubectl -n rook-ceph get service rook-ceph-rgw-my-store\nNAME                     CLUSTER-IP   EXTERNAL-IP   PORT(S)     AGE\nrook-ceph-rgw-my-store   10.3.0.177   &lt;none&gt;        80/TCP      2m\n</code></pre> <p>Save the external service as <code>rgw-external.yaml</code>:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: rook-ceph-rgw-my-store-external\n  namespace: rook-ceph\n  labels:\n    app: rook-ceph-rgw\n    rook_cluster: rook-ceph\n    rook_object_store: my-store\nspec:\n  ports:\n  - name: rgw\n    port: 80\n    protocol: TCP\n    targetPort: 80\n  selector:\n    app: rook-ceph-rgw\n    rook_cluster: rook-ceph\n    rook_object_store: my-store\n  sessionAffinity: None\n  type: NodePort\n</code></pre> <p>Now create the external service.</p> <pre><code>kubectl create -f rgw-external.yaml\n</code></pre> <p>See both rgw services running and notice what port the external service is running on:</p> <pre><code>$ kubectl -n rook-ceph get service rook-ceph-rgw-my-store rook-ceph-rgw-my-store-external\nNAME                              TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE\nrook-ceph-rgw-my-store            ClusterIP   10.104.82.228    &lt;none&gt;        80/TCP         4m\nrook-ceph-rgw-my-store-external   NodePort    10.111.113.237   &lt;none&gt;        80:31536/TCP   39s\n</code></pre> <p>Internally the rgw service is running on port <code>80</code>. The external port in this case is <code>31536</code>. Now you can access the <code>CephObjectStore</code> from anywhere! All you need is the hostname for any machine in the cluster, the external port, and the user credentials.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#create-a-user","title":"Create a User","text":"<p>If you need to create an independent set of user credentials to access the S3 endpoint, create a <code>CephObjectStoreUser</code>. The user will be used to connect to the RGW service in the cluster using the S3 API. The user will be independent of any object bucket claims that you might have created in the earlier instructions in this document.</p> <p>See the Object Store User CRD for more detail on the settings available for a <code>CephObjectStoreUser</code>.</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephObjectStoreUser\nmetadata:\n  name: my-user\n  namespace: rook-ceph\nspec:\n  store: my-store\n  displayName: \"my display name\"\n</code></pre> <p>When the <code>CephObjectStoreUser</code> is created, the Rook operator will then create the RGW user on the specified <code>CephObjectStore</code> and store the Access Key and Secret Key in a kubernetes secret in the same namespace as the <code>CephObjectStoreUser</code>.</p> <pre><code># Create the object store user\nkubectl create -f object-user.yaml\n</code></pre> <pre><code># To confirm the object store user is configured, describe the secret\n$ kubectl -n rook-ceph describe secret rook-ceph-object-user-my-store-my-user\nName:    rook-ceph-object-user-my-store-my-user\nNamespace:  rook-ceph\nLabels:     app=rook-ceph-rgw\n            rook_cluster=rook-ceph\n            rook_object_store=my-store\nAnnotations:  &lt;none&gt;\n\nType: kubernetes.io/rook\n\nData\n====\nAccessKey:  20 bytes\nSecretKey:  40 bytes\n</code></pre> <p>The AccessKey and SecretKey data fields can be mounted in a pod as an environment variable. More information on consuming kubernetes secrets can be found in the K8s secret documentation</p> <p>To directly retrieve the secrets:</p> <pre><code>kubectl -n rook-ceph get secret rook-ceph-object-user-my-store-my-user -o jsonpath='{.data.AccessKey}' | base64 --decode\nkubectl -n rook-ceph get secret rook-ceph-object-user-my-store-my-user -o jsonpath='{.data.SecretKey}' | base64 --decode\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#enable-tls","title":"Enable TLS","text":"<p>TLS is critical for securing object storage data access, and it is assumed as a default by many S3 clients. TLS is enabled for CephObjectStores by configuring <code>gateway</code> options. Set <code>securePort</code>, and give Rook access to a TLS certificate using <code>sslCertificateRef</code>. <code>caBundleRef</code> may be necessary as well to give the deployed gateway (RGW) access to the TLS certificate's CA signing bundle.</p> <p>Ceph RGW only supports a single TLS certificate. If the given TLS certificate is a concatenation of multiple certificates, only the first certificate will be used by the RGW as the server certificate. Therefore, the TLS certificate given must include all endpoints that clients will use for access as subject alternate names (SANs).</p> <p>The CephObjectStore service endpoint must be added as a SAN on the TLS certificate. If it is not possible to add the service DNS name as a SAN on the TLS certificate, set <code>hosting.advertiseEndpoint</code> to a TLS-approved endpoint to help ensure Rook and clients use secure data access.</p> <p>Note</p> <p>OpenShift users can use add <code>service.beta.openshift.io/serving-cert-secret-name</code> as a service annotation instead of using <code>sslCertificateRef</code>.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#virtual-host-style-bucket-access","title":"Virtual host-style Bucket Access","text":"<p>The Ceph Object Gateway supports accessing buckets using virtual host-style addressing, which allows addressing buckets using the bucket name as a subdomain in the endpoint.</p> <p>AWS has deprecated the the alternative path-style addressing mode which is Rook and Ceph's default. As a result, many end-user applications have begun to remove path-style support entirely. Many production clusters will have to enable virtual host-style address.</p> <p>Virtual host-style addressing requires 2 things:</p> <ol> <li>An endpoint that supports wildcard addressing</li> <li>CephObjectStore hosting configuration.</li> </ol> <p>Wildcard addressing can be configured in myriad ways. Some options:</p> <ul> <li>Kubernetes ingress loadbalancer</li> <li>Openshift DNS operator</li> </ul> <p>The minimum recommended <code>hosting</code> configuration is exemplified below. It is important to ensure that Rook advertises the wildcard-addressable endpoint as a priority over the default. TLS is also recommended for security, and the configured TLS certificate should specify the advertise endpoint.</p> <pre><code>spec:\n  ...\n  hosting:\n    advertiseEndpoint:\n      dnsName: my.wildcard.addressable.endpoint.com\n      port: 443\n      useTls: true\n</code></pre> <p>A more complex <code>hosting</code> configuration is exemplified below. In this example, two wildcard-addressable endpoints are available. One is a wildcard-addressable ingress service that is accessible to clients outside of the Kubernetes cluster (<code>s3.ingress.domain.com</code>). The other is a wildcard-addressable Kubernetes cluster service (<code>s3.rook-ceph.svc</code>). The cluster service is the preferred advertise endpoint because the internal service avoids the possibility of the ingress service's router being a bottleneck for S3 client operations.</p> <pre><code>spec:\n  ...\n  hosting:\n    advertiseEndpoint:\n      dnsName: s3.rook-ceph.svc\n      port: 443\n      useTls: true\n  dnsNames:\n    - s3.ingress.domain.com\n</code></pre>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#object-multisite","title":"Object Multisite","text":"<p>Multisite is a feature of Ceph that allows object stores to replicate its data over multiple Ceph clusters.</p> <p>Multisite also allows object stores to be independent and isolated from other object stores in a cluster.</p> <p>For more information on multisite please read the ceph multisite overview for how to run it.</p>"},{"location":"Storage-Configuration/Object-Storage-RGW/object-storage/#using-swift-and-keystone","title":"Using Swift and Keystone","text":"<p>It is possible to access an object store using the Swift API. Using Swift requires the use of OpenStack Keystone as an authentication provider.</p> <p>More information on the use of Swift and Keystone can be found in the document on Object Store with Keystone and Swift.</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-mirroring/","title":"Filesystem Mirroring","text":"<p>Ceph filesystem mirroring is a process of asynchronous replication of snapshots to a remote CephFS file system. Snapshots are synchronized by mirroring snapshot data followed by creating a snapshot with the same name (for a given directory on the remote file system) as the snapshot being synchronized. It is generally useful when planning for Disaster Recovery. Mirroring is for clusters that are geographically distributed and stretching a single cluster is not possible due to high latencies.</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-mirroring/#prerequisites","title":"Prerequisites","text":"<p>This guide assumes you have created a Rook cluster as explained in the main quickstart guide</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-mirroring/#create-the-filesystem-with-mirroring-enabled","title":"Create the Filesystem with Mirroring enabled","text":"<p>The following will enable mirroring on the filesystem:</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephFilesystem\nmetadata:\n  name: myfs\n  namespace: rook-ceph\nspec:\n  metadataPool:\n    failureDomain: host\n    replicated:\n      size: 3\n  dataPools:\n    - name: replicated\n      failureDomain: host\n      replicated:\n        size: 3\n  preserveFilesystemOnDelete: true\n  metadataServer:\n    activeCount: 1\n    activeStandby: true\n  mirroring:\n    enabled: true\n    # list of Kubernetes Secrets containing the peer token\n    # for more details see: https://docs.ceph.com/en/latest/dev/cephfs-mirroring/#bootstrap-peers\n    # Add the secret name if it already exists else specify the empty list here.\n    peers:\n      secretNames:\n        #- secondary-cluster-peer\n    # specify the schedule(s) on which snapshots should be taken\n    # see the official syntax here https://docs.ceph.com/en/latest/cephfs/snap-schedule/#add-and-remove-schedules\n    snapshotSchedules:\n      - path: /\n        interval: 24h # daily snapshots\n        # The startTime should be mentioned in the format YYYY-MM-DDTHH:MM:SS\n        # If startTime is not specified, then by default the start time is considered as midnight UTC.\n        # see usage here https://docs.ceph.com/en/latest/cephfs/snap-schedule/#usage\n        # startTime: 2022-07-15T11:55:00\n    # manage retention policies\n    # see syntax duration here https://docs.ceph.com/en/latest/cephfs/snap-schedule/#add-and-remove-retention-policies\n    snapshotRetention:\n      - path: /\n        duration: \"h 24\"\n</code></pre>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-mirroring/#create-the-cephfs-mirror-daemon","title":"Create the cephfs-mirror daemon","text":"<p>Launch the <code>rook-ceph-fs-mirror</code> pod on the source storage cluster, which deploys the <code>cephfs-mirror</code> daemon in the cluster:</p> <pre><code>kubectl create -f deploy/examples/filesystem-mirror.yaml\n</code></pre> <p>Please refer to Filesystem Mirror CRD for more information.</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-mirroring/#configuring-mirroring-peers","title":"Configuring mirroring peers","text":"<p>Once mirroring is enabled, Rook will by default create its own bootstrap peer token so that it can be used by another cluster. The bootstrap peer token can be found in a Kubernetes Secret. The name of the Secret is present in the Status field of the CephFilesystem CR:</p> <pre><code>status:\n  info:\n    fsMirrorBootstrapPeerSecretName: fs-peer-token-myfs\n</code></pre> <p>This secret can then be fetched like so:</p> <pre><code># kubectl get secret -n rook-ceph fs-peer-token-myfs -o jsonpath='{.data.token}'|base64 -d\neyJmc2lkIjoiOTFlYWUwZGQtMDZiMS00ZDJjLTkxZjMtMTMxMWM5ZGYzODJiIiwiY2xpZW50X2lkIjoicmJkLW1pcnJvci1wZWVyIiwia2V5IjoiQVFEN1psOWZ3V1VGRHhBQWdmY0gyZi8xeUhYeGZDUTU5L1N0NEE9PSIsIm1vbl9ob3N0IjoiW3YyOjEwLjEwMS4xOC4yMjM6MzMwMCx2MToxMC4xMDEuMTguMjIzOjY3ODldIn0=\n</code></pre>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-mirroring/#import-the-token-in-the-destination-cluster","title":"Import the token in the Destination cluster","text":"<p>The decoded secret must be saved in a file before importing.</p> <pre><code># ceph fs snapshot mirror peer_bootstrap import &lt;fs_name&gt; &lt;token file path&gt;\n</code></pre> <p>See the CephFS mirror documentation on how to add a bootstrap peer.</p> <p>Further refer to CephFS mirror documentation to configure a directory for snapshot mirroring.</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-mirroring/#verify-that-the-snapshots-have-synced","title":"Verify that the snapshots have synced","text":"<p>To check the <code>mirror daemon status</code>, please run the following command from the toolbox pod.</p> <p>For example :</p> <pre><code># ceph fs snapshot mirror daemon status | jq\n</code></pre> <pre><code>[\n  {\n    \"daemon_id\": 906790,\n    \"filesystems\": [\n      {\n        \"filesystem_id\": 1,\n        \"name\": \"myfs\",\n        \"directory_count\": 1,\n        \"peers\": [\n          {\n            \"uuid\": \"a24a3366-8130-4d55-aada-95fa9d3ff94d\",\n            \"remote\": {\n              \"client_name\": \"client.mirror\",\n              \"cluster_name\": \"91046889-a6aa-4f74-9fb0-f7bb111666b4\",\n              \"fs_name\": \"myfs\"\n            },\n            \"stats\": {\n              \"failure_count\": 0,\n              \"recovery_count\": 0\n            }\n          }\n        ]\n      }\n    ]\n  }\n]\n</code></pre> <p>Please refer to the <code>--admin-daemon</code> socket commands from the CephFS mirror documentation to verify mirror status and peer synchronization status and run the commands from the <code>rook-ceph-fs-mirror</code> pod:</p> <pre><code># kubectl -n rook-ceph exec -it deploy/rook-ceph-fs-mirror -- bash\n</code></pre> <p>Fetch the <code>ceph-client.fs-mirror</code> daemon admin socket file from the <code>/var/run/ceph</code> directory:</p> <pre><code># ls -lhsa /var/run/ceph/\n</code></pre> <pre><code># ceph --admin-daemon /var/run/ceph/ceph-client.fs-mirror.1.93989418120648.asok fs mirror status myfs@1\n</code></pre> <pre><code>{\n    \"rados_inst\": \"X.X.X.X:0/2286593433\",\n    \"peers\": {\n        \"a24a3366-8130-4d55-aada-95fa9d3ff94d\": {\n            \"remote\": {\n                \"client_name\": \"client.mirror\",\n                \"cluster_name\": \"91046889-a6aa-4f74-9fb0-f7bb111666b4\",\n                \"fs_name\": \"myfs\"\n            }\n        }\n    },\n    \"snap_dirs\": {\n        \"dir_count\": 1\n    }\n}\n</code></pre> <p>For getting <code>peer synchronization status</code>:</p> <pre><code># ceph --admin-daemon /var/run/ceph/ceph-client.fs-mirror.1.93989418120648.asok fs mirror peer status myfs@1 a24a3366-8130-4d55-aada-95fa9d3ff94d\n</code></pre> <pre><code>{\n    \"/volumes/_nogroup/subvol-1\": {\n        \"state\": \"idle\",\n        \"last_synced_snap\": {\n            \"id\": 4,\n            \"name\": \"snap2\"\n        },\n        \"snaps_synced\": 0,\n        \"snaps_deleted\": 0,\n        \"snaps_renamed\": 0\n    }\n}\n</code></pre>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/","title":"Filesystem Storage Overview","text":"<p>A filesystem storage (also named shared filesystem) can be mounted with read/write permission from multiple pods. This may be useful for applications which can be clustered using a shared filesystem.</p> <p>This example runs a shared filesystem for the kube-registry.</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#prerequisites","title":"Prerequisites","text":"<p>This guide assumes you have created a Rook cluster as explained in the main quickstart guide</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#create-the-filesystem","title":"Create the Filesystem","text":"<p>Create the filesystem by specifying the desired settings for the metadata pool, data pools, and metadata server in the <code>CephFilesystem</code> CRD. In this example we create the metadata pool with replication of three and a single data pool with replication of three. For more options, see the documentation on creating shared filesystems.</p> <p>Save this shared filesystem definition as <code>filesystem.yaml</code>:</p> <pre><code>apiVersion: ceph.rook.io/v1\nkind: CephFilesystem\nmetadata:\n  name: myfs\n  namespace: rook-ceph\nspec:\n  metadataPool:\n    replicated:\n      size: 3\n  dataPools:\n    - name: replicated\n      replicated:\n        size: 3\n  preserveFilesystemOnDelete: true\n  metadataServer:\n    activeCount: 1\n    activeStandby: true\n</code></pre> <p>The Rook operator will create all the pools and other resources necessary to start the service. This may take a minute to complete.</p> <pre><code># Create the filesystem\nkubectl create -f filesystem.yaml\n[...]\n</code></pre> <p>To confirm the filesystem is configured, wait for the mds pods to start:</p> <pre><code>$ kubectl -n rook-ceph get pod -l app=rook-ceph-mds\nNAME                                      READY     STATUS    RESTARTS   AGE\nrook-ceph-mds-myfs-7d59fdfcf4-h8kw9       1/1       Running   0          12s\nrook-ceph-mds-myfs-7d59fdfcf4-kgkjp       1/1       Running   0          12s\n</code></pre> <p>To see detailed status of the filesystem, start and connect to the Rook toolbox. A new line will be shown with <code>ceph status</code> for the <code>mds</code> service. In this example, there is one active instance of MDS which is up, with one MDS instance in <code>standby-replay</code> mode in case of failover.</p> <pre><code>$ ceph status\n[...]\n  services:\n    mds: myfs-1/1/1 up {[myfs:0]=mzw58b=up:active}, 1 up:standby-replay\n</code></pre>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#provision-storage","title":"Provision Storage","text":"<p>Before Rook can start provisioning storage, a StorageClass needs to be created based on the filesystem. This is needed for Kubernetes to interoperate with the CSI driver to create persistent volumes.</p> <p>Save this storage class definition as <code>storageclass.yaml</code>:</p> <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: rook-cephfs\n# Change \"rook-ceph\" provisioner prefix to match the operator namespace if needed\nprovisioner: rook-ceph.cephfs.csi.ceph.com\nparameters:\n  # clusterID is the namespace where the rook cluster is running\n  # If you change this namespace, also change the namespace below where the secret namespaces are defined\n  clusterID: rook-ceph\n\n  # CephFS filesystem name into which the volume shall be created\n  fsName: myfs\n\n  # Ceph pool into which the volume shall be created\n  # Required for provisionVolume: \"true\"\n  pool: myfs-replicated\n\n  # The secrets contain Ceph admin credentials. These are generated automatically by the operator\n  # in the same namespace as the cluster.\n  csi.storage.k8s.io/provisioner-secret-name: rook-csi-cephfs-provisioner\n  csi.storage.k8s.io/provisioner-secret-namespace: rook-ceph\n  csi.storage.k8s.io/controller-expand-secret-name: rook-csi-cephfs-provisioner\n  csi.storage.k8s.io/controller-expand-secret-namespace: rook-ceph\n  csi.storage.k8s.io/node-stage-secret-name: rook-csi-cephfs-node\n  csi.storage.k8s.io/node-stage-secret-namespace: rook-ceph\n\nreclaimPolicy: Delete\n</code></pre> <p>If you've deployed the Rook operator in a namespace other than \"rook-ceph\" as is common change the prefix in the provisioner to match the namespace you used. For example, if the Rook operator is running in \"rook-op\" the provisioner value should be \"rook-op.rbd.csi.ceph.com\".</p> <p>Create the storage class.</p> <pre><code>kubectl create -f deploy/examples/csi/cephfs/storageclass.yaml\n</code></pre>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#quotas","title":"Quotas","text":"<p>Attention</p> <p>The CephFS CSI driver uses quotas to enforce the PVC size requested.</p> <p>Only newer kernels support CephFS quotas (kernel version of at least 4.17). If you require quotas to be enforced and the kernel driver does not support it, you can disable the kernel driver and use the FUSE client. This can be done by setting <code>CSI_FORCE_CEPHFS_KERNEL_CLIENT: false</code> in the operator deployment (<code>operator.yaml</code>). However, it is important to know that when the FUSE client is enabled, there is an issue that during upgrade the application pods will be disconnected from the mount and will need to be restarted. See the upgrade guide for more details.</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#consume-the-shared-filesystem-k8s-registry-sample","title":"Consume the Shared Filesystem: K8s Registry Sample","text":"<p>As an example, we will start the kube-registry pod with the shared filesystem as the backing store. Save the following spec as <code>kube-registry.yaml</code>:</p> <pre><code>apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: cephfs-pvc\n  namespace: kube-system\nspec:\n  accessModes:\n  - ReadWriteMany\n  resources:\n    requests:\n      storage: 1Gi\n  storageClassName: rook-cephfs\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: kube-registry\n  namespace: kube-system\n  labels:\n    k8s-app: kube-registry\n    kubernetes.io/cluster-service: \"true\"\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      k8s-app: kube-registry\n  template:\n    metadata:\n      labels:\n        k8s-app: kube-registry\n        kubernetes.io/cluster-service: \"true\"\n    spec:\n      containers:\n      - name: registry\n        image: registry:2\n        imagePullPolicy: Always\n        resources:\n          limits:\n            memory: 100Mi\n        env:\n        # Configuration reference: https://docs.docker.com/registry/configuration/\n        - name: REGISTRY_HTTP_ADDR\n          value: :5000\n        - name: REGISTRY_HTTP_SECRET\n          value: \"Ple4seCh4ngeThisN0tAVerySecretV4lue\"\n        - name: REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY\n          value: /var/lib/registry\n        volumeMounts:\n        - name: image-store\n          mountPath: /var/lib/registry\n        ports:\n        - containerPort: 5000\n          name: registry\n          protocol: TCP\n        livenessProbe:\n          httpGet:\n            path: /\n            port: registry\n        readinessProbe:\n          httpGet:\n            path: /\n            port: registry\n      volumes:\n      - name: image-store\n        persistentVolumeClaim:\n          claimName: cephfs-pvc\n          readOnly: false\n</code></pre> <p>Create the Kube registry deployment:</p> <pre><code>kubectl create -f deploy/examples/csi/cephfs/kube-registry.yaml\n</code></pre> <p>You now have a docker registry which is HA with persistent storage.</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#kernel-version-requirement","title":"Kernel Version Requirement","text":"<p>If the Rook cluster has more than one filesystem and the application pod is scheduled to a node with kernel version older than 4.7, inconsistent results may arise since kernels older than 4.7 do not support specifying filesystem namespaces.</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#consume-the-shared-filesystem-toolbox","title":"Consume the Shared Filesystem: Toolbox","text":"<p>Once you have pushed an image to the registry (see the instructions to expose and use the kube-registry), verify that kube-registry is using the filesystem that was configured above by mounting the shared filesystem in the toolbox pod. See the Direct Filesystem topic for more details.</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#consume-the-shared-filesystem-across-namespaces","title":"Consume the Shared Filesystem across namespaces","text":"<p>A PVC that you create using the <code>rook-cephfs</code> storageClass can be shared between different Pods simultaneously, either read-write or read-only, but is restricted to a single namespace (a PVC is a namespace-scoped resource, so you cannot use it in another one).</p> <p>However there are some use cases where you want to share the content from a CephFS-based PVC among different Pods in different namespaces, for a shared library for example, or a collaboration workspace between applications running in different namespaces.</p> <p>You can do that using the following recipe.</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#shared-volume-creation","title":"Shared volume creation","text":"<ul> <li>In the <code>rook</code> namespace, create a copy of the secret <code>rook-csi-cephfs-node</code>, name it <code>rook-csi-cephfs-node-user</code> .</li> <li>Edit your new secret, changing the name of the keys (keep the value as it is):<ul> <li><code>adminID</code> -&gt; <code>userID</code></li> <li><code>adminKey</code> -&gt; <code>userKey</code></li> </ul> </li> <li>Create the PVC you want to share, for example:</li> </ul> <pre><code>kind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: base-pvc\n  namespace: first-namespace\nspec:\n  accessModes:\n    - ReadWriteMany\n  resources:\n    requests:\n      storage: 100Gi\n  storageClassName: rook-cephfs\n  volumeMode: Filesystem\n</code></pre> <ul> <li>The corresponding PV that is created will have all the necessary info to connect to the CephFS volume (all non-necessary information are removed here):</li> </ul> <pre><code>kind: PersistentVolume\napiVersion: v1\nmetadata:\n  name: pvc-a02dd277-cb26-4c1e-9434-478ebc321e22\n  annotations:\n    pv.kubernetes.io/provisioned-by: rook.cephfs.csi.ceph.com\n  finalizers:\n    - kubernetes.io/pv-protection\nspec:\n  capacity:\n    storage: 100Gi\n  csi:\n    driver: rook.cephfs.csi.ceph.com\n    volumeHandle: &gt;-\n      0001-0011-rook-0000000000000001-8a528de0-e274-11ec-b069-0a580a800213\n    volumeAttributes:\n      clusterID: rook\n      fsName: rook-cephfilesystem\n      storage.kubernetes.io/csiProvisionerIdentity: 1654174264855-8081-rook.cephfs.csi.ceph.com\n      subvolumeName: csi-vol-8a528de0-e274-11ec-b069-0a580a800213\n      subvolumePath: &gt;-\n        /volumes/csi/csi-vol-8a528de0-e274-11ec-b069-0a580a800213/da98fb83-fff3-485a-a0a9-57c227cb67ec\n    nodeStageSecretRef:\n      name: rook-csi-cephfs-node\n      namespace: rook\n    controllerExpandSecretRef:\n      name: rook-csi-cephfs-provisioner\n      namespace: rook\n  accessModes:\n    - ReadWriteMany\n  claimRef:\n    kind: PersistentVolumeClaim\n    namespace: first-namespace\n    name: base-pvc\n    apiVersion: v1\n    resourceVersion: '49728'\n  persistentVolumeReclaimPolicy: Retain\n  storageClassName: rook-cephfs\n  volumeMode: Filesystem\n</code></pre> <ul> <li> <p>On this PV, change the <code>persistentVolumeReclaimPolicy</code> parameter to <code>Retain</code> to avoid it from being deleted when you will delete PVCs. Don't forget to change it back to <code>Delete</code> when you want to remove the shared volume (see full procedure in the next section).</p> </li> <li> <p>Copy the YAML content of the PV, and create a new static PV with the same information and some modifications. From the original YAML, you must:</p> <ul> <li>Modify the original name. To keep track, the best solution is to append to the original name the namespace name where you want your new PV. In this example <code>newnamespace</code>.</li> <li>Modify the volumeHandle. Again append the targeted namespace.</li> <li>Add the <code>staticVolume: \"true\"</code> entry to the volumeAttributes.</li> <li>Add the rootPath entry to the volumeAttributes, with the same content as <code>subvolumePath</code>.</li> <li>In the <code>nodeStageSecretRef</code> section, change the name to point to the secret you created earlier, <code>rook-csi-cephfs-node-user</code>.</li> <li>Remove the unnecessary information before applying the YAML (claimRef, managedFields,...):</li> </ul> </li> </ul> <p>Your YAML should look like this:</p> <pre><code>kind: PersistentVolume\napiVersion: v1\nmetadata:\n  name: pvc-a02dd277-cb26-4c1e-9434-478ebc321e22-newnamespace\nspec:\n  capacity:\n    storage: 100Gi\n  csi:\n    driver: rook.cephfs.csi.ceph.com\n    volumeHandle: &gt;-\n      0001-0011-rook-0000000000000001-8a528de0-e274-11ec-b069-0a580a800213-newnamespace\n    volumeAttributes:\n      clusterID: rook\n      fsName: rook-cephfilesystem\n      storage.kubernetes.io/csiProvisionerIdentity: 1654174264855-8081-rook.cephfs.csi.ceph.com\n      subvolumeName: csi-vol-8a528de0-e274-11ec-b069-0a580a800213\n      subvolumePath: &gt;-\n        /volumes/csi/csi-vol-8a528de0-e274-11ec-b069-0a580a800213/da98fb83-fff3-485a-a0a9-57c227cb67ec\n      rootPath: &gt;-\n        /volumes/csi/csi-vol-8a528de0-e274-11ec-b069-0a580a800213/da98fb83-fff3-485a-a0a9-57c227cb67ec\n      staticVolume: \"true\"\n    nodeStageSecretRef:\n      name: rook-csi-cephfs-node\n      namespace: rook\n  accessModes:\n    - ReadWriteMany\n  persistentVolumeReclaimPolicy: Retain\n  storageClassName: rook-cephfs\n  volumeMode: Filesystem\n</code></pre> <ul> <li>In a new or other namespace, create a new PVC that will use this new PV you created. You simply have to point to it in the <code>volumeName</code> parameter. Make sure you enter the same size as the original PVC!:</li> </ul> <pre><code>kind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: second-pvc\n  namespace: newnamespace\n  finalizers:\n    - kubernetes.io/pvc-protection\nspec:\n  accessModes:\n    - ReadWriteMany\n  resources:\n    requests:\n      storage: 100Gi\n  volumeName: pvc-a02dd277-cb26-4c1e-9434-478ebc321e22-newnamespace\n  storageClassName: rook-cephfs\n  volumeMode: Filesystem\n</code></pre> <p>You have now access to the same CephFS subvolume from different PVCs in different namespaces. Redo the previous steps (copy PV with a new name, create a PVC pointing to it) in each namespace you want to use this subvolume.</p> <p>Note: the new PVCs/PVs we have created are static. Therefore CephCSI does not support snapshots, clones, resizing or delete operations for them. If those operations are required, you must make them on the original PVC.</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#shared-volume-removal","title":"Shared volume removal","text":"<p>As the same CephFS volume is used by different PVCs/PVs, you must proceed very orderly to remove it properly.</p> <ul> <li>Delete the static PVCs in the different namespaces, but keep the original one!</li> <li>Delete the corresponding static PVs that should now have been marked as \"Released\". Again, don't delete the original one yet!</li> <li>Edit the original PV, changing back the <code>persistentVolumeReclaimPolicy</code> from <code>Retain</code> to <code>Delete</code>.</li> <li>Delete the original PVC. It will now properly delete the original PV, as well as the subvolume in CephFS.</li> </ul>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#pending-issue","title":"Pending Issue","text":"<p>Due to this bug, the global mount for a Volume that is mounted multiple times on the same node will not be unmounted. This does not result in any particular problem, apart from polluting the logs with unmount error messages, or having many different mounts hanging if you create and delete many shared PVCs, or you don't really use them.</p> <p>Until this issue is solved, either on the Rook or Kubelet side, you can always manually unmount the unwanted hanging global mounts on the nodes:</p> <ul> <li>Log onto each node where the volume has been mounted.</li> <li>Check for hanging mounts using their <code>volumeHandle</code>.</li> <li>Unmount the unwanted volumes.</li> </ul>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#teardown","title":"Teardown","text":"<p>To clean up all the artifacts created by the filesystem demo:</p> <pre><code>kubectl delete -f kube-registry.yaml\n</code></pre> <p>To delete the filesystem components and backing data, delete the Filesystem CRD.</p> <p>Warning</p> <p>Data will be deleted if preserveFilesystemOnDelete=false.</p> <pre><code>kubectl -n rook-ceph delete cephfilesystem myfs\n</code></pre> <p>Note: If the \"preserveFilesystemOnDelete\" filesystem attribute is set to true, the above command won't delete the filesystem. Recreating the same CRD will reuse the existing filesystem.</p>"},{"location":"Storage-Configuration/Shared-Filesystem-CephFS/filesystem-storage/#advanced-example-erasure-coded-filesystem","title":"Advanced Example: Erasure Coded Filesystem","text":"<p>The Ceph filesystem example can be found here: Ceph Shared Filesystem - Samples - Erasure Coded.</p>"},{"location":"Troubleshooting/ceph-common-issues/","title":"Ceph Common Issues","text":""},{"location":"Troubleshooting/ceph-common-issues/#topics","title":"Topics","text":"<ul> <li>Troubleshooting Techniques<ul> <li>Ceph Tools<ul> <li>Tools in the Rook Toolbox</li> <li>Ceph Commands</li> </ul> </li> </ul> </li> <li>Cluster failing to service requests<ul> <li>Symptoms</li> <li>Investigation</li> <li>Solution</li> </ul> </li> <li>Monitors are the only pods running<ul> <li>Symptoms</li> <li>Investigation<ul> <li>Operator fails to connect to the mon</li> <li>Solution</li> <li>Failing mon pod</li> <li>Solution</li> </ul> </li> </ul> </li> <li>PVCs stay in pending state<ul> <li>Symptoms</li> <li>Investigation<ul> <li>Confirm if there are OSDs</li> <li>OSD Prepare Logs</li> <li>CSI Driver</li> <li>Operator unresponsiveness</li> </ul> </li> <li>Solution</li> </ul> </li> <li>OSD pods are failing to start<ul> <li>Symptoms</li> <li>Investigation</li> <li>Solution</li> </ul> </li> <li>OSD pods are not created on my devices<ul> <li>Symptoms</li> <li>Investigation</li> <li>Solution</li> </ul> </li> <li>Node hangs after reboot<ul> <li>Symptoms</li> <li>Investigation</li> <li>Solution</li> </ul> </li> <li>Using multiple shared filesystem (CephFS) is attempted on a kernel version older than 4.7<ul> <li>Symptoms</li> <li>Solution</li> </ul> </li> <li>Set debug log level for all Ceph daemons</li> <li>Activate log to file for a particular Ceph daemon</li> <li>A worker node using RBD devices hangs up<ul> <li>Symptoms</li> <li>Investigation</li> <li>Solution</li> </ul> </li> <li>Too few PGs per OSD warning is shown<ul> <li>Symptoms</li> <li>Solution</li> </ul> </li> <li>LVM metadata can be corrupted with OSD on LV-backed PVC<ul> <li>Symptoms</li> <li>Solution</li> </ul> </li> <li>OSD prepare job fails due to low aio-max-nr setting</li> <li>Unexpected partitions created<ul> <li>Symptoms</li> <li>Solution<ul> <li>Recover from corruption (v1.6.0-v1.6.7)</li> </ul> </li> </ul> </li> <li>Operator environment variables are ignored<ul> <li>Symptoms</li> <li>Investigation</li> <li>Solution</li> </ul> </li> <li>The cluster is in an unhealthy state or fails to configure when LimitNOFILE=infinity in containerd<ul> <li>Symptoms</li> <li>Solution</li> </ul> </li> </ul> <p>Many of these problem cases are hard to summarize down to a short phrase that adequately describes the problem. Each problem will start with a bulleted list of symptoms. Keep in mind that all symptoms may not apply depending on the configuration of Rook. If the majority of the symptoms are seen there is a fair chance you are experiencing that problem.</p> <p>If after trying the suggestions found on this page and the problem is not resolved, the Rook team is very happy to help you troubleshoot the issues in their Slack channel. Once you have registered for the Rook Slack, proceed to the <code>#ceph</code> channel to ask for assistance.</p> <p>See also the CSI Troubleshooting Guide.</p>"},{"location":"Troubleshooting/ceph-common-issues/#troubleshooting-techniques","title":"Troubleshooting Techniques","text":"<p>There are two main categories of information you will need to investigate issues in the cluster:</p> <ol> <li>Kubernetes status and logs documented here</li> <li>Ceph cluster status (see upcoming Ceph tools section)</li> </ol>"},{"location":"Troubleshooting/ceph-common-issues/#ceph-tools","title":"Ceph Tools","text":"<p>After you verify the basic health of the running pods, next you will want to run Ceph tools for status of the storage components. There are two ways to run the Ceph tools, either in the Rook toolbox or inside other Rook pods that are already running.</p> <ul> <li>Logs on a specific node to find why a PVC is failing to mount</li> <li>See the log collection topic for a script that will help you gather the logs</li> <li>Other artifacts:<ul> <li>The monitors that are expected to be in quorum: <code>kubectl -n &lt;cluster-namespace&gt; get configmap rook-ceph-mon-endpoints -o yaml | grep data</code></li> </ul> </li> </ul>"},{"location":"Troubleshooting/ceph-common-issues/#tools-in-the-rook-toolbox","title":"Tools in the Rook Toolbox","text":"<p>The rook-ceph-tools pod provides a simple environment to run Ceph tools. Once the pod is up and running, connect to the pod to execute Ceph commands to evaluate that current state of the cluster.</p> <pre><code>kubectl -n rook-ceph exec -it $(kubectl -n rook-ceph get pod -l \"app=rook-ceph-tools\" -o jsonpath='{.items[*].metadata.name}') bash\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#ceph-commands","title":"Ceph Commands","text":"<p>Here are some common commands to troubleshoot a Ceph cluster:</p> <ul> <li><code>ceph status</code></li> <li><code>ceph osd status</code></li> <li><code>ceph osd df</code></li> <li><code>ceph osd utilization</code></li> <li><code>ceph osd pool stats</code></li> <li><code>ceph osd tree</code></li> <li><code>ceph pg stat</code></li> </ul> <p>The first two status commands provide the overall cluster health. The normal state for cluster operations is HEALTH_OK, but will still function when the state is in a HEALTH_WARN state. If you are in a WARN state, then the cluster is in a condition that it may enter the HEALTH_ERROR state at which point all disk I/O operations are halted. If a HEALTH_WARN state is observed, then one should take action to prevent the cluster from halting when it enters the HEALTH_ERROR state.</p> <p>There are many Ceph sub-commands to look at and manipulate Ceph objects, well beyond the scope this document. See the Ceph documentation for more details of gathering information about the health of the cluster. In addition, there are other helpful hints and some best practices located in the Advanced Configuration section. Of particular note, there are scripts for collecting logs and gathering OSD information there.</p>"},{"location":"Troubleshooting/ceph-common-issues/#cluster-failing-to-service-requests","title":"Cluster failing to service requests","text":""},{"location":"Troubleshooting/ceph-common-issues/#symptoms","title":"Symptoms","text":"<ul> <li>Execution of the <code>ceph</code> command hangs</li> <li>PersistentVolumes are not being created</li> <li>Large amount of slow requests are blocking</li> <li>Large amount of stuck requests are blocking</li> <li>One or more MONs are restarting periodically</li> </ul>"},{"location":"Troubleshooting/ceph-common-issues/#investigation","title":"Investigation","text":"<p>Create a rook-ceph-tools pod to investigate the current state of Ceph. Here is an example of what one might see. In this case the <code>ceph status</code> command would just hang so a CTRL-C needed to be sent.</p> <pre><code>kubectl -n rook-ceph exec -it deploy/rook-ceph-tools -- ceph status\n\nceph status\n^CCluster connection interrupted or timed out\n</code></pre> <p>Another indication is when one or more of the MON pods restart frequently. Note the 'mon107' that has only been up for 16 minutes in the following output.</p> <pre><code>$ kubectl -n rook-ceph get all -o wide --show-all\nNAME                                 READY     STATUS    RESTARTS   AGE       IP               NODE\npo/rook-ceph-mgr0-2487684371-gzlbq   1/1       Running   0          17h       192.168.224.46   k8-host-0402\npo/rook-ceph-mon107-p74rj            1/1       Running   0          16m       192.168.224.28   k8-host-0402\nrook-ceph-mon1-56fgm                 1/1       Running   0          2d        192.168.91.135   k8-host-0404\nrook-ceph-mon2-rlxcd                 1/1       Running   0          2d        192.168.123.33   k8-host-0403\nrook-ceph-osd-bg2vj                  1/1       Running   0          2d        192.168.91.177   k8-host-0404\nrook-ceph-osd-mwxdm                  1/1       Running   0          2d        192.168.123.31   k8-host-0403\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#solution","title":"Solution","text":"<p>What is happening here is that the MON pods are restarting and one or more of the Ceph daemons are not getting configured with the proper cluster information. This is commonly the result of not specifying a value for <code>dataDirHostPath</code> in your Cluster CRD.</p> <p>The <code>dataDirHostPath</code> setting specifies a path on the local host for the Ceph daemons to store configuration and data. Setting this to a path like <code>/var/lib/rook</code>, reapplying your Cluster CRD and restarting all the Ceph daemons (MON, MGR, OSD, RGW) should solve this problem. After the Ceph daemons have been restarted, it is advisable to restart the rook-tools pod.</p>"},{"location":"Troubleshooting/ceph-common-issues/#monitors-are-the-only-pods-running","title":"Monitors are the only pods running","text":""},{"location":"Troubleshooting/ceph-common-issues/#symptoms_1","title":"Symptoms","text":"<ul> <li>Rook operator is running</li> <li>Either a single mon starts or the mons start very slowly (at least several minutes apart)</li> <li>The crash-collector pods are crashing</li> <li>No mgr, osd, or other daemons are created except the CSI driver</li> </ul>"},{"location":"Troubleshooting/ceph-common-issues/#investigation_1","title":"Investigation","text":"<p>When the operator is starting a cluster, the operator will start one mon at a time and check that they are healthy before continuing to bring up all three mons. If the first mon is not detected healthy, the operator will continue to check until it is healthy. If the first mon fails to start, a second and then a third mon may attempt to start. However, they will never form quorum and the orchestration will be blocked from proceeding.</p> <p>The crash-collector pods will be blocked from starting until the mons have formed quorum the first time.</p> <p>There are several common causes for the mons failing to form quorum:</p> <ul> <li>The operator pod does not have network connectivity to the mon pod(s). The network may be configured incorrectly.</li> <li>One or more mon pods are in running state, but the operator log shows they are not able to form quorum</li> <li>A mon is using configuration from a previous installation. See the cleanup guide     for cleaning the previous cluster.</li> <li>A firewall may be blocking the ports required for the Ceph mons to form quorum. Ensure ports 6789 and 3300 are enabled.     See the Ceph networking guide for more details.</li> <li>There may be MTU mismatch between different networking components. Some networks may be more     susceptible to mismatch than others. If Kubernetes CNI or hosts enable jumbo frames (MTU 9000),     Ceph will use large packets to maximize network bandwidth. If other parts of the networking chain     don't support jumbo frames, this could result in lost or rejected packets unexpectedly.</li> </ul>"},{"location":"Troubleshooting/ceph-common-issues/#operator-fails-to-connect-to-the-mon","title":"Operator fails to connect to the mon","text":"<p>First look at the logs of the operator to confirm if it is able to connect to the mons.</p> <pre><code>kubectl -n rook-ceph logs -l app=rook-ceph-operator\n</code></pre> <p>Likely you will see an error similar to the following that the operator is timing out when connecting to the mon. The last command is <code>ceph mon_status</code>, followed by a timeout message five minutes later.</p> <pre><code>2018-01-21 21:47:32.375833 I | exec: Running command: ceph mon_status --cluster=rook --conf=/var/lib/rook/rook-ceph/rook.config --keyring=/var/lib/rook/rook-ceph/client.admin.keyring --format json --out-file /tmp/442263890\n2018-01-21 21:52:35.370533 I | exec: 2018-01-21 21:52:35.071462 7f96a3b82700  0 monclient(hunting): authenticate timed out after 300\n2018-01-21 21:52:35.071462 7f96a3b82700  0 monclient(hunting): authenticate timed out after 300\n2018-01-21 21:52:35.071524 7f96a3b82700  0 librados: client.admin authentication error (110) Connection timed out\n2018-01-21 21:52:35.071524 7f96a3b82700  0 librados: client.admin authentication error (110) Connection timed out\n[errno 110] error connecting to the cluster\n</code></pre> <p>The error would appear to be an authentication error, but it is misleading. The real issue is a timeout.</p>"},{"location":"Troubleshooting/ceph-common-issues/#solution_1","title":"Solution","text":"<p>If you see the timeout in the operator log, verify if the mon pod is running (see the next section). If the mon pod is running, check the network connectivity between the operator pod and the mon pod. A common issue is that the CNI is not configured correctly.</p> <p>To verify the network connectivity:</p> <ul> <li>Get the endpoint for a mon</li> <li>Curl the mon from the operator pod</li> </ul> <p>For example, this command will curl the first mon from the operator:</p> <pre><code>$ kubectl -n rook-ceph exec deploy/rook-ceph-operator -- curl $(kubectl -n rook-ceph get svc -l app=rook-ceph-mon -o jsonpath='{.items[0].spec.clusterIP}'):3300 2&gt;/dev/null\nceph v2\n</code></pre> <p>If \"ceph v2\" is printed to the console, the connection was successful. If the command does not respond or otherwise fails, the network connection cannot be established.</p>"},{"location":"Troubleshooting/ceph-common-issues/#failing-mon-pod","title":"Failing mon pod","text":"<p>Second we need to verify if the mon pod started successfully.</p> <pre><code>$ kubectl -n rook-ceph get pod -l app=rook-ceph-mon\nNAME                                READY     STATUS               RESTARTS   AGE\nrook-ceph-mon-a-69fb9c78cd-58szd    1/1       CrashLoopBackOff     2          47s\n</code></pre> <p>If the mon pod is failing as in this example, you will need to look at the mon pod status or logs to determine the cause. If the pod is in a crash loop backoff state, you should see the reason by describing the pod.</p> <pre><code># The pod shows a termination status that the keyring does not match the existing keyring\n$ kubectl -n rook-ceph describe pod -l mon=rook-ceph-mon0\n...\n    Last State:    Terminated\n      Reason:    Error\n      Message:    The keyring does not match the existing keyring in /var/lib/rook/rook-ceph-mon0/data/keyring.\n                    You may need to delete the contents of dataDirHostPath on the host from a previous deployment.\n...\n</code></pre> <p>See the solution in the next section regarding cleaning up the <code>dataDirHostPath</code> on the nodes.</p>"},{"location":"Troubleshooting/ceph-common-issues/#solution_2","title":"Solution","text":"<p>This is a common problem reinitializing the Rook cluster when the local directory used for persistence has not been purged. This directory is the <code>dataDirHostPath</code> setting in the cluster CRD and is typically set to <code>/var/lib/rook</code>. To fix the issue you will need to delete all components of Rook and then delete the contents of <code>/var/lib/rook</code> (or the directory specified by <code>dataDirHostPath</code>) on each of the hosts in the cluster. Then when the cluster CRD is applied to start a new cluster, the rook-operator should start all the pods as expected.</p> <p>Caution</p> <p>Deleting the <code>dataDirHostPath</code> folder is destructive to the storage. Only delete the folder if you are trying to permanently purge the Rook cluster.</p> <p>See the Cleanup Guide for more details.</p>"},{"location":"Troubleshooting/ceph-common-issues/#pvcs-stay-in-pending-state","title":"PVCs stay in pending state","text":""},{"location":"Troubleshooting/ceph-common-issues/#symptoms_2","title":"Symptoms","text":"<ul> <li>When you create a PVC based on a rook storage class, it stays pending indefinitely</li> </ul> <p>For the Wordpress example, you might see two PVCs in pending state.</p> <pre><code>$ kubectl get pvc\nNAME             STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS      AGE\nmysql-pv-claim   Pending                                      rook-ceph-block   8s\nwp-pv-claim      Pending                                      rook-ceph-block   16s\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#investigation_2","title":"Investigation","text":"<p>There are two common causes for the PVCs staying in pending state:</p> <ol> <li>There are no OSDs in the cluster</li> <li>The CSI provisioner pod is not running or is not responding to the request to provision the storage</li> </ol>"},{"location":"Troubleshooting/ceph-common-issues/#confirm-if-there-are-osds","title":"Confirm if there are OSDs","text":"<p>To confirm if you have OSDs in your cluster, connect to the Rook Toolbox and run the <code>ceph status</code> command. You should see that you have at least one OSD <code>up</code> and <code>in</code>. The minimum number of OSDs required depends on the <code>replicated.size</code> setting in the pool created for the storage class. In a \"test\" cluster, only one OSD is required (see <code>storageclass-test.yaml</code>). In the production storage class example (<code>storageclass.yaml</code>), three OSDs would be required.</p> <pre><code>$ ceph status\n  cluster:\n    id:     a0452c76-30d9-4c1a-a948-5d8405f19a7c\n    health: HEALTH_OK\n\n  services:\n    mon: 3 daemons, quorum a,b,c (age 11m)\n    mgr: a(active, since 10m)\n    osd: 1 osds: 1 up (since 46s), 1 in (since 109m)\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#osd-prepare-logs","title":"OSD Prepare Logs","text":"<p>If you don't see the expected number of OSDs, let's investigate why they weren't created. On each node where Rook looks for OSDs to configure, you will see an \"osd prepare\" pod.</p> <pre><code>$ kubectl -n rook-ceph get pod -l app=rook-ceph-osd-prepare\nNAME                                 ...  READY   STATUS      RESTARTS   AGE\nrook-ceph-osd-prepare-minikube-9twvk   0/2     Completed   0          30m\n</code></pre> <p>See the section on why OSDs are not getting created to investigate the logs.</p>"},{"location":"Troubleshooting/ceph-common-issues/#csi-driver","title":"CSI Driver","text":"<p>The CSI driver may not be responding to the requests. Look in the logs of the CSI provisioner pod to see if there are any errors during the provisioning.</p> <p>There are two provisioner pods:</p> <pre><code>kubectl -n rook-ceph get pod -l app=csi-rbdplugin-provisioner\n</code></pre> <p>Get the logs of each of the pods. One of them should be the \"leader\" and be responding to requests.</p> <pre><code>kubectl -n rook-ceph logs csi-cephfsplugin-provisioner-d77bb49c6-q9hwq csi-provisioner\n</code></pre> <p>See also the CSI Troubleshooting Guide.</p>"},{"location":"Troubleshooting/ceph-common-issues/#operator-unresponsiveness","title":"Operator unresponsiveness","text":"<p>Lastly, if you have OSDs <code>up</code> and <code>in</code>, the next step is to confirm the operator is responding to the requests. Look in the Operator pod logs around the time when the PVC was created to confirm if the request is being raised. If the operator does not show requests to provision the block image, the operator may be stuck on some other operation. In this case, restart the operator pod to get things going again.</p>"},{"location":"Troubleshooting/ceph-common-issues/#solution_3","title":"Solution","text":"<p>If the \"osd prepare\" logs didn't give you enough clues about why the OSDs were not being created, please review your cluster.yaml configuration. The common misconfigurations include:</p> <ul> <li>If <code>useAllDevices: true</code>, Rook expects to find local devices attached to the nodes. If no devices are found, no OSDs will be created.</li> <li>If <code>useAllDevices: false</code>, OSDs will only be created if <code>deviceFilter</code> is specified.</li> <li>Only local devices attached to the nodes will be configurable by Rook. In other words, the devices must show up under <code>/dev</code>.<ul> <li>The devices must not have any partitions or filesystems on them. Rook will only configure raw devices. Partitions are not yet supported.</li> </ul> </li> </ul>"},{"location":"Troubleshooting/ceph-common-issues/#osd-pods-are-failing-to-start","title":"OSD pods are failing to start","text":""},{"location":"Troubleshooting/ceph-common-issues/#symptoms_3","title":"Symptoms","text":"<ul> <li>OSD pods are failing to start</li> <li>You have started a cluster after tearing down another cluster</li> </ul>"},{"location":"Troubleshooting/ceph-common-issues/#investigation_3","title":"Investigation","text":"<p>When an OSD starts, the device or directory will be configured for consumption. If there is an error with the configuration, the pod will crash and you will see the CrashLoopBackoff status for the pod. Look in the osd pod logs for an indication of the failure.</p> <pre><code>$ kubectl -n rook-ceph logs rook-ceph-osd-fl8fs\n...\n</code></pre> <p>One common case for failure is that you have re-deployed a test cluster and some state may remain from a previous deployment. If your cluster is larger than a few nodes, you may get lucky enough that the monitors were able to start and form quorum. However, now the OSDs pods may fail to start due to the old state. Looking at the OSD pod logs you will see an error about the file already existing.</p> <pre><code>$ kubectl -n rook-ceph logs rook-ceph-osd-fl8fs\n...\n2017-10-31 20:13:11.187106 I | mkfs-osd0: 2017-10-31 20:13:11.186992 7f0059d62e00 -1 bluestore(/var/lib/rook/osd0) _read_fsid unparsable uuid\n2017-10-31 20:13:11.187208 I | mkfs-osd0: 2017-10-31 20:13:11.187026 7f0059d62e00 -1 bluestore(/var/lib/rook/osd0) _setup_block_symlink_or_file failed to create block symlink to /dev/disk/by-partuuid/651153ba-2dfc-4231-ba06-94759e5ba273: (17) File exists\n2017-10-31 20:13:11.187233 I | mkfs-osd0: 2017-10-31 20:13:11.187038 7f0059d62e00 -1 bluestore(/var/lib/rook/osd0) mkfs failed, (17) File exists\n2017-10-31 20:13:11.187254 I | mkfs-osd0: 2017-10-31 20:13:11.187042 7f0059d62e00 -1 OSD::mkfs: ObjectStore::mkfs failed with error (17) File exists\n2017-10-31 20:13:11.187275 I | mkfs-osd0: 2017-10-31 20:13:11.187121 7f0059d62e00 -1  ** ERROR: error creating empty object store in /var/lib/rook/osd0: (17) File exists\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#solution_4","title":"Solution","text":"<p>If the error is from the file that already exists, this is a common problem reinitializing the Rook cluster when the local directory used for persistence has not been purged. This directory is the <code>dataDirHostPath</code> setting in the cluster CRD and is typically set to <code>/var/lib/rook</code>. To fix the issue you will need to delete all components of Rook and then delete the contents of <code>/var/lib/rook</code> (or the directory specified by <code>dataDirHostPath</code>) on each of the hosts in the cluster. Then when the cluster CRD is applied to start a new cluster, the rook-operator should start all the pods as expected.</p>"},{"location":"Troubleshooting/ceph-common-issues/#osd-pods-are-not-created-on-my-devices","title":"OSD pods are not created on my devices","text":""},{"location":"Troubleshooting/ceph-common-issues/#symptoms_4","title":"Symptoms","text":"<ul> <li>No OSD pods are started in the cluster</li> <li>Devices are not configured with OSDs even though specified in the Cluster CRD</li> <li>One OSD pod is started on each node instead of multiple pods for each device</li> </ul>"},{"location":"Troubleshooting/ceph-common-issues/#investigation_4","title":"Investigation","text":"<p>First, ensure that you have specified the devices correctly in the CRD. The Cluster CRD has several ways to specify the devices that are to be consumed by the Rook storage:</p> <ul> <li><code>useAllDevices: true</code>: Rook will consume all devices it determines to be available</li> <li><code>deviceFilter</code>: Consume all devices that match this regular expression</li> <li><code>devices</code>: Explicit list of device names on each node to consume</li> </ul> <p>Second, if Rook determines that a device is not available (has existing partitions or a formatted filesystem), Rook will skip consuming the devices. If Rook is not starting OSDs on the devices you expect, Rook may have skipped it for this reason. To see if a device was skipped, view the OSD preparation log on the node where the device was skipped. Note that it is completely normal and expected for OSD prepare pod to be in the <code>completed</code> state. After the job is complete, Rook leaves the pod around in case the logs need to be investigated.</p> <pre><code># Get the prepare pods in the cluster\n$ kubectl -n rook-ceph get pod -l app=rook-ceph-osd-prepare\nNAME                                   READY     STATUS      RESTARTS   AGE\nrook-ceph-osd-prepare-node1-fvmrp      0/1       Completed   0          18m\nrook-ceph-osd-prepare-node2-w9xv9      0/1       Completed   0          22m\nrook-ceph-osd-prepare-node3-7rgnv      0/1       Completed   0          22m\n</code></pre> <pre><code># view the logs for the node of interest in the \"provision\" container\n$ kubectl -n rook-ceph logs rook-ceph-osd-prepare-node1-fvmrp provision\n[...]\n</code></pre> <p>Here are some key lines to look for in the log:</p> <pre><code># A device will be skipped if Rook sees it has partitions or a filesystem\n2019-05-30 19:02:57.353171 W | cephosd: skipping device sda that is in use\n2019-05-30 19:02:57.452168 W | skipping device \"sdb5\": [\"Used by ceph-disk\"]\n\n# Other messages about a disk being unusable by ceph include:\nInsufficient space (&lt;5GB) on vgs\nInsufficient space (&lt;5GB)\nLVM detected\nHas BlueStore device label\nlocked\nread-only\n\n# A device is going to be configured\n2019-05-30 19:02:57.535598 I | cephosd: device sdc to be configured by ceph-volume\n\n# For each device configured you will see a report printed to the log\n2019-05-30 19:02:59.844642 I |   Type            Path                                                    LV Size         % of device\n2019-05-30 19:02:59.844651 I | ----------------------------------------------------------------------------------------------------\n2019-05-30 19:02:59.844677 I |   [data]          /dev/sdc                                                7.00 GB         100%\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#solution_5","title":"Solution","text":"<p>Either update the CR with the correct settings, or clean the partitions or filesystem from your devices. To clean devices from a previous install see the cleanup guide.</p> <p>After the settings are updated or the devices are cleaned, trigger the operator to analyze the devices again by restarting the operator. Each time the operator starts, it will ensure all the desired devices are configured. The operator does automatically deploy OSDs in most scenarios, but an operator restart will cover any scenarios that the operator doesn't detect automatically.</p> <pre><code># Restart the operator to ensure devices are configured. A new pod will automatically be started when the current operator pod is deleted.\n$ kubectl -n rook-ceph delete pod -l app=rook-ceph-operator\n[...]\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#node-hangs-after-reboot","title":"Node hangs after reboot","text":"<p>This issue is fixed in Rook v1.3 or later.</p>"},{"location":"Troubleshooting/ceph-common-issues/#symptoms_5","title":"Symptoms","text":"<ul> <li>After issuing a <code>reboot</code> command, node never returned online</li> <li>Only a power cycle helps</li> </ul>"},{"location":"Troubleshooting/ceph-common-issues/#investigation_5","title":"Investigation","text":"<p>On a node running a pod with a Ceph persistent volume</p> <pre><code>mount | grep rbd\n# _netdev mount option is absent, also occurs for cephfs\n# OS is not aware PV is mounted over network\n/dev/rbdx on ... (rw,relatime, ..., noquota)\n</code></pre> <p>When the reboot command is issued, network interfaces are terminated before disks are unmounted. This results in the node hanging as repeated attempts to unmount Ceph persistent volumes fail with the following error:</p> <pre><code>libceph: connect [monitor-ip]:6789 error -101\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#solution_6","title":"Solution","text":"<p>The node needs to be drained before reboot. After the successful drain, the node can be rebooted as usual.</p> <p>Because <code>kubectl drain</code> command automatically marks the node as unschedulable (<code>kubectl cordon</code> effect), the node needs to be uncordoned once it's back online.</p> <p>Drain the node:</p> <pre><code>kubectl drain &lt;node-name&gt; --ignore-daemonsets --delete-local-data\n</code></pre> <p>Uncordon the node:</p> <pre><code>kubectl uncordon &lt;node-name&gt;\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#using-multiple-shared-filesystem-cephfs-is-attempted-on-a-kernel-version-older-than-47","title":"Using multiple shared filesystem (CephFS) is attempted on a kernel version older than 4.7","text":""},{"location":"Troubleshooting/ceph-common-issues/#symptoms_6","title":"Symptoms","text":"<ul> <li>More than one shared filesystem (CephFS) has been created in the cluster</li> <li>A pod attempts to mount any other shared filesystem besides the first one that was created</li> <li>The pod incorrectly gets the first filesystem mounted instead of the intended filesystem</li> </ul>"},{"location":"Troubleshooting/ceph-common-issues/#solution_7","title":"Solution","text":"<p>The only solution to this problem is to upgrade your kernel to <code>4.7</code> or higher. This is due to a mount flag added in the kernel version <code>4.7</code> which allows to chose the filesystem by name.</p> <p>For additional info on the kernel version requirement for multiple shared filesystems (CephFS), see Filesystem - Kernel version requirement.</p>"},{"location":"Troubleshooting/ceph-common-issues/#set-debug-log-level-for-all-ceph-daemons","title":"Set debug log level for all Ceph daemons","text":"<p>You can set a given log level and apply it to all the Ceph daemons at the same time. For this, make sure the toolbox pod is running, then determine the level you want (between 0 and 20). You can find the list of all subsystems and their default values in Ceph logging and debug official guide. Be careful when increasing the level as it will produce very verbose logs.</p> <p>Assuming you want a log level of 1, you will run:</p> <pre><code>$ kubectl -n rook-ceph exec deploy/rook-ceph-tools -- set-ceph-debug-level 1\nceph config set global debug_context 1\nceph config set global debug_lockdep 1\n[...]\n</code></pre> <p>Once you are done debugging, you can revert all the debug flag to their default value by running the following:</p> <pre><code>kubectl -n rook-ceph exec deploy/rook-ceph-tools -- set-ceph-debug-level default\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#activate-log-to-file-for-a-particular-ceph-daemon","title":"Activate log to file for a particular Ceph daemon","text":"<p>They are cases where looking at Kubernetes logs is not enough for diverse reasons, but just to name a few:</p> <ul> <li>not everyone is familiar for Kubernetes logging and expects to find logs in traditional directories</li> <li>logs get eaten (buffer limit from the log engine) and thus not requestable from Kubernetes</li> </ul> <p>So for each daemon, <code>dataDirHostPath</code> is used to store logs, if logging is activated. Rook will bindmount <code>dataDirHostPath</code> for every pod. Let's say you want to enable logging for <code>mon.a</code>, but only for this daemon. Using the toolbox or from inside the operator run:</p> <pre><code>ceph config set mon.a log_to_file true\n</code></pre> <p>This will activate logging on the filesystem, you will be able to find logs in <code>dataDirHostPath/$NAMESPACE/log</code>, so typically this would mean <code>/var/lib/rook/rook-ceph/log</code>. You don't need to restart the pod, the effect will be immediate.</p> <p>To disable the logging on file, simply set <code>log_to_file</code> to <code>false</code>.</p>"},{"location":"Troubleshooting/ceph-common-issues/#a-worker-node-using-rbd-devices-hangs-up","title":"A worker node using RBD devices hangs up","text":""},{"location":"Troubleshooting/ceph-common-issues/#symptoms_7","title":"Symptoms","text":"<ul> <li>There is no progress on I/O from/to one of RBD devices (<code>/dev/rbd*</code> or <code>/dev/nbd*</code>).</li> <li>After that, the whole worker node hangs up.</li> </ul>"},{"location":"Troubleshooting/ceph-common-issues/#investigation_6","title":"Investigation","text":"<p>This happens when the following conditions are satisfied.</p> <ul> <li>The problematic RBD device and the corresponding OSDs are co-located.</li> <li>There is an XFS filesystem on top of this device.</li> </ul> <p>In addition, when this problem happens, you can see the following messages in <code>dmesg</code>.</p> <pre><code>$ dmesg\n...\n[51717.039319] INFO: task kworker/2:1:5938 blocked for more than 120 seconds.\n[51717.039361]       Not tainted 4.15.0-72-generic #81-Ubuntu\n[51717.039388] \"echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n...\n</code></pre> <p>It's so-called <code>hung_task</code> problem and means that there is a deadlock in the kernel. For more detail, please refer to the corresponding issue comment.</p>"},{"location":"Troubleshooting/ceph-common-issues/#solution_8","title":"Solution","text":"<p>This problem will be solve by the following two fixes.</p> <ul> <li>Linux kernel: A minor feature that is introduced by this commit. It will be included in Linux v5.6.</li> <li>Ceph: A fix that uses the above-mentioned kernel's feature. The Ceph community will probably discuss this fix after releasing Linux v5.6.</li> </ul> <p>You can bypass this problem by using ext4 or any other filesystems rather than XFS. Filesystem type can be specified with <code>csi.storage.k8s.io/fstype</code> in StorageClass resource.</p>"},{"location":"Troubleshooting/ceph-common-issues/#too-few-pgs-per-osd-warning-is-shown","title":"Too few PGs per OSD warning is shown","text":""},{"location":"Troubleshooting/ceph-common-issues/#symptoms_8","title":"Symptoms","text":"<ul> <li><code>ceph status</code> shows \"too few PGs per OSD\" warning as follows.</li> </ul> <pre><code>$ ceph status\n  cluster:\n    id:     fd06d7c3-5c5c-45ca-bdea-1cf26b783065\n    health: HEALTH_WARN\n            too few PGs per OSD (16 &lt; min 30)\n[...]\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#solution_9","title":"Solution","text":"<p>The meaning of this warning is written in the document. However, in many cases it is benign. For more information, please see the blog entry. Please refer to Configuring Pools if you want to know the proper <code>pg_num</code> of pools and change these values.</p>"},{"location":"Troubleshooting/ceph-common-issues/#lvm-metadata-can-be-corrupted-with-osd-on-lv-backed-pvc","title":"LVM metadata can be corrupted with OSD on LV-backed PVC","text":""},{"location":"Troubleshooting/ceph-common-issues/#symptoms_9","title":"Symptoms","text":"<p>There is a critical flaw in OSD on LV-backed PVC. LVM metadata can be corrupted if both the host and OSD container modify it simultaneously. For example, the administrator might modify it on the host, while the OSD initialization process in a container could modify it too. In addition, if <code>lvmetad</code> is running, the possibility of occurrence gets higher. In this case, the change of LVM metadata in OSD container is not reflected to LVM metadata cache in host for a while.</p> <p>If you still decide to configure an OSD on LVM, please keep the following in mind to reduce the probability of this issue.</p>"},{"location":"Troubleshooting/ceph-common-issues/#solution_10","title":"Solution","text":"<ul> <li>Disable <code>lvmetad.</code></li> <li>Avoid configuration of LVs from the host. In addition, don't touch the VGs and physical volumes that back these LVs.</li> <li>Avoid incrementing the <code>count</code> field of <code>storageClassDeviceSets</code> and create a new LV that backs an OSD simultaneously.</li> </ul> <p>You can know whether the above-mentioned tag exists with the command: <code>sudo lvs -o lv_name,lv_tags</code>. If the <code>lv_tag</code> field is empty in an LV corresponding to the OSD lv_tags, this OSD encountered the problem. In this case, please retire this OSD or replace with other new OSD before restarting.</p> <p>This problem doesn't happen in newly created LV-backed PVCs because OSD container doesn't modify LVM metadata anymore. The existing lvm mode OSDs work continuously even thought upgrade your Rook. However, using the raw mode OSDs is recommended because of the above-mentioned problem. You can replace the existing OSDs with raw mode OSDs by retiring them and adding new OSDs one by one. See the documents Remove an OSD and Add an OSD on a PVC.</p>"},{"location":"Troubleshooting/ceph-common-issues/#osd-prepare-job-fails-due-to-low-aio-max-nr-setting","title":"OSD prepare job fails due to low aio-max-nr setting","text":"<p>If the Kernel is configured with a low aio-max-nr setting, the OSD prepare job might fail with the following error:</p> <pre><code>exec: stderr: 2020-09-17T00:30:12.145+0000 7f0c17632f40 -1 bdev(0x56212de88700 /var/lib/ceph/osd/ceph-0//block) _aio_start io_setup(2) failed with EAGAIN; try increasing /proc/sys/fs/aio-max-nr\n</code></pre> <p>To overcome this, you need to increase the value of <code>fs.aio-max-nr</code> of your sysctl configuration (typically <code>/etc/sysctl.conf</code>). You can do this with your favorite configuration management system.</p> <p>Alternatively, you can have a DaemonSet to apply the configuration for you on all your nodes.</p>"},{"location":"Troubleshooting/ceph-common-issues/#unexpected-partitions-created","title":"Unexpected partitions created","text":""},{"location":"Troubleshooting/ceph-common-issues/#symptoms_10","title":"Symptoms","text":"<p>Users running Rook versions v1.6.0-v1.6.7 may observe unwanted OSDs on partitions that appear unexpectedly and seemingly randomly, which can corrupt existing OSDs.</p> <p>Unexpected partitions are created on host disks that are used by Ceph OSDs. This happens more often on SSDs than HDDs and usually only on disks that are 875GB or larger. Many tools like <code>lsblk</code>, <code>blkid</code>, <code>udevadm</code>, and <code>parted</code> will not show a partition table type for the partition. Newer versions of <code>blkid</code> are generally able to recognize the type as \"atari\".</p> <p>The underlying issue causing this is Atari partition (sometimes identified as AHDI) support in the Linux kernel. Atari partitions have very relaxed specifications compared to other partition types, and it is relatively easy for random data written to a disk to appear as an Atari partition to the Linux kernel. Ceph's Bluestore OSDs have an anecdotally high probability of writing data on to disks that can appear to the kernel as an Atari partition.</p> <p>Below is an example of <code>lsblk</code> output from a node where phantom Atari partitions are present. Note that <code>sdX1</code> is never present for the phantom partitions, and <code>sdX2</code> is 48G on all disks. <code>sdX3</code> is a variable size and may not always be present. It is possible for <code>sdX4</code> to appear, though it is an anecdotally rare event.</p> <pre><code># lsblk\nNAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\nsdb      8:16   0     3T  0 disk\n\u251c\u2500sdb2   8:18   0    48G  0 part\n\u2514\u2500sdb3   8:19   0   6.1M  0 part\nsdc      8:32   0     3T  0 disk\n\u251c\u2500sdc2   8:34   0    48G  0 part\n\u2514\u2500sdc3   8:35   0   6.2M  0 part\nsdd      8:48   0     3T  0 disk\n\u251c\u2500sdd2   8:50   0    48G  0 part\n\u2514\u2500sdd3   8:51   0   6.3M  0 part\n</code></pre> <p>You can see GitHub rook/rook - Issue 7940 unexpected partition on disks &gt;= 1TB (atari partitions) for more detailed information and discussion.</p>"},{"location":"Troubleshooting/ceph-common-issues/#solution_11","title":"Solution","text":""},{"location":"Troubleshooting/ceph-common-issues/#recover-from-corruption-v160-v167","title":"Recover from corruption (v1.6.0-v1.6.7)","text":"<p>If you are using Rook v1.6, you must first update to v1.6.8 or higher to avoid further incidents of OSD corruption caused by these Atari partitions.</p> <p>An old workaround suggested using <code>deviceFilter: ^sd[a-z]+$</code>, but this still results in unexpected partitions. Rook will merely stop creating new OSDs on the partitions. It does not fix a related issue that <code>ceph-volume</code> that is unaware of the Atari partition problem. Users who used this workaround are still at risk for OSD failures in the future.</p> <p>To resolve the issue, immediately update to v1.6.8 or higher. After the update, no corruption should occur on OSDs created in the future. Next, to get back to a healthy Ceph cluster state, focus on one corrupted disk at a time and remove all OSDs on each corrupted disk one disk at a time.</p> <p>As an example, you may have <code>/dev/sdb</code> with two unexpected partitions (<code>/dev/sdb2</code> and <code>/dev/sdb3</code>) as well as a second corrupted disk <code>/dev/sde</code> with one unexpected partition (<code>/dev/sde2</code>).</p> <ol> <li>First, remove the OSDs associated with <code>/dev/sdb</code>, <code>/dev/sdb2</code>, and <code>/dev/sdb3</code>. There might be     only one, or up to 3 OSDs depending on how your system was affected. Again see the     OSD management doc.</li> <li>Use <code>dd</code> to wipe the first sectors of the partitions followed by the disk itself. E.g.,<ul> <li><code>dd if=/dev/zero of=/dev/sdb2 bs=1M</code></li> <li><code>dd if=/dev/zero of=/dev/sdb3 bs=1M</code></li> <li><code>dd if=/dev/zero of=/dev/sdb bs=1M</code></li> </ul> </li> <li>Then wipe clean <code>/dev/sdb</code> to prepare it for a new OSD.     See the teardown document for details.</li> <li>After this, scale up the Rook operator to deploy a new OSD to <code>/dev/sdb</code>. This will allow Ceph to     use <code>/dev/sdb</code> for data recovery and replication while the next OSDs are removed.</li> <li>Now Repeat steps 1-4 for <code>/dev/sde</code> and <code>/dev/sde2</code>, and continue for any other corrupted disks.</li> </ol> <p>If your Rook cluster does not have any critical data stored in it, it may be simpler to uninstall Rook completely and redeploy with v1.6.8 or higher.</p>"},{"location":"Troubleshooting/ceph-common-issues/#operator-environment-variables-are-ignored","title":"Operator environment variables are ignored","text":""},{"location":"Troubleshooting/ceph-common-issues/#symptoms_11","title":"Symptoms","text":"<p>Configuration settings passed as environment variables do not take effect as expected. For example, the discover daemonset is not created, even though <code>ROOK_ENABLE_DISCOVERY_DAEMON=\"true\"</code> is set.</p>"},{"location":"Troubleshooting/ceph-common-issues/#investigation_7","title":"Investigation","text":"<p>Inspect the <code>rook-ceph-operator-config</code> ConfigMap for conflicting settings. The ConfigMap takes precedence over the environment. The ConfigMap must exist, even if all actual configuration is supplied through the environment.</p> <p>Look for lines with the <code>op-k8sutil</code> prefix in the operator logs. These lines detail the final values, and source, of the different configuration variables.</p> <p>Verify that both of the following messages are present in the operator logs:</p> <pre><code>rook-ceph-operator-config-controller successfully started\nrook-ceph-operator-config-controller done reconciling\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#solution_12","title":"Solution","text":"<p>If it does not exist, create an empty ConfigMap:</p> <pre><code>kind: ConfigMap\napiVersion: v1\nmetadata:\n  name: rook-ceph-operator-config\n  namespace: rook-ceph # namespace:operator\ndata: {}\n</code></pre> <p>If the ConfigMap exists, remove any keys that you wish to configure through the environment.</p>"},{"location":"Troubleshooting/ceph-common-issues/#the-cluster-is-in-an-unhealthy-state-or-fails-to-configure-when-limitnofileinfinity-in-containerd","title":"The cluster is in an unhealthy state or fails to configure when LimitNOFILE=infinity in containerd","text":""},{"location":"Troubleshooting/ceph-common-issues/#symptoms_12","title":"Symptoms","text":"<p>When trying to create a new deployment, Ceph mons keep crashing and the cluster fails to configure or remains in an unhealthy state. The nodes' CPUs are stuck at 100%.</p> <pre><code>NAME        DATADIRHOSTPATH   MONCOUNT   AGE    PHASE   MESSAGE                                    HEALTH       EXTERNAL   FSID\nrook-ceph   /var/lib/rook      3         4m6s   Ready   Failed to configure ceph cluster           HEALTH_ERR\n</code></pre>"},{"location":"Troubleshooting/ceph-common-issues/#solution_13","title":"Solution","text":"<p>Before systemd v240, systemd would leave <code>fs.nr_open</code> as-is because it had no mechanism to set a safe upper limit for it. The kernel hard-coded value for the default number of max open files is 1048576. Starting from systemd v240, when <code>LimitNOFILE=infinity</code> is specified in the containerd.service configuration, this value will typically be set to ~1073741816 (INT_MAX for x86_64 divided by two).</p> <p>To fix this, set LimitNOFILE in the systemd service configuration to 1048576.</p> <p>Create an override.conf file with the new LimitNOFILE value:</p> <pre><code>$ vim /etc/systemd/system/containerd.service.d/override.conf\n[Service]\nLimitNOFILE=1048576\n</code></pre> <p>Reload systemd manager configuration, restart containerd and restart all monitors deployments:</p> <pre><code>$ systemctl daemon-reload\n$ systemctl restart containerd\n$ kubectl rollout restart deployment rook-ceph-mon-a rook-ceph-mon-b rook-ceph-mon-c -n rook-ceph\n</code></pre>"},{"location":"Troubleshooting/ceph-csi-common-issues/","title":"CSI Common Issues","text":"<p>Issues when provisioning volumes with the Ceph CSI driver can happen for many reasons such as:</p> <ul> <li>Network connectivity between CSI pods and ceph</li> <li>Cluster health issues</li> <li>Slow operations</li> <li>Kubernetes issues</li> <li>Ceph-CSI configuration or bugs</li> </ul> <p>The following troubleshooting steps can help identify a number of issues.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#block-rbd","title":"Block (RBD)","text":"<p>If you are mounting block volumes (usually RWO), these are referred to as <code>RBD</code> volumes in Ceph. See the sections below for RBD if you are having block volume issues.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#shared-filesystem-cephfs","title":"Shared Filesystem (CephFS)","text":"<p>If you are mounting shared filesystem volumes (usually RWX), these are referred to as <code>CephFS</code> volumes in Ceph. See the sections below for CephFS if you are having filesystem volume issues.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#network-connectivity","title":"Network Connectivity","text":"<p>The Ceph monitors are the most critical component of the cluster to check first. Retrieve the mon endpoints from the services:</p> <pre><code>$ kubectl -n rook-ceph get svc -l app=rook-ceph-mon\nNAME              TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE\nrook-ceph-mon-a   ClusterIP   10.104.165.31   &lt;none&gt;        6789/TCP,3300/TCP   18h\nrook-ceph-mon-b   ClusterIP   10.97.244.93    &lt;none&gt;        6789/TCP,3300/TCP   21s\nrook-ceph-mon-c   ClusterIP   10.99.248.163   &lt;none&gt;        6789/TCP,3300/TCP   8s\n</code></pre> <p>If host networking is enabled in the CephCluster CR, you will instead need to find the node IPs for the hosts where the mons are running.</p> <p>The <code>clusterIP</code> is the mon IP and <code>3300</code> is the port that will be used by Ceph-CSI to connect to the ceph cluster. These endpoints must be accessible by all clients in the cluster, including the CSI driver.</p> <p>If you are seeing issues provisioning the PVC then you need to check the network connectivity from the provisioner pods.</p> <ul> <li>For CephFS PVCs, check network connectivity from the <code>csi-cephfsplugin</code> container of the <code>csi-cephfsplugin-provisioner</code> pods</li> <li>For Block PVCs, check network connectivity from the <code>csi-rbdplugin</code> container of the <code>csi-rbdplugin-provisioner</code> pods</li> </ul> <p>For redundancy, there are two provisioner pods for each type. Make sure to test connectivity from all provisioner pods.</p> <p>Connect to the provisioner pods and verify the connection to the mon endpoints such as the following:</p> <pre><code># Connect to the csi-cephfsplugin container in the provisioner pod\nkubectl -n rook-ceph exec -ti deploy/csi-cephfsplugin-provisioner -c csi-cephfsplugin -- bash\n\n# Test the network connection to the mon endpoint\ncurl 10.104.165.31:3300 2&gt;/dev/null\nceph v2\n</code></pre> <p>If you see the response \"ceph v2\", the connection succeeded. If there is no response then there is a network issue connecting to the ceph cluster.</p> <p>Check network connectivity for all monitor IP\u2019s and ports which are passed to ceph-csi.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#ceph-health","title":"Ceph Health","text":"<p>Sometimes an unhealthy Ceph cluster can contribute to the issues in creating or mounting the PVC. Check that your Ceph cluster is healthy by connecting to the Toolbox and running the <code>ceph</code> commands:</p> <pre><code>ceph health detail\n</code></pre> <pre><code>HEALTH_OK\n</code></pre>"},{"location":"Troubleshooting/ceph-csi-common-issues/#slow-operations","title":"Slow Operations","text":"<p>Even slow ops in the ceph cluster can contribute to the issues. In the toolbox, make sure that no slow ops are present and the ceph cluster is healthy</p> <pre><code>$ ceph -s\ncluster:\n  id:     ba41ac93-3b55-4f32-9e06-d3d8c6ff7334\n  health: HEALTH_WARN\n          30 slow ops, oldest one blocked for 10624 sec, mon.a has slow ops\n[...]\n</code></pre> <p>If Ceph is not healthy, check the following health for more clues:</p> <ul> <li>The Ceph monitor logs for errors</li> <li>The OSD logs for errors</li> <li>Disk Health</li> <li>Network Health</li> </ul>"},{"location":"Troubleshooting/ceph-csi-common-issues/#ceph-troubleshooting","title":"Ceph Troubleshooting","text":""},{"location":"Troubleshooting/ceph-csi-common-issues/#check-if-the-rbd-pool-exists","title":"Check if the RBD Pool exists","text":"<p>Make sure the pool you have specified in the <code>storageclass.yaml</code> exists in the ceph cluster.</p> <p>Suppose the pool name mentioned in the <code>storageclass.yaml</code> is <code>replicapool</code>. It can be verified to exist in the toolbox:</p> <pre><code>$ ceph osd lspools\n1 .mgr\n2 replicapool\n</code></pre> <p>If the pool is not in the list, create the <code>CephBlockPool</code> CR for the pool if you have not already. If you have already created the pool, check the Rook operator log for errors creating the pool.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#check-if-the-filesystem-exists","title":"Check if the Filesystem exists","text":"<p>For the shared filesystem (CephFS), check that the filesystem and pools you have specified in the <code>storageclass.yaml</code> exist in the Ceph cluster.</p> <p>Suppose the <code>fsName</code> name mentioned in the <code>storageclass.yaml</code> is <code>myfs</code>. It can be verified in the toolbox:</p> <pre><code>$ ceph fs ls\nname: myfs, metadata pool: myfs-metadata, data pools: [myfs-data0 ]\n</code></pre> <p>Now verify the <code>pool</code> mentioned in the <code>storageclass.yaml</code> exists, such as the example <code>myfs-data0</code>.</p> <pre><code>ceph osd lspools\n1 .mgr\n2 replicapool\n3 myfs-metadata0\n4 myfs-data0\n</code></pre> <p>The pool for the filesystem will have the suffix <code>-data0</code> compared the filesystem name that is created by the CephFilesystem CR.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#subvolumegroups","title":"subvolumegroups","text":"<p>If the subvolumegroup is not specified in the ceph-csi configmap (where you have passed the ceph monitor information), Ceph-CSI creates the default subvolumegroup with the name csi. Verify that the subvolumegroup exists:</p> <pre><code>$ ceph fs subvolumegroup ls myfs\n[\n    {\n        \"name\": \"csi\"\n    }\n]\n</code></pre> <p>If you don\u2019t see any issues with your Ceph cluster, the following sections will start debugging the issue from the CSI side.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#provisioning-volumes","title":"Provisioning Volumes","text":"<p>At times the issue can also exist in the Ceph-CSI or the sidecar containers used in Ceph-CSI.</p> <p>Ceph-CSI has included number of sidecar containers in the provisioner pods such as: <code>csi-attacher</code>, <code>csi-resizer</code>, <code>csi-provisioner</code>, <code>csi-cephfsplugin</code>, <code>csi-snapshotter</code>, and <code>liveness-prometheus</code>.</p> <p>The CephFS provisioner core CSI driver container name is <code>csi-cephfsplugin</code> as one of the container names. For the RBD (Block) provisioner you will see <code>csi-rbdplugin</code> as the container name.</p> <p>Here is a summary of the sidecar containers:</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#csi-provisioner","title":"csi-provisioner","text":"<p>The external-provisioner is a sidecar container that dynamically provisions volumes by calling <code>ControllerCreateVolume()</code> and <code>ControllerDeleteVolume()</code> functions of CSI drivers. More details about external-provisioner can be found here.</p> <p>If there is an issue with PVC Create or Delete, check the logs of the <code>csi-provisioner</code> sidecar container.</p> <pre><code>kubectl -n rook-ceph logs deploy/csi-rbdplugin-provisioner -c csi-provisioner\n</code></pre>"},{"location":"Troubleshooting/ceph-csi-common-issues/#csi-resizer","title":"csi-resizer","text":"<p>The CSI <code>external-resizer</code> is a sidecar container that watches the Kubernetes API server for PersistentVolumeClaim updates and triggers <code>ControllerExpandVolume</code> operations against a CSI endpoint if the user requested more storage on the PersistentVolumeClaim object. More details about external-provisioner can be found here.</p> <p>If any issue exists in PVC expansion you can check the logs of the <code>csi-resizer</code> sidecar container.</p> <pre><code>kubectl -n rook-ceph logs deploy/csi-rbdplugin-provisioner -c csi-resizer\n</code></pre>"},{"location":"Troubleshooting/ceph-csi-common-issues/#csi-snapshotter","title":"csi-snapshotter","text":"<p>The CSI external-snapshotter sidecar only watches for <code>VolumeSnapshotContent</code> create/update/delete events. It will talk to ceph-csi containers to create or delete snapshots. More details about external-snapshotter can be found here.</p> <p>In Kubernetes 1.17 the volume snapshot feature was promoted to beta. In Kubernetes 1.20, the feature gate is enabled by default on standard Kubernetes deployments and cannot be turned off.</p> <p>Make sure you have installed the correct snapshotter CRD version. If you have not installed the snapshotter controller, see the Snapshots guide.</p> <pre><code>$ kubectl get crd | grep snapshot\nvolumesnapshotclasses.snapshot.storage.k8s.io    2021-01-25T11:19:38Z\nvolumesnapshotcontents.snapshot.storage.k8s.io   2021-01-25T11:19:39Z\nvolumesnapshots.snapshot.storage.k8s.io          2021-01-25T11:19:40Z\n</code></pre> <p>The above CRDs must have the matching version in your <code>snapshotclass.yaml</code> or <code>snapshot.yaml</code>. Otherwise, the <code>VolumeSnapshot</code> and <code>VolumesnapshotContent</code> will not be created.</p> <p>The snapshot controller is responsible for creating both <code>VolumeSnapshot</code> and <code>VolumesnapshotContent</code> object. If the objects are not getting created, you may need to check the logs of the snapshot-controller container.</p> <p>Rook only installs the snapshotter sidecar container, not the controller. It is recommended that Kubernetes distributors bundle and deploy the controller and CRDs as part of their Kubernetes cluster management process (independent of any CSI Driver).</p> <p>If your Kubernetes distribution does not bundle the snapshot controller, you may manually install these components.</p> <p>If any issue exists in the snapshot Create/Delete operation you can check the logs of the csi-snapshotter sidecar container.</p> <pre><code>kubectl -n rook-ceph logs deploy/csi-rbdplugin-provisioner -c csi-snapshotter\n</code></pre> <p>If you see an error about a volume already existing such as:</p> <pre><code>GRPC error: rpc error: code = Aborted desc = an operation with the given Volume ID\n0001-0009-rook-ceph-0000000000000001-8d0ba728-0e17-11eb-a680-ce6eecc894de already exists.\n</code></pre> <p>The issue typically is in the Ceph cluster or network connectivity. If the issue is in Provisioning the PVC Restarting the Provisioner pods help(for CephFS issue restart <code>csi-cephfsplugin-provisioner-xxxxxx</code> CephFS Provisioner. For RBD, restart the <code>csi-rbdplugin-provisioner-xxxxxx</code> pod. If the issue is in mounting the PVC, restart the <code>csi-rbdplugin-xxxxx</code> pod (for RBD) and the <code>csi-cephfsplugin-xxxxx</code> pod for CephFS issue.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#mounting-the-volume-to-application-pods","title":"Mounting the volume to application pods","text":"<p>When a user requests to create the application pod with PVC, there is a three-step process</p> <ul> <li>CSI driver registration</li> <li>Create volume attachment object</li> <li>Stage and publish the volume</li> </ul>"},{"location":"Troubleshooting/ceph-csi-common-issues/#csi-driver-registration","title":"csi-driver registration","text":"<p><code>csi-cephfsplugin-xxxx</code> or <code>csi-rbdplugin-xxxx</code> is a daemonset pod running on all the nodes where your application gets scheduled. If the plugin pods are not running on the node where your application is scheduled might cause the issue, make sure plugin pods are always running.</p> <p>Each plugin pod has two important containers: one is <code>driver-registrar</code> and <code>csi-rbdplugin</code> or <code>csi-cephfsplugin</code>. Sometimes there is also a <code>liveness-prometheus</code> container.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#driver-registrar","title":"driver-registrar","text":"<p>The node-driver-registrar is a sidecar container that registers the CSI driver with Kubelet. More details can be found here.</p> <p>If any issue exists in attaching the PVC to the application pod check logs from driver-registrar sidecar container in plugin pod where your application pod is scheduled.</p> <pre><code>$ kubectl -n rook-ceph logs deploy/csi-rbdplugin -c driver-registrar\n[...]\nI0120 12:28:34.231761  124018 main.go:112] Version: v2.0.1\nI0120 12:28:34.233910  124018 connection.go:151] Connecting to unix:///csi/csi.sock\nI0120 12:28:35.242469  124018 node_register.go:55] Starting Registration Server at: /registration/rook-ceph.rbd.csi.ceph.com-reg.sock\nI0120 12:28:35.243364  124018 node_register.go:64] Registration Server started at: /registration/rook-ceph.rbd.csi.ceph.com-reg.sock\nI0120 12:28:35.243673  124018 node_register.go:86] Skipping healthz server because port set to: 0\nI0120 12:28:36.318482  124018 main.go:79] Received GetInfo call: &amp;InfoRequest{}\nI0120 12:28:37.455211  124018 main.go:89] Received NotifyRegistrationStatus call: &amp;RegistrationStatus{PluginRegistered:true,Error:,}\nE0121 05:19:28.658390  124018 connection.go:129] Lost connection to unix:///csi/csi.sock.\nE0125 07:11:42.926133  124018 connection.go:129] Lost connection to unix:///csi/csi.sock.\n[...]\n</code></pre> <p>You should see the response <code>RegistrationStatus{PluginRegistered:true,Error:,}</code> in the logs to confirm that plugin is registered with kubelet.</p> <p>If you see a driver not found an error in the application pod describe output. Restarting the <code>csi-xxxxplugin-xxx</code> pod on the node may help.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#volume-attachment","title":"Volume Attachment","text":"<p>Each provisioner pod also has a sidecar container called <code>csi-attacher</code>.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#csi-attacher","title":"csi-attacher","text":"<p>The external-attacher is a sidecar container that attaches volumes to nodes by calling <code>ControllerPublish</code> and <code>ControllerUnpublish</code> functions of CSI drivers. It is necessary because the internal Attach/Detach controller running in Kubernetes controller-manager does not have any direct interfaces to CSI drivers. More details can be found here.</p> <p>If any issue exists in attaching the PVC to the application pod first check the volumeattachment object created and also log from csi-attacher sidecar container in provisioner pod.</p> <pre><code>$ kubectl get volumeattachment\nNAME                                                                   ATTACHER                        PV                                         NODE       ATTACHED   AGE\ncsi-75903d8a902744853900d188f12137ea1cafb6c6f922ebc1c116fd58e950fc92   rook-ceph.cephfs.csi.ceph.com   pvc-5c547d2a-fdb8-4cb2-b7fe-e0f30b88d454   minikube   true       4m26s\n</code></pre> <pre><code>kubectl logs po/csi-rbdplugin-provisioner-d857bfb5f-ddctl -c csi-attacher\n</code></pre>"},{"location":"Troubleshooting/ceph-csi-common-issues/#cephfs-stale-operations","title":"CephFS Stale operations","text":"<p>Check for any stale mount commands on the <code>csi-cephfsplugin-xxxx</code> pod on the node where your application pod is scheduled.</p> <p>You need to exec in the <code>csi-cephfsplugin-xxxx</code> pod and grep for stale mount operators.</p> <p>Identify the <code>csi-cephfsplugin-xxxx</code> pod running on the node where your application is scheduled with <code>kubectl get po -o wide</code> and match the node names.</p> <pre><code>$ kubectl exec -it csi-cephfsplugin-tfk2g -c csi-cephfsplugin -- sh\n$ ps -ef |grep mount\n[...]\nroot          67      60  0 11:55 pts/0    00:00:00 grep mount\n</code></pre> <pre><code>ps -ef |grep ceph\n[...]\nroot           1       0  0 Jan20 ?        00:00:26 /usr/local/bin/cephcsi --nodeid=minikube --type=cephfs --endpoint=unix:///csi/csi.sock --v=0 --nodeserver=true --drivername=rook-ceph.cephfs.csi.ceph.com --pidlimit=-1 --metricsport=9091 --forcecephkernelclient=true --metricspath=/metrics --enablegrpcmetrics=true\nroot          69      60  0 11:55 pts/0    00:00:00 grep ceph\n</code></pre> <p>If any commands are stuck check the dmesg logs from the node. Restarting the <code>csi-cephfsplugin</code> pod may also help sometimes.</p> <p>If you don\u2019t see any stuck messages, confirm the network connectivity, Ceph health, and slow ops.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#rbd-stale-operations","title":"RBD Stale operations","text":"<p>Check for any stale <code>map/mkfs/mount</code> commands on the <code>csi-rbdplugin-xxxx</code> pod on the node where your application pod is scheduled.</p> <p>You need to exec in the <code>csi-rbdplugin-xxxx</code> pod and grep for stale operators like (<code>rbd map, rbd unmap, mkfs, mount</code> and <code>umount</code>).</p> <p>Identify the <code>csi-rbdplugin-xxxx</code> pod running on the node where your application is scheduled with <code>kubectl get po -o wide</code> and match the node names.</p> <pre><code>$ kubectl exec -it csi-rbdplugin-vh8d5 -c csi-rbdplugin -- sh\n$ ps -ef |grep map\n[...]\nroot     1297024 1296907  0 12:00 pts/0    00:00:00 grep map\n</code></pre> <pre><code>$ ps -ef |grep mount\n[...]\nroot        1824       1  0 Jan19 ?        00:00:00 /usr/sbin/rpc.mountd\nceph     1041020 1040955  1 07:11 ?        00:03:43 ceph-mgr --fsid=ba41ac93-3b55-4f32-9e06-d3d8c6ff7334 --keyring=/etc/ceph/keyring-store/keyring --log-to-stderr=true --err-to-stderr=true --mon-cluster-log-to-stderr=true --log-stderr-prefix=debug  --default-log-to-file=false --default-mon-cluster-log-to-file=false --mon-host=[v2:10.111.136.166:3300,v1:10.111.136.166:6789] --mon-initial-members=a --id=a --setuser=ceph --setgroup=ceph --client-mount-uid=0 --client-mount-gid=0 --foreground --public-addr=172.17.0.6\nroot     1297115 1296907  0 12:00 pts/0    00:00:00 grep mount\n</code></pre> <pre><code>$ ps -ef |grep mkfs\n[...]\nroot     1297291 1296907  0 12:00 pts/0    00:00:00 grep mkfs\n</code></pre> <pre><code>$ ps -ef |grep umount\n[...]\nroot     1298500 1296907  0 12:01 pts/0    00:00:00 grep umount\n</code></pre> <pre><code>$ ps -ef |grep unmap\n[...]\nroot     1298578 1296907  0 12:01 pts/0    00:00:00 grep unmap\n</code></pre> <p>If any commands are stuck check the dmesg logs from the node. Restarting the <code>csi-rbdplugin</code> pod also may help sometimes.</p> <p>If you don\u2019t see any stuck messages, confirm the network connectivity, Ceph health, and slow ops.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#dmesg-logs","title":"dmesg logs","text":"<p>Check the dmesg logs on the node where pvc mounting is failing or the <code>csi-rbdplugin</code> container of the <code>csi-rbdplugin-xxxx</code> pod on that node.</p> <pre><code>dmesg\n</code></pre>"},{"location":"Troubleshooting/ceph-csi-common-issues/#rbd-commands","title":"RBD Commands","text":"<p>If nothing else helps, get the last executed command from the ceph-csi pod logs and run it manually inside the provisioner or plugin pod to see if there are errors returned even if they couldn't be seen in the logs.</p> <pre><code>rbd ls --id=csi-rbd-node -m=10.111.136.166:6789 --key=AQDpIQhg+v83EhAAgLboWIbl+FL/nThJzoI3Fg==\n</code></pre> <p>Where <code>-m</code> is one of the mon endpoints and the <code>--key</code> is the key used by the CSI driver for accessing the Ceph cluster.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#node-loss","title":"Node Loss","text":"<p>When a node is lost, you will see application pods on the node stuck in the <code>Terminating</code> state while another pod is rescheduled and is in the <code>ContainerCreating</code> state.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#force-deleting-the-pod","title":"Force deleting the pod","text":"<p>To force delete the pod stuck in the <code>Terminating</code> state:</p> <pre><code>kubectl -n rook-ceph delete pod my-app-69cd495f9b-nl6hf --grace-period 0 --force\n</code></pre> <p>After the force delete, wait for a timeout of about 8-10 minutes. If the pod still not in the running state, continue with the next section to blocklist the node.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#blocklisting-a-node","title":"Blocklisting a node","text":"<p>To shorten the timeout, you can mark the node as \"blocklisted\" from the Rook toolbox so Rook can safely failover the pod sooner.</p> <pre><code>$ ceph osd blocklist add &lt;NODE_IP&gt; # get the node IP you want to blocklist\nblocklisting &lt;NODE_IP&gt;\n</code></pre> <p>After running the above command within a few minutes the pod will be running.</p>"},{"location":"Troubleshooting/ceph-csi-common-issues/#removing-a-node-blocklist","title":"Removing a node blocklist","text":"<p>After you are absolutely sure the node is permanently offline and that the node no longer needs to be blocklisted, remove the node from the blocklist.</p> <pre><code>$ ceph osd blocklist rm &lt;NODE_IP&gt;\nun-blocklisting &lt;NODE_IP&gt;\n</code></pre>"},{"location":"Troubleshooting/ceph-toolbox/","title":"Toolbox","text":"<p>The Rook toolbox is a container with common tools used for rook debugging and testing. The toolbox is based on CentOS, so more tools of your choosing can be easily installed with <code>yum</code>.</p> <p>The toolbox can be run in two modes:</p> <ol> <li>Interactive: Start a toolbox pod where you can connect and execute Ceph commands from a shell</li> <li>One-time job: Run a script with Ceph commands and collect the results from the job log</li> </ol> <p>Hint</p> <p>Before running the toolbox you should have a running Rook cluster deployed (see the Quickstart Guide).</p> <p>Note</p> <p>The toolbox is not necessary if you are using kubectl plugin to execute Ceph commands.</p>"},{"location":"Troubleshooting/ceph-toolbox/#interactive-toolbox","title":"Interactive Toolbox","text":"<p>The rook toolbox can run as a deployment in a Kubernetes cluster where you can connect and run arbitrary Ceph commands.</p> <p>Launch the rook-ceph-tools pod:</p> <pre><code>kubectl create -f deploy/examples/toolbox.yaml\n</code></pre> <p>Wait for the toolbox pod to download its container and get to the <code>running</code> state:</p> <pre><code>kubectl -n rook-ceph rollout status deploy/rook-ceph-tools\n</code></pre> <p>Once the rook-ceph-tools pod is running, you can connect to it with:</p> <pre><code>kubectl -n rook-ceph exec -it deploy/rook-ceph-tools -- bash\n</code></pre> <p>All available tools in the toolbox are ready for your troubleshooting needs.</p> <p>Example:</p> <ul> <li><code>ceph status</code></li> <li><code>ceph osd status</code></li> <li><code>ceph df</code></li> <li><code>rados df</code></li> </ul> <p>When you are done with the toolbox, you can remove the deployment:</p> <pre><code>kubectl -n rook-ceph delete deploy/rook-ceph-tools\n</code></pre>"},{"location":"Troubleshooting/ceph-toolbox/#toolbox-job","title":"Toolbox Job","text":"<p>If you want to run Ceph commands as a one-time operation and collect the results later from the logs, you can run a script as a Kubernetes Job. The toolbox job will run a script that is embedded in the job spec. The script has the full flexibility of a bash script.</p> <p>In this example, the <code>ceph status</code> command is executed when the job is created. Create the toolbox job:</p> <pre><code>kubectl create -f deploy/examples/toolbox-job.yaml\n</code></pre> <p>After the job completes, see the results of the script:</p> <pre><code>kubectl -n rook-ceph logs -l job-name=rook-ceph-toolbox-job\n</code></pre>"},{"location":"Troubleshooting/common-issues/","title":"Common Issues","text":"<p>To help troubleshoot your Rook clusters, here are some tips on what information will help solve the issues you might be seeing. If after trying the suggestions found on this page and the problem is not resolved, the Rook team is very happy to help you troubleshoot the issues in their Slack channel. Once you have registered for the Rook Slack, proceed to the General channel to ask for assistance.</p>"},{"location":"Troubleshooting/common-issues/#ceph-common-issues","title":"Ceph Common Issues","text":"<p>For common issues specific to Ceph, see the Ceph Common Issues page.</p>"},{"location":"Troubleshooting/common-issues/#troubleshooting-techniques","title":"Troubleshooting Techniques","text":"<p>Kubernetes status and logs are the main resources needed to investigate issues in any Rook cluster.</p>"},{"location":"Troubleshooting/common-issues/#kubernetes-tools","title":"Kubernetes Tools","text":"<p>Kubernetes status is the first line of investigating when something goes wrong with the cluster. Here are a few artifacts that are helpful to gather:</p> <ul> <li>Rook pod status:<ul> <li><code>kubectl get pod -n &lt;cluster-namespace&gt; -o wide</code><ul> <li>e.g., <code>kubectl get pod -n rook-ceph -o wide</code></li> </ul> </li> </ul> </li> <li>Logs for Rook pods<ul> <li>Logs for the operator: <code>kubectl logs -n &lt;cluster-namespace&gt; -l app=&lt;storage-backend-operator&gt;</code><ul> <li>e.g., <code>kubectl logs -n rook-ceph -l app=rook-ceph-operator</code></li> </ul> </li> <li>Logs for a specific pod: <code>kubectl logs -n &lt;cluster-namespace&gt; &lt;pod-name&gt;</code>, or a pod using a label such as mon1: <code>kubectl logs -n &lt;cluster-namespace&gt; -l &lt;label-matcher&gt;</code><ul> <li>e.g., <code>kubectl logs -n rook-ceph -l mon=a</code></li> </ul> </li> <li>Logs on a specific node to find why a PVC is failing to mount:<ul> <li>Connect to the node, then get kubelet logs (if your distro is using systemd): <code>journalctl -u kubelet</code></li> </ul> </li> <li>Pods with multiple containers<ul> <li>For all containers, in order: <code>kubectl -n &lt;cluster-namespace&gt; logs &lt;pod-name&gt; --all-containers</code></li> <li>For a single container: <code>kubectl -n &lt;cluster-namespace&gt; logs &lt;pod-name&gt; -c &lt;container-name&gt;</code></li> </ul> </li> <li>Logs for pods which are no longer running: <code>kubectl -n &lt;cluster-namespace&gt; logs --previous &lt;pod-name&gt;</code></li> </ul> </li> </ul> <p>Some pods have specialized init containers, so you may need to look at logs for different containers within the pod.</p> <ul> <li><code>kubectl -n &lt;namespace&gt; logs &lt;pod-name&gt; -c &lt;container-name&gt;</code></li> <li>Other Rook artifacts: <code>kubectl -n &lt;cluster-namespace&gt; get all</code></li> </ul>"},{"location":"Troubleshooting/direct-tools/","title":"Direct Tools","text":"<p>Rook is designed with Kubernetes design principles from the ground up. This topic is going to escape the bounds of Kubernetes storage and show you how to use block and file storage directly from a pod without any of the Kubernetes magic. The purpose of this topic is to help you quickly test a new configuration, although it is not meant to be used in production. All of the benefits of Kubernetes storage including failover, detach, and attach will not be available. If your pod dies, your mount will die with it.</p>"},{"location":"Troubleshooting/direct-tools/#start-the-direct-mount-pod","title":"Start the Direct Mount Pod","text":"<p>To test mounting your Ceph volumes, start a pod with the necessary mounts. An example is provided in the examples test directory:</p> <pre><code>kubectl create -f deploy/examples/direct-mount.yaml\n</code></pre> <p>After the pod is started, connect to it like this:</p> <pre><code>kubectl -n rook-ceph get pod -l app=rook-direct-mount\n$ kubectl -n rook-ceph exec -it &lt;pod&gt; bash\n</code></pre>"},{"location":"Troubleshooting/direct-tools/#block-storage-tools","title":"Block Storage Tools","text":"<p>After you have created a pool as described in the Block Storage topic, you can create a block image and mount it directly in a pod. This example will show how the Ceph rbd volume can be mounted in the direct mount pod.</p> <p>Create the Direct Mount Pod.</p> <p>Create a volume image (10MB):</p> <pre><code>rbd create replicapool/test --size 10\nrbd info replicapool/test\n\n# Disable the rbd features that are not in the kernel module\nrbd feature disable replicapool/test fast-diff deep-flatten object-map\n</code></pre> <p>Map the block volume and format it and mount it:</p> <pre><code># Map the rbd device. If the Direct Mount Pod was started with \"hostNetwork: false\" this hangs and you have to stop it with Ctrl-C,\n# however the command still succeeds; see https://github.com/rook/rook/issues/2021\nrbd map replicapool/test\n\n# Find the device name, such as rbd0\nlsblk | grep rbd\n\n# Format the volume (only do this the first time or you will lose data)\nmkfs.ext4 -m0 /dev/rbd0\n\n# Mount the block device\nmkdir /tmp/rook-volume\nmount /dev/rbd0 /tmp/rook-volume\n</code></pre> <p>Write and read a file:</p> <pre><code>echo \"Hello Rook\" &gt; /tmp/rook-volume/hello\ncat /tmp/rook-volume/hello\n</code></pre>"},{"location":"Troubleshooting/direct-tools/#unmount-the-block-device","title":"Unmount the Block device","text":"<p>Unmount the volume and unmap the kernel device:</p> <pre><code>umount /tmp/rook-volume\nrbd unmap /dev/rbd0\n</code></pre>"},{"location":"Troubleshooting/direct-tools/#shared-filesystem-tools","title":"Shared Filesystem Tools","text":"<p>After you have created a filesystem as described in the Shared Filesystem topic, you can mount the filesystem from multiple pods. The the other topic you may have mounted the filesystem already in the registry pod. Now we will mount the same filesystem in the Direct Mount pod. This is just a simple way to validate the Ceph filesystem and is not recommended for production Kubernetes pods.</p> <p>Follow Direct Mount Pod to start a pod with the necessary mounts and then proceed with the following commands after connecting to the pod.</p> <pre><code># Create the directory\nmkdir /tmp/registry\n\n# Detect the mon endpoints and the user secret for the connection\nmon_endpoints=$(grep mon_host /etc/ceph/ceph.conf | awk '{print $3}')\nmy_secret=$(grep key /etc/ceph/keyring | awk '{print $3}')\n\n# Mount the filesystem\nmount -t ceph -o mds_namespace=myfs,name=admin,secret=$my_secret $mon_endpoints:/ /tmp/registry\n\n# See your mounted filesystem\ndf -h\n</code></pre> <p>Now you should have a mounted filesystem. If you have pushed images to the registry you will see a directory called <code>docker</code>.</p> <pre><code>ls /tmp/registry\n</code></pre> <p>Try writing and reading a file to the shared filesystem.</p> <pre><code>echo \"Hello Rook\" &gt; /tmp/registry/hello\ncat /tmp/registry/hello\n\n# delete the file when you're done\nrm -f /tmp/registry/hello\n</code></pre>"},{"location":"Troubleshooting/direct-tools/#unmount-the-filesystem","title":"Unmount the Filesystem","text":"<p>To unmount the shared filesystem from the Direct Mount Pod:</p> <pre><code>umount /tmp/registry\nrmdir /tmp/registry\n</code></pre> <p>No data will be deleted by unmounting the filesystem.</p>"},{"location":"Troubleshooting/disaster-recovery/","title":"Disaster Recovery","text":"<p>Under extenuating circumstances, steps may be necessary to recover the cluster health. There are several types of recovery addressed in this document.</p>"},{"location":"Troubleshooting/disaster-recovery/#restoring-mon-quorum","title":"Restoring Mon Quorum","text":"<p>Under extenuating circumstances, the mons may lose quorum. If the mons cannot form quorum again, there is a manual procedure to get the quorum going again. The only requirement is that at least one mon is still healthy. The following steps will remove the unhealthy mons from quorum and allow you to form a quorum again with a single mon, then grow the quorum back to the original size.</p> <p>The Rook kubectl Plugin has a command <code>restore-quorum</code> that will walk you through the mon quorum automated restoration process.</p> <p>If the name of the healthy mon is <code>c</code>, you would run the command:</p> <pre><code>kubectl rook-ceph mons restore-quorum c\n</code></pre> <p>See the restore-quorum documentation for more details.</p>"},{"location":"Troubleshooting/disaster-recovery/#restoring-crds-after-deletion","title":"Restoring CRDs After Deletion","text":"<p>When the Rook CRDs are deleted, the Rook operator will respond to the deletion event to attempt to clean up the cluster resources. If any data appears present in the cluster, Rook will refuse to allow the resources to be deleted since the operator will refuse to remove the finalizer on the CRs until the underlying data is deleted. For more details, see the dependency design doc.</p> <p>While it is good that the CRs will not be deleted and the underlying Ceph data and daemons continue to be available, the CRs will be stuck indefinitely in a <code>Deleting</code> state in which the operator will not continue to ensure cluster health. Upgrades will be blocked, further updates to the CRs are prevented, and so on. Since Kubernetes does not allow undeleting resources, the following procedure will allow you to restore the CRs to their prior state without even necessarily suffering cluster downtime.</p> <p>Note</p> <p>In the following commands, the affected <code>CephCluster</code> resource is called <code>rook-ceph</code>. If yours is named differently, the commands will need to be adjusted.</p> <ol> <li> <p>Scale down the operator.</p> <pre><code>kubectl -n rook-ceph scale --replicas=0 deploy/rook-ceph-operator\n</code></pre> </li> <li> <p>Backup all Rook CRs and critical metadata</p> <pre><code># Store the `CephCluster` CR settings. Also, save other Rook CRs that are in terminating state.\nkubectl -n rook-ceph get cephcluster rook-ceph -o yaml &gt; cluster.yaml\n\n# Backup critical secrets and configmaps in case something goes wrong later in the procedure\nkubectl -n rook-ceph get secret -o yaml &gt; secrets.yaml\nkubectl -n rook-ceph get configmap -o yaml &gt; configmaps.yaml\n</code></pre> </li> <li> <p>Remove the owner references from all critical Rook resources that were referencing the <code>CephCluster</code> CR.</p> <ol> <li> <p>Programmatically determine all such resources, using this command:</p> <pre><code># Determine the `CephCluster` UID\nROOK_UID=$(kubectl -n rook-ceph get cephcluster rook-ceph -o 'jsonpath={.metadata.uid}')\n# List all secrets, configmaps, services, deployments, and PVCs with that ownership UID.\nRESOURCES=$(kubectl -n rook-ceph get secret,configmap,service,deployment,pvc -o jsonpath='{range .items[?(@.metadata.ownerReferences[*].uid==\"'\"$ROOK_UID\"'\")]}{.kind}{\"/\"}{.metadata.name}{\"\\n\"}{end}')\n# Show the collected resources.\nkubectl -n rook-ceph get $RESOURCES\n</code></pre> </li> <li> <p>Verify that all critical resources are shown in the output. The critical resources are these:</p> <ul> <li>Secrets: <code>rook-ceph-admin-keyring</code>, <code>rook-ceph-config</code>, <code>rook-ceph-mon</code>, <code>rook-ceph-mons-keyring</code></li> <li>ConfigMap: <code>rook-ceph-mon-endpoints</code></li> <li>Services: <code>rook-ceph-mon-*</code>, <code>rook-ceph-mgr-*</code></li> <li>Deployments: <code>rook-ceph-mon-*</code>, <code>rook-ceph-osd-*</code>, <code>rook-ceph-mgr-*</code></li> <li>PVCs (if applicable): <code>rook-ceph-mon-*</code> and the OSD PVCs (named <code>&lt;deviceset&gt;-*</code>, for example <code>set1-data-*</code>)</li> </ul> </li> <li> <p>For each listed resource, remove the <code>ownerReferences</code> metadata field, in order to unlink it from the deleting <code>CephCluster</code>     CR.</p> <p>To do so programmatically, use the command:</p> <pre><code>for resource in $(kubectl -n rook-ceph get $RESOURCES -o name); do\n  kubectl -n rook-ceph patch $resource -p '{\"metadata\": {\"ownerReferences\":null}}'\ndone\n</code></pre> <p>For a manual alternative, issue <code>kubectl edit</code> on each resource, and remove the block matching:</p> <pre><code>ownerReferences:\n- apiVersion: ceph.rook.io/v1\n   blockOwnerDeletion: true\n   controller: true\n   kind: `CephCluster`\n   name: rook-ceph\n   uid: &lt;uid&gt;\n</code></pre> </li> </ol> </li> <li> <p>Before completing this step, validate these things. Failing to do so could result in data loss.</p> <ol> <li>Confirm that <code>cluster.yaml</code> contains the <code>CephCluster</code> CR.</li> <li>Confirm all critical resources listed above have had the <code>ownerReference</code> to the <code>CephCluster</code> CR removed.</li> </ol> <p>Remove the finalizer from the <code>CephCluster</code> resource. This will cause the resource to be immediately deleted by Kubernetes.</p> <pre><code>kubectl -n rook-ceph patch cephcluster/rook-ceph --type json --patch='[ { \"op\": \"remove\", \"path\": \"/metadata/finalizers\" } ]'\n</code></pre> <p>After the finalizer is removed, the <code>CephCluster</code> will be immediately deleted. If all owner references were properly removed, all ceph daemons will continue running and there will be no downtime.</p> </li> <li> <p>Create the <code>CephCluster</code> CR with the same settings as previously</p> <pre><code># Use the same cluster settings as exported in step 2.\nkubectl create -f cluster.yaml\n</code></pre> </li> <li> <p>If there are other CRs in terminating state such as CephBlockPools, CephObjectStores, or CephFilesystems,     follow the above steps as well for those CRs:</p> <ol> <li>Backup the CR</li> <li>Remove the finalizer and confirm the CR is deleted (the underlying Ceph resources will be preserved)</li> <li>Create the CR again</li> </ol> </li> <li> <p>Scale up the operator</p> <pre><code>kubectl -n rook-ceph scale --replicas=1 deploy/rook-ceph-operator\n</code></pre> </li> <li> <p>Watch the operator log to confirm that the reconcile completes successfully.</p> <pre><code>kubectl -n rook-ceph logs -f deployment/rook-ceph-operator\n</code></pre> </li> </ol>"},{"location":"Troubleshooting/disaster-recovery/#adopt-an-existing-rook-ceph-cluster-into-a-new-kubernetes-cluster","title":"Adopt an existing Rook Ceph cluster into a new Kubernetes cluster","text":"<p>Situations this section can help resolve:</p> <ol> <li>The Kubernetes environment underlying a running Rook Ceph cluster failed catastrophically, requiring a new Kubernetes environment in which the user wishes to recover the previous Rook Ceph cluster.</li> <li>The user wishes to migrate their existing Rook Ceph cluster to a new Kubernetes environment, and downtime can be tolerated.</li> </ol>"},{"location":"Troubleshooting/disaster-recovery/#prerequisites","title":"Prerequisites","text":"<ol> <li>A working Kubernetes cluster to which we will migrate the previous Rook Ceph cluster.</li> <li>At least one Ceph mon db is in quorum, and sufficient number of Ceph OSD is <code>up</code> and <code>in</code> before disaster.</li> <li>The previous Rook Ceph cluster is not running.</li> </ol>"},{"location":"Troubleshooting/disaster-recovery/#overview-for-steps-below","title":"Overview for Steps below","text":"<ol> <li>Start a new and clean Rook Ceph cluster, with old <code>CephCluster</code> <code>CephBlockPool</code> <code>CephFilesystem</code> <code>CephNFS</code> <code>CephObjectStore</code>.</li> <li>Shut the new cluster down when it has been created successfully.</li> <li>Replace ceph-mon data with that of the old cluster.</li> <li>Replace <code>fsid</code> in <code>secrets/rook-ceph-mon</code> with that of the old one.</li> <li>Fix monmap in ceph-mon db.</li> <li>Fix ceph mon auth key.</li> <li>Disable auth.</li> <li>Start the new cluster, watch it resurrect.</li> <li>Fix admin auth key, and enable auth.</li> <li>Restart cluster for the final time.</li> </ol>"},{"location":"Troubleshooting/disaster-recovery/#steps","title":"Steps","text":"<p>Assuming <code>dataHostPathData</code> is <code>/var/lib/rook</code>, and the <code>CephCluster</code> trying to adopt is named <code>rook-ceph</code>.</p> <ol> <li>Make sure the old Kubernetes cluster is completely torn down and the new Kubernetes cluster is up and running without Rook Ceph.</li> <li>Backup <code>/var/lib/rook</code> in all the Rook Ceph nodes to a different directory. Backups will be used later.</li> <li>Pick a <code>/var/lib/rook/rook-ceph/rook-ceph.config</code> from any previous Rook Ceph node and save the old cluster <code>fsid</code> from its content.</li> <li>Remove <code>/var/lib/rook</code> from all the Rook Ceph nodes.</li> <li>Add identical <code>CephCluster</code> descriptor to the new Kubernetes cluster, especially identical <code>spec.storage.config</code> and <code>spec.storage.nodes</code>, except <code>mon.count</code>, which should be set to <code>1</code>.</li> <li>Add identical <code>CephFilesystem</code> <code>CephBlockPool</code> <code>CephNFS</code> <code>CephObjectStore</code> descriptors (if any) to the new Kubernetes cluster.</li> <li>Install Rook Ceph in the new Kubernetes cluster.</li> <li>Watch the operator logs with <code>kubectl -n rook-ceph logs -f rook-ceph-operator-xxxxxxx</code>, and wait until the orchestration has settled.</li> <li>STATE: Now the cluster will have <code>rook-ceph-mon-a</code>, <code>rook-ceph-mgr-a</code>, and all the auxiliary pods up and running, and zero (hopefully) <code>rook-ceph-osd-ID-xxxxxx</code> running. <code>ceph -s</code> output should report 1 mon, 1 mgr running, and all of the OSDs down, all PGs are in <code>unknown</code> state. Rook should not start any OSD daemon since all devices belongs to the old cluster (which have a different <code>fsid</code>).</li> <li> <p>Run <code>kubectl -n rook-ceph exec -it rook-ceph-mon-a-xxxxxxxx bash</code> to enter the <code>rook-ceph-mon-a</code> pod,</p> <pre><code>mon-a# cat /etc/ceph/keyring-store/keyring  # save this keyring content for later use\nmon-a# exit\n</code></pre> </li> <li> <p>Stop the Rook operator by running <code>kubectl -n rook-ceph edit deploy/rook-ceph-operator</code> and set <code>replicas</code> to <code>0</code>.</p> </li> <li>Stop cluster daemons by running <code>kubectl -n rook-ceph delete deploy/X</code> where X is every deployment in namespace <code>rook-ceph</code>, except <code>rook-ceph-operator</code> and <code>rook-ceph-tools</code>.</li> <li>Save the <code>rook-ceph-mon-a</code> address with <code>kubectl -n rook-ceph get cm/rook-ceph-mon-endpoints -o yaml</code> in the new Kubernetes cluster for later use.</li> <li> <p>SSH to the host where <code>rook-ceph-mon-a</code> in the new Kubernetes cluster resides.</p> <ol> <li>Remove <code>/var/lib/rook/mon-a</code></li> <li>Pick a healthy <code>rook-ceph-mon-ID</code> directory (<code>/var/lib/rook/mon-ID</code>) in the previous backup, copy to <code>/var/lib/rook/mon-a</code>. <code>ID</code> is any healthy mon node ID of the old cluster.</li> <li>Replace <code>/var/lib/rook/mon-a/keyring</code> with the saved keyring, preserving only the <code>[mon.]</code> section, remove <code>[client.admin]</code> section.</li> <li> <p>Run <code>docker run -it --rm -v /var/lib/rook:/var/lib/rook ceph/ceph:v14.2.1-20190430 bash</code>. The Docker image tag should match the Ceph version used in the Rook cluster. The <code>/etc/ceph/ceph.conf</code> file needs to exist for <code>ceph-mon</code> to work.</p> <pre><code>touch /etc/ceph/ceph.conf\ncd /var/lib/rook\nceph-mon --extract-monmap monmap --mon-data ./mon-a/data  # Extract monmap from old ceph-mon db and save as monmap\nmonmaptool --print monmap  # Print the monmap content, which reflects the old cluster ceph-mon configuration.\nmonmaptool --rm a monmap  # Delete `a` from monmap.\nmonmaptool --rm b monmap  # Repeat, and delete `b` from monmap.\nmonmaptool --rm c monmap  # Repeat this pattern until all the old ceph-mons are removed\nmonmaptool --rm d monmap\nmonmaptool --rm e monmap\nmonmaptool --addv a [v2:10.77.2.216:3300,v1:10.77.2.216:6789] monmap   # Replace it with the rook-ceph-mon-a address you got from previous command.\nceph-mon --inject-monmap monmap --mon-data ./mon-a/data  # Replace monmap in ceph-mon db with our modified version.\nrm monmap\nexit\n</code></pre> </li> </ol> </li> <li> <p>Tell Rook to run as old cluster by running <code>kubectl -n rook-ceph edit secret/rook-ceph-mon</code> and changing <code>fsid</code> to the original <code>fsid</code>. Note that the <code>fsid</code> is base64 encoded and must not contain a trailing carriage return. For example:</p> <pre><code>echo -n a811f99a-d865-46b7-8f2c-f94c064e4356 | base64  # Replace with the fsid from your old cluster.\n</code></pre> </li> <li> <p>Disable authentication by running <code>kubectl -n rook-ceph edit cm/rook-config-override</code> and adding content below:</p> <pre><code>data:\nconfig: |\n    [global]\n    auth cluster required = none\n    auth service required = none\n    auth client required = none\n    auth supported = none\n</code></pre> </li> <li> <p>Bring the Rook Ceph operator back online by running <code>kubectl -n rook-ceph edit deploy/rook-ceph-operator</code> and set <code>replicas</code> to <code>1</code>.</p> </li> <li>Watch the operator logs with <code>kubectl -n rook-ceph logs -f rook-ceph-operator-xxxxxxx</code>, and wait until the orchestration has settled.</li> <li>STATE: Now the new cluster should be up and running with authentication disabled. <code>ceph -s</code> should report 1 mon &amp; 1 mgr &amp; all of the OSDs up and running, and all PGs in either <code>active</code> or <code>degraded</code> state.</li> <li> <p>Run <code>kubectl -n rook-ceph exec -it rook-ceph-tools-XXXXXXX bash</code> to enter tools pod:</p> <pre><code>vi key\n# [paste keyring content saved before, preserving only `[client admin]` section]\nceph auth import -i key\nrm key\n</code></pre> </li> <li> <p>Re-enable authentication by running <code>kubectl -n rook-ceph edit cm/rook-config-override</code> and removing auth configuration added in previous steps.</p> </li> <li>Stop the Rook operator by running <code>kubectl -n rook-ceph edit deploy/rook-ceph-operator</code> and set <code>replicas</code> to <code>0</code>.</li> <li>Shut down entire new cluster by running <code>kubectl -n rook-ceph delete deploy/X</code> where X is every deployment in namespace <code>rook-ceph</code>, except <code>rook-ceph-operator</code> and <code>rook-ceph-tools</code>, again. This time OSD daemons are present and should be removed too.</li> <li>Bring the Rook Ceph operator back online by running <code>kubectl -n rook-ceph edit deploy/rook-ceph-operator</code> and set <code>replicas</code> to <code>1</code>.</li> <li>Watch the operator logs with <code>kubectl -n rook-ceph logs -f rook-ceph-operator-xxxxxxx</code>, and wait until the orchestration has settled.</li> <li>STATE: Now the new cluster should be up and running with authentication enabled. <code>ceph -s</code> output should not change much comparing to previous steps.</li> </ol>"},{"location":"Troubleshooting/disaster-recovery/#backing-up-and-restoring-a-cluster-based-on-pvcs-into-a-new-kubernetes-cluster","title":"Backing up and restoring a cluster based on PVCs into a new Kubernetes cluster","text":"<p>It is possible to migrate/restore an rook/ceph cluster from an existing Kubernetes cluster to a new one without resorting to SSH access or ceph tooling. This allows doing the migration using standard kubernetes resources only. This guide assumes the following:</p> <ol> <li>You have a CephCluster that uses PVCs to persist mon and osd data. Let's call it the \"old cluster\"</li> <li>You can restore the PVCs as-is in the new cluster. Usually this is done by taking regular snapshots of the PVC volumes and using a tool that can re-create PVCs from these snapshots in the underlying cloud provider. Velero is one such tool.</li> <li>You have regular backups of the secrets and configmaps in the rook-ceph namespace. Velero provides this functionality too.</li> </ol> <p>Do the following in the new cluster:</p> <ol> <li>Stop the rook operator by scaling the deployment <code>rook-ceph-operator</code> down to zero: <code>kubectl -n rook-ceph scale deployment rook-ceph-operator --replicas 0</code> and deleting the other deployments. An example command to do this is <code>k -n rook-ceph delete deployment -l operator!=rook</code></li> <li>Restore the rook PVCs to the new cluster.</li> <li>Copy the keyring and fsid secrets from the old cluster: <code>rook-ceph-mgr-a-keyring</code>, <code>rook-ceph-mon</code>, <code>rook-ceph-mons-keyring</code>, <code>rook-ceph-osd-0-keyring</code>, ...</li> <li>Delete mon services and copy them from the old cluster: <code>rook-ceph-mon-a</code>, <code>rook-ceph-mon-b</code>, ... Note that simply re-applying won't work because the goal here is to restore the <code>clusterIP</code> in each service and this field is immutable in <code>Service</code> resources.</li> <li>Copy the endpoints configmap from the old cluster: <code>rook-ceph-mon-endpoints</code></li> <li>Scale the rook operator up again : <code>kubectl -n rook-ceph scale deployment rook-ceph-operator --replicas 1</code></li> <li>Wait until the reconciliation is over.</li> </ol>"},{"location":"Troubleshooting/disaster-recovery/#restoring-the-rook-cluster-after-the-rook-namespace-is-deleted","title":"Restoring the Rook cluster after the Rook namespace is deleted","text":"<p>When the rook-ceph namespace is accidentally deleted, the good news is that the cluster can be restored. With the content in the directory <code>dataDirHostPath</code> and the original OSD disks, the ceph cluster could be restored with this guide.</p> <p>You need to manually create a ConfigMap and a Secret to make it work. The information required for the ConfigMap and Secret can be found in the <code>dataDirHostPath</code> directory.</p> <p>The first resource is the secret named <code>rook-ceph-mon</code> as seen in this example below:</p> <pre><code>apiVersion: v1\ndata:\n\u00a0 ceph-secret: QVFCZ0h6VmorcVNhSGhBQXVtVktNcjcrczNOWW9Oa2psYkErS0E9PQ==\n\u00a0 ceph-username: Y2xpZW50LmFkbWlu\n\u00a0 fsid: M2YyNzE4NDEtNjE4OC00N2MxLWIzZmQtOTBmZDRmOTc4Yzc2\n\u00a0 mon-secret: QVFCZ0h6VmorcVNhSGhBQXVtVktNcjcrczNOWW9Oa2psYkErS0E9PQ==\nkind: Secret\nmetadata:\n\u00a0 finalizers:\n\u00a0 - ceph.rook.io/disaster-protection\n\u00a0 name: rook-ceph-mon\n\u00a0 namespace: rook-ceph\n\u00a0 ownerReferences: null\ntype: kubernetes.io/rook\n</code></pre> <p>The values for the secret can be found in <code>$dataDirHostPath/rook-ceph/client.admin.keyring</code> and <code>$dataDirHostPath/rook-ceph/rook-ceph.config</code>.</p> <ul> <li><code>ceph-secret</code> and <code>mon-secret</code> are to be filled with the <code>client.admin</code>'s keyring contents.</li> <li><code>ceph-username</code>: set to the string <code>client.admin</code></li> <li><code>fsid</code>: set to the original ceph cluster id.</li> </ul> <p>All the fields in data section need to be encoded in base64. Coding could be done like this:</p> <pre><code>echo -n \"string to code\" | base64 -i -\n</code></pre> <p>Now save the secret as <code>rook-ceph-mon.yaml</code>, to be created later in the restore.</p> <p>The second resource is the configmap named rook-ceph-mon-endpoints as seen in this example below:</p> <pre><code>apiVersion: v1\ndata:\n\u00a0 csi-cluster-config-json: '[{\"clusterID\":\"rook-ceph\",\"monitors\":[\"169.169.241.153:6789\",\"169.169.82.57:6789\",\"169.169.7.81:6789\"],\"namespace\":\"\"}]'\n\u00a0 data: k=169.169.241.153:6789,m=169.169.82.57:6789,o=169.169.7.81:6789\n\u00a0 mapping: '{\"node\":{\"k\":{\"Name\":\"10.138.55.111\",\"Hostname\":\"10.138.55.111\",\"Address\":\"10.138.55.111\"},\"m\":{\"Name\":\"10.138.55.120\",\"Hostname\":\"10.138.55.120\",\"Address\":\"10.138.55.120\"},\"o\":{\"Name\":\"10.138.55.112\",\"Hostname\":\"10.138.55.112\",\"Address\":\"10.138.55.112\"}}}'\n\u00a0 maxMonId: \"15\"\nkind: ConfigMap\nmetadata:\n\u00a0 finalizers:\n\u00a0 - ceph.rook.io/disaster-protection\n\u00a0 name: rook-ceph-mon-endpoints\n\u00a0 namespace: rook-ceph\n\u00a0 ownerReferences: null\n</code></pre> <p>The Monitor's service IPs are kept in the monitor data store and you need to create them by original ones. After you create this configmap with the original service IPs, the rook operator will create the correct services for you with IPs matching in the monitor data store. Along with monitor ids, their service IPs and mapping relationship of them can be found in dataDirHostPath/rook-ceph/rook-ceph.config, for example:</p> <pre><code>[global]\nfsid\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = 3f271841-6188-47c1-b3fd-90fd4f978c76\nmon initial members = m o k\nmon host\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = [v2:169.169.82.57:3300,v1:169.169.82.57:6789],[v2:169.169.7.81:3300,v1:169.169.7.81:6789],[v2:169.169.241.153:3300,v1:169.169.241.153:6789]\n</code></pre> <p><code>mon initial members</code> and <code>mon host</code> are holding sequences of monitors' id and IP respectively; the sequence are going in the same order among monitors as a result you can tell which monitors have which service IP addresses. Modify your <code>rook-ceph-mon-endpoints.yaml</code> on fields <code>csi-cluster-config-json</code> and <code>data</code> based on the understanding of <code>rook-ceph.config</code> above. The field <code>mapping</code> tells rook where to schedule monitor's pods. you could search in <code>dataDirHostPath</code> in all Ceph cluster hosts for <code>mon-m,mon-o,mon-k</code>. If you find <code>mon-m</code> in host <code>10.138.55.120</code>, you should fill <code>10.138.55.120</code> in field <code>mapping</code> for <code>m</code>. Others are the same. Update the <code>maxMonId</code> to be the max numeric ID of the highest monitor ID. For example, 15 is the 0-based ID for mon <code>o</code>. Now save this configmap in the file rook-ceph-mon-endpoints.yaml, to be created later in the restore.</p> <p>Now that you have the info for the secret and the configmap, you are ready to restore the running cluster.</p> <p>Deploy Rook Ceph using the YAML files or Helm, with the same settings you had previously.</p> <pre><code>kubectl create -f crds.yaml -f common.yaml -f operator.yaml\n</code></pre> <p>After the operator is running, create the configmap and secret you have just crafted:</p> <pre><code>kubectl create -f rook-ceph-mon.yaml -f rook-ceph-mon-endpoints.yaml\n</code></pre> <p>Create your Ceph cluster CR (if possible, with the same settings as existed previously):</p> <pre><code>kubectl create -f cluster.yaml\n</code></pre> <p>Now your Rook Ceph cluster should be running again.</p>"},{"location":"Troubleshooting/kubectl-plugin/","title":"kubectl Plugin","text":"<p>The Rook kubectl plugin is a tool to help troubleshoot your Rook cluster. Here are a few of the operations that the plugin will assist with:</p> <ul> <li>Health of the Rook pods</li> <li>Health of the Ceph cluster</li> <li>Create \"debug\" pods for mons and OSDs that are in need of special Ceph maintenance operations</li> <li>Restart the operator</li> <li>Purge an OSD</li> <li>Run any <code>ceph</code> command</li> </ul> <p>See the kubectl-rook-ceph documentation for more details.</p>"},{"location":"Troubleshooting/kubectl-plugin/#installation","title":"Installation","text":"<ul> <li>Install krew</li> <li> <p>Install Rook plugin</p> <pre><code>kubectl krew install rook-ceph\n</code></pre> </li> </ul>"},{"location":"Troubleshooting/kubectl-plugin/#ceph-commands","title":"Ceph Commands","text":"<ul> <li> <p>Run any <code>ceph</code> command with <code>kubectl rook-ceph ceph &lt;args&gt;</code>. For example, get the Ceph status:</p> <pre><code>kubectl rook-ceph ceph status\n</code></pre> <p>Output:</p> <pre><code>    cluster:\n    id:     a1ac6554-4cc8-4c3b-a8a3-f17f5ec6f529\n    health: HEALTH_OK\n\n    services:\n    mon: 3 daemons, quorum a,b,c (age 11m)\n    mgr: a(active, since 10m)\n    mds: 1/1 daemons up, 1 hot standby\n    osd: 3 osds: 3 up (since 10m), 3 in (since 8d)\n\n    data:\n    volumes: 1/1 healthy\n    pools:   6 pools, 137 pgs\n    objects: 34 objects, 4.1 KiB\n    usage:   58 MiB used, 59 GiB / 59 GiB avail\n    pgs:     137 active+clean\n\n    io:\n    client:   1.2 KiB/s rd, 2 op/s rd, 0 op/s wr\n</code></pre> </li> </ul> <p>Reference: Ceph Status</p>"},{"location":"Troubleshooting/kubectl-plugin/#debug-mode","title":"Debug Mode","text":"<p>Debug mode can be useful when a MON or OSD needs advanced maintenance operations that require the daemon to be stopped. Ceph tools such as <code>ceph-objectstore-tool</code>, <code>ceph-bluestore-tool</code>, or <code>ceph-monstore-tool</code> are commonly used in these scenarios. Debug mode will set up the MON or OSD so that these commands can be run.</p> <ul> <li> <p>Start the debug pod for mon b</p> <pre><code>kubectl rook-ceph debug start rook-ceph-mon-b\n</code></pre> </li> <li> <p>Stop the debug pod for mon b</p> <pre><code>kubectl rook-ceph debug stop rook-ceph-mon-b\n</code></pre> </li> </ul> <p>Reference: Debug Mode</p>"},{"location":"Troubleshooting/openshift-common-issues/","title":"OpenShift Common Issues","text":""},{"location":"Troubleshooting/openshift-common-issues/#enable-monitoring-in-the-storage-dashboard","title":"Enable Monitoring in the Storage Dashboard","text":"<p>OpenShift Console uses OpenShift Prometheus for monitoring and populating data in Storage Dashboard. Additional configuration is required to monitor the Ceph Cluster from the storage dashboard.</p> <ol> <li> <p>Change the monitoring namespace to <code>openshift-monitoring</code></p> <p>Change the namespace of the RoleBinding <code>rook-ceph-metrics</code> from <code>rook-ceph</code> to <code>openshift-monitoring</code> for the <code>prometheus-k8s</code> ServiceAccount in rbac.yaml.</p> <pre><code>subjects:\n- kind: ServiceAccount\nname: prometheus-k8s\nnamespace: openshift-monitoring\n</code></pre> </li> <li> <p>Enable Ceph Cluster monitoring</p> <p>Follow ceph-monitoring/prometheus-alerts.</p> </li> <li> <p>Set the required label on the namespace</p> <pre><code>oc label namespace rook-ceph \"openshift.io/cluster-monitoring=true\"\n</code></pre> </li> </ol>"},{"location":"Troubleshooting/openshift-common-issues/#troubleshoot-monitoring-issues","title":"Troubleshoot Monitoring Issues","text":"<p>Attention</p> <p>Switch to <code>rook-ceph</code> namespace using <code>oc project rook-ceph</code>.</p> <ol> <li> <p>Ensure ceph-mgr pod is Running</p> <pre><code>$ oc get pods -l app=rook-ceph-mgr\nNAME            READY   STATUS    RESTARTS   AGE\nrook-ceph-mgr   1/1     Running   0          14h\n</code></pre> </li> <li> <p>Ensure service monitor is present</p> <pre><code>$ oc get servicemonitor rook-ceph-mgr\nNAME                          AGE\nrook-ceph-mgr                 14h\n</code></pre> </li> <li> <p>Ensure the prometheus rules object has been created</p> <pre><code>$ oc get prometheusrules -l prometheus=rook-prometheus\nNAME                    AGE\nprometheus-ceph-rules   14h\n</code></pre> </li> </ol>"},{"location":"Troubleshooting/performance-profiling/","title":"Performance Profiling","text":""},{"location":"Troubleshooting/performance-profiling/#collect-perf-data-of-a-ceph-process-at-runtime","title":"Collect perf data of a ceph process at runtime","text":"<p>Warn</p> <p>This is an advanced topic please be aware of the steps you're performing or reach out to the experts for further guidance.</p> <p>There are some cases where the debug logs are not sufficient to investigate issues like high CPU utilization of a Ceph process. In that situation, coredump and perf information of a Ceph process is useful to be collected which can be shared with the Ceph team in an issue.</p> <p>To collect this information, please follow these steps:</p> <ul> <li>Edit the rook-ceph-operator deployment and set <code>ROOK_HOSTPATH_REQUIRES_PRIVILEGED</code> to <code>true</code>.</li> <li>Wait for the pods to get reinitialized:</li> </ul> <pre><code># watch kubectl -n rook-ceph get pods\n</code></pre> <ul> <li>Enter the respective pod of the Ceph process which needs to be investigated. For example:</li> </ul> <pre><code># kubectl -n rook-ceph exec -it deploy/rook-ceph-mon-a -- bash\n</code></pre> <ul> <li>Install <code>gdb</code> , <code>perf</code> and <code>git</code> inside the pod. For example:</li> </ul> <pre><code># dnf install gdb git perf -y\n</code></pre> <ul> <li>Capture perf data of the respective Ceph process:</li> </ul> <pre><code># perf record -e cycles --call-graph dwarf -p &lt;pid of the process&gt;\n# perf report &gt; perf_report_&lt;process/thread&gt;\n</code></pre> <ul> <li>Grab the <code>pid</code> of the respective Ceph process to collect its backtrace at multiple time instances, attach <code>gdb</code> to it and share the output <code>gdb.txt</code>:</li> </ul> <pre><code># gdb -p &lt;pid_of_the_process&gt;\n\n- set pag off\n- set log on\n- thr a a bt full # This captures the complete backtrace of the process\n- backtrace\n- Ctrl+C\n- backtrace\n- Ctrl+C\n- backtrace\n- Ctrl+C\n- backtrace\n- set log off\n- q (to exit out of gdb)\n</code></pre> <ul> <li>Grab the live coredump of the respective process using <code>gcore</code>:</li> </ul> <pre><code># gcore &lt;pid_of_the_process&gt;\n</code></pre> <ul> <li>Capture the Wallclock Profiler data for the respective Ceph process and share the output <code>gdbpmp.data</code> generated:</li> </ul> <pre><code># git clone https://github.com/markhpc/gdbpmp\n# cd gdbpmp\n# ./gdbpmp.py -p &lt;pid_of_the_process&gt; -n 100 -o gdbpmp.data\n</code></pre> <ul> <li>Collect the <code>perf.data</code>, <code>perf_report</code>, backtrace of the process <code>gdb.txt</code> , <code>core</code> file and profiler data <code>gdbpmp.data</code> and upload it to the tracker issue for troubleshooting purposes.</li> </ul>"},{"location":"Upgrade/ceph-upgrade/","title":"Ceph Upgrades","text":"<p>This guide will walk through the steps to upgrade the version of Ceph in a Rook cluster. Rook and Ceph upgrades are designed to ensure data remains available even while the upgrade is proceeding. Rook will perform the upgrades in a rolling fashion such that application pods are not disrupted.</p> <p>Rook is cautious when performing upgrades. When an upgrade is requested (the Ceph image has been updated in the CR), Rook will go through all the daemons one by one and will individually perform checks on them. It will make sure a particular daemon can be stopped before performing the upgrade. Once the deployment has been updated, it checks if this is ok to continue. After each daemon is updated we wait for things to settle (monitors to be in a quorum, PGs to be clean for OSDs, up for MDSes, etc.), then only when the condition is met we move to the next daemon. We repeat this process until all the daemons have been updated.</p>"},{"location":"Upgrade/ceph-upgrade/#considerations","title":"Considerations","text":"<ul> <li>WARNING: Upgrading a Rook cluster is not without risk. There may be unexpected issues or     obstacles that damage the integrity and health of the storage cluster, including data loss.</li> <li>The Rook cluster's storage may be unavailable for short periods during the upgrade process.</li> <li>Read this document in full before undertaking a Rook cluster upgrade.</li> </ul>"},{"location":"Upgrade/ceph-upgrade/#supported-versions","title":"Supported Versions","text":"<p>Rook v1.16 supports the following Ceph versions:</p> <ul> <li>Ceph Squid v19.2.0 or newer</li> <li>Ceph Reef v18.2.0 or newer</li> </ul> <p>Important</p> <p>When an update is requested, the operator will check Ceph's status, if it is in <code>HEALTH_ERR</code> the operator will refuse to proceed with the upgrade.</p>"},{"location":"Upgrade/ceph-upgrade/#ceph-images","title":"Ceph Images","text":"<p>Official Ceph container images can be found on Quay.</p> <p>These images are tagged in a few ways:</p> <ul> <li>The most explicit form of tags are full-ceph-version-and-build tags (e.g., <code>v19.2.0-20240927</code>).     These tags are recommended for production clusters, as there is no possibility for the cluster to     be heterogeneous with respect to the version of Ceph running in containers.</li> <li>Ceph major version tags (e.g., <code>v18</code>) are useful for development and test clusters so that the     latest version of Ceph is always available.</li> </ul> <p>Ceph containers other than the official images from the registry above will not be supported.</p>"},{"location":"Upgrade/ceph-upgrade/#example-upgrade-to-ceph-reef","title":"Example Upgrade to Ceph Reef","text":""},{"location":"Upgrade/ceph-upgrade/#1-update-the-ceph-daemons","title":"1. Update the Ceph daemons","text":"<p>The upgrade will be automated by the Rook operator after the desired Ceph image is changed in the CephCluster CRD (<code>spec.cephVersion.image</code>).</p> <pre><code>ROOK_CLUSTER_NAMESPACE=rook-ceph\nNEW_CEPH_IMAGE='quay.io/ceph/ceph:v19.2.0-20240927'\nkubectl -n $ROOK_CLUSTER_NAMESPACE patch CephCluster $ROOK_CLUSTER_NAMESPACE --type=merge -p \"{\\\"spec\\\": {\\\"cephVersion\\\": {\\\"image\\\": \\\"$NEW_CEPH_IMAGE\\\"}}}\"\n</code></pre>"},{"location":"Upgrade/ceph-upgrade/#2-update-the-toolbox-image","title":"2. Update the toolbox image","text":"<p>Since the Rook toolbox is not controlled by the Rook operator, users must perform a manual upgrade by modifying the <code>image</code> to match the ceph version employed by the new Rook operator release. Employing an outdated Ceph version within the toolbox may result in unexpected behaviour.</p> <pre><code>kubectl -n rook-ceph set image deploy/rook-ceph-tools rook-ceph-tools=quay.io/ceph/ceph:v19.2.0-20240927\n</code></pre>"},{"location":"Upgrade/ceph-upgrade/#3-wait-for-the-pod-updates","title":"3. Wait for the pod updates","text":"<p>As with upgrading Rook, now wait for the upgrade to complete. Status can be determined in a similar way to the Rook upgrade as well.</p> <pre><code>watch --exec kubectl -n $ROOK_CLUSTER_NAMESPACE get deployments -l rook_cluster=$ROOK_CLUSTER_NAMESPACE -o jsonpath='{range .items[*]}{.metadata.name}{\"  \\treq/upd/avl: \"}{.spec.replicas}{\"/\"}{.status.updatedReplicas}{\"/\"}{.status.readyReplicas}{\"  \\tceph-version=\"}{.metadata.labels.ceph-version}{\"\\n\"}{end}'\n</code></pre> <p>Confirm the upgrade is completed when the versions are all on the desired Ceph version.</p> <pre><code>kubectl -n $ROOK_CLUSTER_NAMESPACE get deployment -l rook_cluster=$ROOK_CLUSTER_NAMESPACE -o jsonpath='{range .items[*]}{\"ceph-version=\"}{.metadata.labels.ceph-version}{\"\\n\"}{end}' | sort | uniq\nThis cluster is not yet finished:\n    ceph-version=v18.2.4-0\n    ceph-version=v19.2.0-0\nThis cluster is finished:\n    ceph-version=v19.2.0-0\n</code></pre>"},{"location":"Upgrade/ceph-upgrade/#4-verify-cluster-health","title":"4. Verify cluster health","text":"<p>Verify the Ceph cluster's health using the health verification.</p>"},{"location":"Upgrade/health-verification/","title":"Health Verification","text":"<p>Rook and Ceph upgrades are designed to ensure data remains available even while the upgrade is proceeding. Rook will perform the upgrades in a rolling fashion such that application pods are not disrupted. To ensure the upgrades are seamless, it is important to begin the upgrades with Ceph in a fully healthy state. This guide reviews ways of verifying the health of a CephCluster.</p> <p>See the troubleshooting documentation for any issues during upgrades:</p> <ul> <li>General K8s troubleshooting</li> <li>Ceph common issues</li> <li>CSI common issues</li> </ul>"},{"location":"Upgrade/health-verification/#pods-all-running","title":"Pods all Running","text":"<p>In a healthy Rook cluster, all pods in the Rook namespace should be in the <code>Running</code> (or <code>Completed</code>) state and have few, if any, pod restarts.</p> <pre><code>ROOK_CLUSTER_NAMESPACE=rook-ceph\nkubectl -n $ROOK_CLUSTER_NAMESPACE get pods\n</code></pre>"},{"location":"Upgrade/health-verification/#status-output","title":"Status Output","text":"<p>The Rook toolbox contains the Ceph tools that gives status details of the cluster with the <code>ceph status</code> command. Below is an output sample:</p> <pre><code>TOOLS_POD=$(kubectl -n $ROOK_CLUSTER_NAMESPACE get pod -l \"app=rook-ceph-tools\" -o jsonpath='{.items[*].metadata.name}')\nkubectl -n $ROOK_CLUSTER_NAMESPACE exec -it $TOOLS_POD -- ceph status\n</code></pre> <p>The output should look similar to the following:</p> <pre><code>  cluster:\n    id:     a3f4d647-9538-4aff-9fd1-b845873c3fe9\n    health: HEALTH_OK\n\n  services:\n    mon: 3 daemons, quorum b,c,a\n    mgr: a(active)\n    mds: myfs-1/1/1 up  {0=myfs-a=up:active}, 1 up:standby-replay\n    osd: 6 osds: 6 up, 6 in\n    rgw: 1 daemon active\n\n  data:\n    pools:   9 pools, 900 pgs\n    objects: 67  objects, 11 KiB\n    usage:   6.1 GiB used, 54 GiB / 60 GiB avail\n    pgs:     900 active+clean\n\n  io:\n    client:   7.4 KiB/s rd, 681 B/s wr, 11 op/s rd, 4 op/s wr\n    recovery: 164 B/s, 1 objects/s\n</code></pre> <p>In the output above, note the following indications that the cluster is in a healthy state:</p> <ul> <li>Cluster health: The overall cluster status is <code>HEALTH_OK</code> and there are no warning or error status     messages displayed.</li> <li>Monitors (mon):  All of the monitors are included in the <code>quorum</code> list.</li> <li>Manager (mgr): The Ceph manager is in the <code>active</code> state.</li> <li>OSDs (osd): All OSDs are <code>up</code> and <code>in</code>.</li> <li>Placement groups (pgs): All PGs are in the <code>active+clean</code> state.</li> <li>(If applicable) Ceph filesystem metadata server (mds): all MDSes are <code>active</code> for all filesystems</li> <li>(If applicable) Ceph object store RADOS gateways (rgw): all daemons are <code>active</code></li> </ul> <p>If the <code>ceph status</code> output has deviations from the general good health described above, there may be an issue that needs to be investigated further. Other commands may show more relevant details on the health of the system, such as <code>ceph osd status</code>. See the Ceph troubleshooting docs for help.</p>"},{"location":"Upgrade/health-verification/#upgrading-an-unhealthy-cluster","title":"Upgrading an unhealthy cluster","text":"<p>Rook will not upgrade Ceph daemons if the health is in a <code>HEALTH_ERR</code> state. Rook can be configured to proceed with the (potentially unsafe) upgrade by setting either <code>skipUpgradeChecks: true</code> or <code>continueUpgradeAfterChecksEvenIfNotHealthy: true</code> as described in the cluster CR settings.</p>"},{"location":"Upgrade/health-verification/#container-versions","title":"Container Versions","text":"<p>The container version running in a specific pod in the Rook cluster can be verified in its pod spec output. For example, for the monitor pod <code>mon-b</code>, verify the container version it is running with the below commands:</p> <pre><code>POD_NAME=$(kubectl -n $ROOK_CLUSTER_NAMESPACE get pod -o custom-columns=name:.metadata.name --no-headers | grep rook-ceph-mon-b)\nkubectl -n $ROOK_CLUSTER_NAMESPACE get pod ${POD_NAME} -o jsonpath='{.spec.containers[0].image}'\n</code></pre> <p>The status and container versions for all Rook pods can be collected all at once with the following commands:</p> <pre><code>kubectl -n $ROOK_OPERATOR_NAMESPACE get pod -o jsonpath='{range .items[*]}{.metadata.name}{\"\\n\\t\"}{.status.phase}{\"\\t\\t\"}{.spec.containers[0].image}{\"\\t\"}{.spec.initContainers[0]}{\"\\n\"}{end}' &amp;&amp; \\\nkubectl -n $ROOK_CLUSTER_NAMESPACE get pod -o jsonpath='{range .items[*]}{.metadata.name}{\"\\n\\t\"}{.status.phase}{\"\\t\\t\"}{.spec.containers[0].image}{\"\\t\"}{.spec.initContainers[0].image}{\"\\n\"}{end}'\n</code></pre> <p>The <code>rook-version</code> label exists on Ceph resources. For various resource controllers, a summary of the resource controllers can be gained with the commands below. These will report the requested, updated, and currently available replicas for various Rook resources in addition to the version of Rook for resources managed by Rook. Note that the operator and toolbox deployments do not have a <code>rook-version</code> label set.</p> <pre><code>kubectl -n $ROOK_CLUSTER_NAMESPACE get deployments -o jsonpath='{range .items[*]}{.metadata.name}{\"  \\treq/upd/avl: \"}{.spec.replicas}{\"/\"}{.status.updatedReplicas}{\"/\"}{.status.readyReplicas}{\"  \\trook-version=\"}{.metadata.labels.rook-version}{\"\\n\"}{end}'\n\nkubectl -n $ROOK_CLUSTER_NAMESPACE get jobs -o jsonpath='{range .items[*]}{.metadata.name}{\"  \\tsucceeded: \"}{.status.succeeded}{\"      \\trook-version=\"}{.metadata.labels.rook-version}{\"\\n\"}{end}'\n</code></pre>"},{"location":"Upgrade/health-verification/#rook-volume-health","title":"Rook Volume Health","text":"<p>Any pod that is using a Rook volume should also remain healthy:</p> <ul> <li>The pod should be in the <code>Running</code> state with few, if any, restarts</li> <li>There should be no errors in its logs</li> <li>The pod should still be able to read and write to the attached Rook volume.</li> </ul>"},{"location":"Upgrade/rook-upgrade/","title":"Rook Upgrades","text":"<p>This guide will walk through the steps to upgrade the software in a Rook cluster from one version to the next. This guide focuses on updating the Rook version for the management layer, while the Ceph upgrade guide focuses on updating the data layer.</p> <p>Upgrades for both the operator and for Ceph are entirely automated except where Rook's permissions need to be explicitly updated by an admin or when incompatibilities need to be addressed manually due to customizations.</p> <p>We welcome feedback and opening issues!</p>"},{"location":"Upgrade/rook-upgrade/#supported-versions","title":"Supported Versions","text":"<p>This guide is for upgrading from Rook v1.15.x to Rook v1.16.x.</p> <p>Please refer to the upgrade guides from previous releases for supported upgrade paths. Rook upgrades are only supported between official releases.</p> <p>For a guide to upgrade previous versions of Rook, please refer to the version of documentation for those releases.</p> <ul> <li>Upgrade 1.14 to 1.15</li> <li>Upgrade 1.13 to 1.14</li> <li>Upgrade 1.12 to 1.13</li> <li>Upgrade 1.11 to 1.12</li> <li>Upgrade 1.10 to 1.11</li> <li>Upgrade 1.9 to 1.10</li> <li>Upgrade 1.8 to 1.9</li> <li>Upgrade 1.7 to 1.8</li> <li>Upgrade 1.6 to 1.7</li> <li>Upgrade 1.5 to 1.6</li> <li>Upgrade 1.4 to 1.5</li> <li>Upgrade 1.3 to 1.4</li> <li>Upgrade 1.2 to 1.3</li> <li>Upgrade 1.1 to 1.2</li> <li>Upgrade 1.0 to 1.1</li> <li>Upgrade 0.9 to 1.0</li> <li>Upgrade 0.8 to 0.9</li> <li>Upgrade 0.7 to 0.8</li> <li>Upgrade 0.6 to 0.7</li> <li>Upgrade 0.5 to 0.6</li> </ul> <p>Important</p> <p>Rook releases from master are expressly unsupported. It is strongly recommended to use official releases of Rook. Unreleased versions from the master branch are subject to changes and incompatibilities that will not be supported in the official releases. Builds from the master branch can have functionality changed or removed at any time without compatibility support and without prior notice.</p>"},{"location":"Upgrade/rook-upgrade/#breaking-changes-in-v116","title":"Breaking changes in v1.16","text":"<ul> <li> <p>The minimum supported Kubernetes version is v1.27.</p> </li> <li> <p>Rook no longer supports Ceph v17 (Quincy) as it is end of life. Rook v1.15 clusters should     upgrade Ceph to at least Ceph v18 (Reef) before upgrading Rook to v1.16.     Be aware of known Ceph v18.2.4 ARM issues.</p> </li> <li> <p>Rook fully deprecated CSI \"holder\" pods in Rook v1.16. Any Rook v1.15 CephCluster with     <code>csi-*plugin-holder-*</code> pods present in the Rook operator namespace must follow holder pod     removal migration steps outlined in     v1.15 documentation.</p> </li> </ul>"},{"location":"Upgrade/rook-upgrade/#considerations","title":"Considerations","text":"<p>With this upgrade guide, there are a few notes to consider:</p> <ul> <li>WARNING: Upgrading a Rook cluster is not without risk. There may be unexpected issues or     obstacles that damage the integrity and health the storage cluster, including data loss.</li> <li>The Rook cluster's storage may be unavailable for short periods during the upgrade process for     both Rook operator updates and for Ceph version updates.</li> <li>Read this document in full before undertaking a Rook cluster upgrade.</li> </ul>"},{"location":"Upgrade/rook-upgrade/#patch-release-upgrades","title":"Patch Release Upgrades","text":"<p>Unless otherwise noted due to extenuating requirements, upgrades from one patch release of Rook to another are as simple as updating the common resources and the image of the Rook operator. For example, when Rook v1.16.1 is released, the process of updating from v1.16.0 is as simple as running the following:</p> <pre><code>git clone --single-branch --depth=1 --branch v1.16.1 https://github.com/rook/rook.git\ncd rook/deploy/examples\n</code></pre> <p>If the Rook Operator or CephCluster are deployed into a different namespace than <code>rook-ceph</code>, see the Update common resources and CRDs section for instructions on how to change the default namespaces in <code>common.yaml</code>.</p> <p>Then, apply the latest changes from v1.16, and update the Rook Operator image.</p> <pre><code>kubectl apply -f common.yaml -f crds.yaml\nkubectl -n rook-ceph set image deploy/rook-ceph-operator rook-ceph-operator=rook/ceph:v1.16.1\n</code></pre> <p>As exemplified above, it is a good practice to update Rook common resources from the example manifests before any update. The common resources and CRDs might not be updated with every release, but Kubernetes will only apply updates to the ones that changed.</p> <p>Also update optional resources like Prometheus monitoring noted more fully in the upgrade section below.</p>"},{"location":"Upgrade/rook-upgrade/#helm","title":"Helm","text":"<p>If Rook is installed via the Helm chart, Helm will handle some details of the upgrade itself. The upgrade steps in this guide will clarify what Helm handles automatically.</p> <p>The <code>rook-ceph</code> helm chart upgrade performs the Rook upgrade. The <code>rook-ceph-cluster</code> helm chart upgrade performs a Ceph upgrade if the Ceph image is updated. The <code>rook-ceph</code> chart should be upgraded before <code>rook-ceph-cluster</code>, so the latest operator has the opportunity to update custom resources as necessary.</p> <p>Note</p> <p>Be sure to update to a supported Helm version</p>"},{"location":"Upgrade/rook-upgrade/#cluster-health","title":"Cluster Health","text":"<p>In order to successfully upgrade a Rook cluster, the following prerequisites must be met:</p> <ul> <li>The cluster should be in a healthy state with full functionality. Review the     health verification guide in order to verify a CephCluster is in a good     starting state.</li> <li>All pods consuming Rook storage should be created, running, and in a steady state.</li> </ul>"},{"location":"Upgrade/rook-upgrade/#rook-operator-upgrade","title":"Rook Operator Upgrade","text":"<p>The examples given in this guide upgrade a live Rook cluster running <code>v1.15.6</code> to the version <code>v1.16.0</code>. This upgrade should work from any official patch release of Rook v1.15 to any official patch release of v1.16.</p> <p>Let's get started!</p>"},{"location":"Upgrade/rook-upgrade/#environment","title":"Environment","text":"<p>These instructions will work for as long the environment is parameterized correctly. Set the following environment variables, which will be used throughout this document.</p> <pre><code># Parameterize the environment\nexport ROOK_OPERATOR_NAMESPACE=rook-ceph\nexport ROOK_CLUSTER_NAMESPACE=rook-ceph\n</code></pre>"},{"location":"Upgrade/rook-upgrade/#1-update-common-resources-and-crds","title":"1. Update common resources and CRDs","text":"<p>Hint</p> <p>Common resources and CRDs are automatically updated when using Helm charts.</p> <p>First, apply updates to Rook common resources. This includes modified privileges (RBAC) needed by the Operator. Also update the Custom Resource Definitions (CRDs).</p> <p>Get the latest common resources manifests that contain the latest changes.</p> <pre><code>git clone --single-branch --depth=1 --branch master https://github.com/rook/rook.git\ncd rook/deploy/examples\n</code></pre> <p>If the Rook Operator or CephCluster are deployed into a different namespace than <code>rook-ceph</code>, update the common resource manifests to use your <code>ROOK_OPERATOR_NAMESPACE</code> and <code>ROOK_CLUSTER_NAMESPACE</code> using <code>sed</code>.</p> <pre><code>sed -i.bak \\\n    -e \"s/\\(.*\\):.*# namespace:operator/\\1: $ROOK_OPERATOR_NAMESPACE # namespace:operator/g\" \\\n    -e \"s/\\(.*\\):.*# namespace:cluster/\\1: $ROOK_CLUSTER_NAMESPACE # namespace:cluster/g\" \\\n  common.yaml\n</code></pre> <p>Apply the resources.</p> <pre><code>kubectl apply -f common.yaml -f crds.yaml\n</code></pre>"},{"location":"Upgrade/rook-upgrade/#prometheus-updates","title":"Prometheus Updates","text":"<p>If Prometheus monitoring is enabled, follow this step to upgrade the Prometheus RBAC resources as well.</p> <pre><code>kubectl apply -f deploy/examples/monitoring/rbac.yaml\n</code></pre>"},{"location":"Upgrade/rook-upgrade/#2-update-the-rook-operator","title":"2. Update the Rook Operator","text":"<p>Hint</p> <p>The operator is automatically updated when using Helm charts.</p> <p>The largest portion of the upgrade is triggered when the operator's image is updated to <code>v1.16.x</code>. When the operator is updated, it will proceed to update all of the Ceph daemons.</p> <pre><code>kubectl -n $ROOK_OPERATOR_NAMESPACE set image deploy/rook-ceph-operator rook-ceph-operator=rook/ceph:master\n</code></pre>"},{"location":"Upgrade/rook-upgrade/#3-update-ceph-csi","title":"3. Update Ceph CSI","text":"<p>Hint</p> <p>This is automatically updated if custom CSI image versions are not set.</p> <p>Important</p> <p>The minimum supported version of Ceph-CSI is v3.8.0.</p> <p>Update to the latest Ceph-CSI drivers if custom CSI images are specified. See the CSI Custom Images documentation.</p> <p>Note</p> <p>If using snapshots, refer to the Upgrade Snapshot API guide.</p>"},{"location":"Upgrade/rook-upgrade/#4-wait-for-the-upgrade-to-complete","title":"4. Wait for the upgrade to complete","text":"<p>Watch now in amazement as the Ceph mons, mgrs, OSDs, rbd-mirrors, MDSes and RGWs are terminated and replaced with updated versions in sequence. The cluster may be unresponsive very briefly as mons update, and the Ceph Filesystem may fall offline a few times while the MDSes are upgrading. This is normal.</p> <p>The versions of the components can be viewed as they are updated:</p> <pre><code>watch --exec kubectl -n $ROOK_CLUSTER_NAMESPACE get deployments -l rook_cluster=$ROOK_CLUSTER_NAMESPACE -o jsonpath='{range .items[*]}{.metadata.name}{\"  \\treq/upd/avl: \"}{.spec.replicas}{\"/\"}{.status.updatedReplicas}{\"/\"}{.status.readyReplicas}{\"  \\trook-version=\"}{.metadata.labels.rook-version}{\"\\n\"}{end}'\n</code></pre> <p>As an example, this cluster is midway through updating the OSDs. When all deployments report <code>1/1/1</code> availability and <code>rook-version=v1.16.0</code>, the Ceph cluster's core components are fully updated.</p> <pre><code>Every 2.0s: kubectl -n rook-ceph get deployment -o j...\n\nrook-ceph-mgr-a         req/upd/avl: 1/1/1      rook-version=v1.16.0\nrook-ceph-mon-a         req/upd/avl: 1/1/1      rook-version=v1.16.0\nrook-ceph-mon-b         req/upd/avl: 1/1/1      rook-version=v1.16.0\nrook-ceph-mon-c         req/upd/avl: 1/1/1      rook-version=v1.16.0\nrook-ceph-osd-0         req/upd/avl: 1//        rook-version=v1.16.0\nrook-ceph-osd-1         req/upd/avl: 1/1/1      rook-version=v1.15.6\nrook-ceph-osd-2         req/upd/avl: 1/1/1      rook-version=v1.15.6\n</code></pre> <p>An easy check to see if the upgrade is totally finished is to check that there is only one <code>rook-version</code> reported across the cluster.</p> <pre><code># kubectl -n $ROOK_CLUSTER_NAMESPACE get deployment -l rook_cluster=$ROOK_CLUSTER_NAMESPACE -o jsonpath='{range .items[*]}{\"rook-version=\"}{.metadata.labels.rook-version}{\"\\n\"}{end}' | sort | uniq\nThis cluster is not yet finished:\n  rook-version=v1.15.6\n  rook-version=v1.16.0\nThis cluster is finished:\n  rook-version=v1.16.0\n</code></pre>"},{"location":"Upgrade/rook-upgrade/#5-verify-the-updated-cluster","title":"5. Verify the updated cluster","text":"<p>At this point, the Rook operator should be running version <code>rook/ceph:v1.16.0</code>.</p> <p>Verify the CephCluster health using the health verification doc.</p>"}]}